Cache for Windows^INT^routine output by %apiRTN^^~Format=Cache.S~
%RO on 29 May 2020 01:33:04PM
BACTchat^INT^1^65478,56127.036718^0
BACTchat	;Chat
.
	;Ulozeni noveho prispevku
New(Txt,User)
	n i,j,Idx
	s i=$h
	s Idx=$p(i,",")_"#"_$j($p(i,",",2),6)_"#",j=1
	l +^Chat
	f  q:'$d(^Chat(Idx_j))  s j=j+1
	s Idx=Idx_j
	s ^Chat(Idx,1)=$g(^User("A",User,"Name")),^Chat(Idx,2)=$tr($zdt(i,4),"/","."),^Chat(Idx,3)=Txt
	l -^Chat
 	q
 	
 	;Smazani vsech chatu
Delete
	k ^Chat
 	q
 	
 

BACTlog^INT^1^65517,31843.122356^0
BACTlog	; Log
.
	;Zapis logu k patogenu
Log(Code,User,Txt)
	n i,j,Idx
	;Vypocet indexu
	s i=$h
	s Idx=$p(i,",")_"#"_$j($p(i,",",2),6)_"#",j=1
	l +^Bact(Code,"LOG")
	f  q:'$d(^Bact(Code,"LOG",Idx_j))  s j=j+1
	s Idx=Idx_j
	i $g(User)="" s j="???"
	e  s j=$g(^User("A",User,"Name"))
	s ^Bact(Code,"LOG",Idx,1)=j,^Bact(Code,"LOG",Idx,2)=$tr($zdt(i,4),"/","."),^Bact(Code,"LOG",Idx,3)=Txt
	l -^Bact(Code,"LOG")
	q
	
	;Zapis obecneho logu	
LogC(User,Txt)
	n i,j,Idx
	;Vypocet indexu
	s i=$h
	s Idx=$p(i,",")_"#"_$j($p(i,",",2),6)_"#",j=1
	l +^Log
	f  q:'$d(^Log(Idx_j))  s j=j+1
	s Idx=Idx_j
	i $g(User)="" s j="???"
	e  s j=$g(^User("A",User,"Name"))
	s ^Log(Idx,1)=j,^Log(Idx,2)=$tr($zdt(i,4),"/","."),^Log(Idx,3)=Txt
	l -^Log
	q
	

BACTmelt^INT^1^65519,43381^0
BACTmelt	;Melt
	
	;Novy melt
New(Code)
	n Idx,Ref
	l +Bact(Code,"MELT"):10
	e  s Txt="S daty nekdo pracuje !" q 4
	
	s Idx=$zp(^Bact(Code,"MELT",""))+1
	s Ref=$na(^Bact(Code,"MELT",Idx))
	d Calc(Code,Ref)
	d Head(Ref,"C")
	l -^Bact(Code,"MELT")
	d Log^BACTlog(Code,$g(C("USER")),"Vypocet MELT")
	q 0
	
	;Smazani meltu
Del(Code,Idx)
	l +Bact(Code,"MELT"):10
	e  s Txt="S daty nekdo pracuje !" q 4
	
	k ^Bact(Code,"MELT",Idx)
	l -^Bact(Code,"MELT")
	d Log^BACTlog(Code,$g(C("USER")),"Smazani MELT")
	q 0
.
	;Nacteni ze souboru
Load(Code,Place)	
	n Idx,Ref
	;Kontrola hlavicky
	;Vlastni nacteni
	l +Bact(Code,"MELT"):10
	e  s Txt="S daty nekdo pracuje !" q 4
	s Idx=$zp(^Bact(Code,"MELT",""))+1
	s Ref=$na(^Bact(Code,"MELT",Idx))
	m @Ref@("D")=@Place
	d Head(Ref,"I")
	l -^Bact(Code,"MELT")
	d Log^BACTlog(Code,$g(C("USER")),"Import MELT")
	q 0
	
	;Ulozeni do souboru
Save(Code,Idx,Place)
	m @Place=^Bact(Code,"MELT",Idx,"D")
	q 0
	
	;Udela hlavicku MELTu
Head(Ref,Status)
	n Uzi
	s @Ref@("A")=$tr($zdt($h,4),"/",".")
	i $g(C("USER"))="" s Uzi="???"
	e  s Uzi=$$GetName^BACTuser(C("USER"))
	s @Ref@("U")=Uzi
	s @Ref@("S")=Status
	q	
	
	;Spocitani MELT
Calc(Code,Place)
	n Gbl,ST,Head,i,j,Data,Alela,ID,Count,PlaceD
	s Gbl=$na(^Bact(Code,"CALC"))
	k @Gbl
	s PlaceD=$na(@Place@("D"))
	k @PlaceD
	m Head=^Bact(Code,"MLSTH")
	s j="ST"
	f i=1:1:Head s j=j_";"_Head(i)
	s j=j_";MELT"
	s Count=1,@PlaceD@(Count)=j
	;Projeti MLST
	s ST=""
	f  s ST=$o(^Bact(Code,"MLST",ST)) q:ST=""  d
	.;Ty, co maji spatna data a jsou vyrazeny, tak nebrat
	.i $g(^Bact(Code,"MLST",ST,"XXX")) q
	.s j=ST
	.f i=1:1:Head s Alela=Head(i) d
	..s ID=$g(^Bact(Code,"MLST",ST,Alela))
	..i ID="" s j=j_";???" q
	..i '$d(@Gbl@(Alela,ID)) d CalcOne(Code,Alela,ID,$na(@Gbl@(Alela,ID)))
	..i '$d(@Gbl@(Alela,ID)) s j=j_";???" q
	..;Vyjimka
	..i $d(@Gbl@(Alela,ID,"X")) s j=j_";"_$g(@Gbl@(Alela,ID,"X")) q
	..;Vzorec=soucet C a G
	..s j=j_";"_($g(@Gbl@(Alela,ID,"S","C"))+$g(@Gbl@(Alela,ID,"S","G")))
	.s Count=Count+1,@PlaceD@(Count)=j
	
	;Prideleni MELTcisel. Setrideni podle velikosti ve sloupcich
	d Sort(PlaceD,Head)
	q
	
	
	;Vypocet jedne alely a FASTu
CalcOne(Code,Alela,ID,Place)
	n FAS,PrimB,PrimE,OK,Seq,Pos,i,j
	k @Place
	s FAS=$g(^Bact(Code,"FAS",Alela,ID))
	i FAS="" q
	;Startovaci sekvence - nalezeni PrimB
	s PrimB="",OK=0
	f  s PrimB=$o(^Bact(Code,"A",Alela,"B",PrimB)) q:PrimB=""  d  q:OK
	.;Vyskyt neni - quit
	.i '$f(FAS,^Bact(Code,"A",Alela,"B",PrimB)) q
	.s OK=1
	.s Pos=$f(FAS,^Bact(Code,"A",Alela,"B",PrimB))
	.s Seq=$e(FAS,Pos,$l(FAS))
	;Pokud neni OK, je chyba....
	i 'OK q
	;Konecna sekvence - nalezeni PrimE
	s PrimE="",OK=0
	f  s PrimE=$o(^Bact(Code,"A",Alela,"E",PrimE)) q:PrimE=""  d  q:OK
	.;Vyskyt neni - quit
	.i '$f(Seq,^Bact(Code,"A",Alela,"E",PrimE)) q
	.s OK=1
	.s Pos=$f(Seq,^Bact(Code,"A",Alela,"E",PrimE))
	.s Seq=$e(Seq,1,Pos-$l(^Bact(Code,"A",Alela,"E",PrimE))-1)
	;Pokud neni OK, je chyba.....
	i 'OK q
	;Zapis,vyhodnoceni - nalezeny usek je v promenne Seq
	s @Place@("D")=Seq
	k Pos
	s Pos("L")=$l(Seq)
	s Pos("PrimB")=PrimB,Pos("PrimE")=PrimE
	f i=1:1:$l(Seq) s j=$e(Seq,i),Pos(j)=$g(Pos(j))+1
	m @Place@("S")=Pos
	;Vyjimky - puleni
	i '$d(^Bact(Code,"VYJ",Alela)) q
	s i=""
	f  s i=$o(^Bact(Code,"VYJ",Alela,i)) q:i=""  i ^Bact(Code,"VYJ",Alela,i,2)=Seq s @Place@("X")=^Bact(Code,"VYJ",Alela,i,1)
	q
	
	;Vlastni setrideni a spocitani MELTcisel
Sort(Place,Num)
	n Tmp,i,j,k,l,Ref,IdMELT
	;Prvni je hlavicka, jedeme od druheho indexu
	s i=1
	f  s i=$o(@Place@(i)) q:i=""  d
	.s j=@Place@(i)
	.s l=""
	.f k=1:1:Num s l=l_$j($p(j,";",k+1),3)_"#"
	.s l=$e(l,1,$l(l)-1)
	.s Tmp(l,i)=""
	
	;Prideleni indexu
	s IdMELT=0
	s i=""
	f  s i=$o(Tmp(i)) q:i=""  d
	.s IdMELT=IdMELT+1
	.s j=""
	.f  s j=$o(Tmp(i,j)) q:j=""  d
	..s k=@Place@(j)
	..s $p(k,";",Num+2)=IdMELT
	..s @Place@(j)=k
	q
	
	;***** Utility pro hledani ******
	
	;Seznam vyjimek
ListX(Code,Place)
	n Alela,ID
	k @Place
	s Alela=""
	f  s Alela=$o(^Bact(Code,"CALC",Alela)) q:Alela=""  d
	.s @Place@(Alela)=""
	.s ID=""
	.f  s ID=$o(^Bact(Code,"CALC",Alela,ID)) q:ID=""  d
	..i $d(^Bact(Code,"CALC",Alela,ID,"X")) s @Place@(Alela,ID)=^Bact(Code,"CALC",Alela,ID,"X")
	
	q
		

BACTmikro^INT^1^65519,43381^0
BACTmikro	;Mikroorganismy
	
	;*********************
	;*  Mikroorganismus  *
	;*********************
	;Zalozeni mikroorganismu
New(Code,Name)
	i Code="" s Txt="Zkratku nutno zadat !" q 1
	l +^Bact:10
	e  s Txt="S daty nekdo pracuje !" q 4
	i $d(^Bact(Code)) s Txt="Tato zkratka uz existuje !" l -^Bact q 1
	s ^Bact(Code)=Name
	l -^Bact
	d LogC^BACTlog($g(C("USER")),"Pridan patogen ("_Code_"-"_Name_")")
	q 0
	
	;Smazani mikroorganismu
Del(Code)	
	i Code="" s Txt="Zkratku nutno zadat !" q 1
	l +^Bact:10
	e  s Txt="S daty nekdo pracuje !" q 4
	k ^Bact(Code)
	l -^Bact
	d LogC^BACTlog($g(C("USER")),"Smazan patogen ("_Code_")")
	q 0
	
	;*********
	;*  FAS  *
	;*********
	;Nacteni FAS souboru z prechodneho mista
LoadFAS(Code,FAS,Gbl)
	n i,j,Cur,Cont
	;Test vstupnich dat
	i Code="" s Txt="Neurceny mikroorganismus !" q 1
	i '$d(^Bact(Code)) s Txt="Neznamy mikroorganismus !" q 1
	l +^Bact(Code):10
	e  s Txt="S daty nekdo pracuje !" q 4
.
	k ^Bact(Code,"FAS",FAS)
	s i="",Cur=0,Cont=""
	f  s i=$o(@Gbl@(i)) q:i=""  d
	.s j=@Gbl@(i)
	.i $e(j)=">" s Cur=$p(j,"_",2),Idx=0,Cont="" q
	.;Muze to byt na vice radku.....tak spojuji
	.i Cur s Cont=Cont_j,^Bact(Code,"FAS",FAS,Cur)=Cont
	
	k @Gbl
	l -^Bact(Code)
	d Log^BACTlog(Code,$g(C("USER")),"Nacteni FAS ("_FAS_")")
	q 0
	
	;Nacteni FAS souboru, FAS je urceno z prvniho radku
LoadFASX(Code,Gbl)
	n FAS,i
	;Test vstupnich dat
	i Code="" s Txt="Neurceny mikroorganismus !" q 1
	i '$d(^Bact(Code)) s Txt="Neznamy mikroorganismus !" q 1
	s i=$o(@Gbl@(""))
	s FAS=$p($p($g(@Gbl@(i)),"_"),">",2)
	i FAS="" s Txt="Nelze urcit FAS !" q 1
	q $$LoadFAS(Code,FAS,Gbl)
.
	;*********************
	;*   MLST            *
	;*********************
	;Nacteni MLST souboru
LoadMLST(Code,Gbl)
	n MLST,i,j,k,Head,Num,Idx
	;Test vstupnich dat
	i Code="" s Txt="Neurceny mikroorganismus !" q 1
	i '$d(^Bact(Code)) s Txt="Neznamy mikroorganismus !" q 1
	s i=$o(@Gbl@(""))
	s MLST=$g(@Gbl@(i))
	i MLST="" s Txt="Nelze urcit MLST !" q 1
	i $p(MLST,";")'="ST" s Txt="Neni spravny MLST soubor !" q 1
	
	l +^Bact(Code):10
	e  s Txt="S daty nekdo pracuje !" q 4
	;Hlavicka - spocitam neprazdne sloupce, pak sestavim
	s Num=0,j=1
	f  s j=j+1 q:$p(MLST,";",j)=""  s Num=Num+1
	f j=2:1:Num+1 s Head(j-1)=$p(MLST,";",j)
	s Head=Num
	;Vymazani vsech starych hodnot
	k ^Bact(Code,"MLST")
	;Nacteni noveho
	k ^Bact(Code,"MLSTH")
	m ^Bact(Code,"MLSTH")=Head
	f  s i=$o(@Gbl@(i)) q:i=""  d
	.s MLST=@Gbl@(i)
	.s Idx=$tr($p(MLST,";")," ")
	.i Idx="" q
	.f k=1:1:Num s ^Bact(Code,"MLST",Idx,Head(k))=$p(MLST,";",k+1)
.
	k @Gbl
	l -^Bact(Code)
	d Log^BACTlog(Code,$g(C("USER")),"Nacteni MLST")
	q 0
.
	;*********************
	;*   Primery         *
	;*********************
	;Nacteni primeru
LoadPrim(Code,Gbl)
	n Mode,i,j,k,Alela,Err,Kam
	;Test vstupnich dat
	i Code="" s Txt="Neurceny mikroorganismus !" q 1
	i '$d(^Bact(Code)) s Txt="Neznamy mikroorganismus !" q 1
	l +^Bact(Code):10
	e  s Txt="S daty nekdo pracuje !" q 4
	
	s Kam=$na(^Bact(Code,"A"))
	;Cyklus pres vsechny radky
	s i="",Mode=0,Alela="",Err=0
	f  s i=$o(@Gbl@(i)) q:i=""  d  q:Err
	.s j=@Gbl@(i)
	.i j="" q
	.;Prvni radek - alela
	.i Mode=0 s Alela=$na(@Kam@(j)) s Mode=1 q
	.;Dalsi radky uz musi mit Alelu
	.i Alela="" s Err=1 q
	.;Podle modu bud zacatek nebo konec
	.i Mode=1 d  q
	..k @Alela@("B")
	..f k=1:1:$l(j,$c(9)) s @Alela@("B",k)=$p(j,$c(9),k)
	..s Mode=2
	.i Mode=2 d
	..k @Alela@("E")
	..f k=1:1:$l(j,$c(9)) s @Alela@("E",k)=$p(j,$c(9),k)
	..s Alela="",Mode=0
.
	;Chyba - nepoznala se Alela
	i Err s Txt="Nezjistena alela !"
	;Uklid - smazani prechodnych dat, odemceni
	k @Gbl
	l -^Bact(Code)
	d Log^BACTlog(Code,$g(C("USER")),"Nacteni primeru")
	q Err
.
	;Ulozeni primeru
SavePrim(Code,Gbl)
	n Odkud,Count,i,j,k
	k @Gbl
	;Test vstupnich dat
	i Code="" s Txt="Neurceny mikroorganismus !" q 1
	i '$d(^Bact(Code)) s Txt="Neznamy mikroorganismus !" q 1
	l +^Bact(Code):10
	e  s Txt="S daty nekdo pracuje !" q 4
	
	s Odkud=$na(^Bact(Code,"A")),Count=0
	;Cyklus pres alely
	s i=""
	f  s i=$o(@Odkud@(i)) q:i=""  d
	.s Count=Count+1,@Gbl@(Count)=i
	.;Pocatecni primery
	.s j="",k=""
	.f  s k=$o(@Odkud@(i,"B",k)) q:k=""  d
	..i j'="" s j=j_$c(9)
	..s j=j_@Odkud@(i,"B",k)
	.s Count=Count+1,@Gbl@(Count)=j
	.;Koncove primery
	.s j="",k=""
	.f  s k=$o(@Odkud@(i,"E",k)) q:k=""  d
	..i j'="" s j=j_$c(9)
	..s j=j_@Odkud@(i,"E",k)
	.s Count=Count+1,@Gbl@(Count)=j
	
	l -^Bact(Code)
	q 0
	
	;Pridani primeru. Type "B" nebo "E"
AddPrimer(Code,Alela,Type,Value)
	;Test vstupnich dat
	i Code="" s Txt="Neurceny mikroorganismus !" q 1
	i '$d(^Bact(Code)) s Txt="Neznamy mikroorganismus !" q 1
	i Type="" s Txt="Neurceny typ !" q 1
	i '$f("BE",Type) s Txt="Neznamy typ !" q 1
	i Alela="" s Txt="Neurcena alela !" q 1
	l +^Bact(Code):10
	e  s Txt="S daty nekdo pracuje !" q 4
	
	s i=$zp(^Bact(Code,"A",Alela,Type,""))+1
	s ^Bact(Code,"A",Alela,Type,i)=Value
	l -^Bact(Code)
	q 0
.
	;*********************
	;*   Vyjimky         *
	;*********************
	;Nacteni Pulenych vyjimek z prechodneho mista
LoadVyj(Code,Gbl)
	n i,j,Alela,Tm,Idx
	;Test vstupnich dat
	i Code="" s Txt="Neurceny mikroorganismus !" q 1
	i '$d(^Bact(Code)) s Txt="Neznamy mikroorganismus !" q 1
	l +^Bact(Code):10
	e  s Txt="S daty nekdo pracuje !" q 4
.
	k ^Bact(Code,"VYJ")
	s i="",Alela=""
	f  s i=$o(@Gbl@(i)) q:i=""  d
	.s j=@Gbl@(i)
	.i $e(j)=">" s j=$e(j,2,$l(j)),Alela=$p(j," "),Tm=$p(j," ",2) q
	.i Alela="" q		
	.;Zapis vyjimky
	.s Idx=$zp(^Bact(Code,"VYJ",Alela,""))+1
	.s ^Bact(Code,"VYJ",Alela,Idx,1)=Tm
	.s ^Bact(Code,"VYJ",Alela,Idx,2)=j
	
	;k @Gbl
	l -^Bact(Code)
	d Log^BACTlog(Code,$g(C("USER")),"Nacteni vyjimek")
	q 0
	
	;*********************
	;*   Kontroly        *
	;*********************
	;Kontrola zakladnich dat - pres vsechny patogeny
Check(Gbl)
	n Mik,PocChyb
	k @Gbl
	s Mik="",PocChyb=0
	f  s Mik=$o(^Bact(Mik)) q:Mik=""  s PocChyb=PocChyb+$$CheckOne(Mik,Gbl,1)
	q PocChyb
	
	;Kontrola zakladnich dat - kontrola jednoho mikroorganismu
	;Obsahuje-li FAS, primery, ...
CheckOne(Mik,Gbl,NoKill)
	n Count,CountI,Alela,MikOK,Primer,PocPrim,FASid,FAS,i,MLSTh,MLSTx,MLSTok,MIKtxt
	s MIKtxt=Mik_": "
	;Pro zapis chyb
	i '$g(NoKill) k @Gbl
	s Count=+$zp(@Gbl@("")),CountI=0
	;Vlastni test
	s MikOK=1
	;Test FAS
	i '$d(^Bact(Mik,"FAS")) d Wri(MIKtxt_"neexistuje FAS") s MikOK=0
	s Alela=""
	f  s Alela=$o(^Bact(Mik,"FAS",Alela)) q:Alela=""  d
	.i '$d(^Bact(Mik,"A",Alela)) d Wri(MIKtxt_"pro FAS "_Alela_" neexistuje primer") s MikOK=0
	;Test ALEL
	i '$d(^Bact(Mik,"A")) d Wri(MIKtxt_"neexistuje Alela") s MikOK=0
	i $d(^Bact(Mik,"A")) d
	.s Alela=""
	.f  s Alela=$o(^Bact(Mik,"A",Alela)) q:Alela=""  d
	..i '$d(^Bact(Mik,"A",Alela,"B")) d Wri(Mik_", alela "_Alela_": "_"neexistuje primer-start") s MikOK=0
	..i '$d(^Bact(Mik,"A",Alela,"E")) d Wri(Mik_", alela "_Alela_": "_"neexistuje primer-konec") s MikOK=0
	;Pokud je neco spatneho s alelami dalsi test se nedela - nema smysl.....
	i 'MikOK q CountI
	;Test FAS pokud prvni cast testu byla v poradku
	;zkontroluji jestli ve FAS je prave jeden primer
	s Alela=""
	f  s Alela=$o(^Bact(Mik,"FAS",Alela)) q:Alela=""  d
	.s FASid=""
	.f  s FASid=$o(^Bact(Mik,"FAS",Alela,FASid)) q:FASid=""  d
	..s FAS=^Bact(Mik,"FAS",Alela,FASid)
	..s Prim="",PocPrim=0
	..f  s Prim=$o(^Bact(Mik,"A",Alela,"B",Prim)) q:Prim=""  d
	...i $f(FAS,^Bact(Mik,"A",Alela,"B",Prim)) s PocPrim=PocPrim+1
	..i PocPrim=0 d Wri(Mik_", alela "_Alela_": "_"pro FAS "_FASid_" nenalezen zadny primer-start")
	..i PocPrim>1 d Wri(Mik_", alela "_Alela_": "_"pro FAS "_FASid_" nalezeno vice primeru-start")
	..s Prim="",PocPrim=0
	..f  s Prim=$o(^Bact(Mik,"A",Alela,"E",Prim)) q:Prim=""  d
	...i $f(FAS,^Bact(Mik,"A",Alela,"E",Prim)) s PocPrim=PocPrim+1
	..i PocPrim=0 d Wri(Mik_", alela "_Alela_": "_"pro FAS "_FASid_" nenalezen zadny primer-konec")
	..i PocPrim>1 d Wri(Mik_", alela "_Alela_": "_"pro FAS "_FASid_" nalezeno vice primeru-konec")
	;Test MLST
	i '$d(^Bact(Mik,"MLST")) d Wri(MIKtxt_"neexistuje MLST")
	i $d(^Bact(Mik,"MLST")) d
	.i '$d(^Bact(Mik,"MLSTH")) d Wri(MIKtxt_"neexistuje MLSTH")
	.m MLSTh=^Bact(Mik,"MLSTH")
	.s i=""
	.f  s i=$o(MLSTh(i)) q:i=""  d
	..s Alela=MLSTh(i)
	..i '$d(^Bact(Mik,"A",Alela)) d Wri(Mik_", MLST : "_"neexistuji primery pro "_Alela) s MLSTx(Alela)=""
	.s i=""
	.f  s i=$o(^Bact(Mik,"MLST",i)) q:i=""  d
	..s Alela="",MLSTok=1
	..f  s Alela=$o(^Bact(Mik,"MLST",i,Alela)) q:Alela=""  i '$d(MLSTx(Alela)) d
	...s FASid=^Bact(Mik,"MLST",i,Alela)
	...i '$d(^Bact(Mik,"FAS",Alela,FASid)) d
	....d Wri(Mik_", MLST : ST("_i_") neexistuje FAS("_FASid_") pro "_Alela)
	....s MLSTok=0
	..i 'MLSTok s ^Bact(Mik,"MLST",i,"XXX")=1
	;Kontrola vyjimek
	s Alela=""
	f  s Alela=$o(^Bact(Mik,"VYJ",Alela)) q:Alela=""  d
	.i '$d(^Bact(Mik,"A",Alela)) d Wri(MIKtxt_"vyjimka pro neexistujici alelu "_Alela)
	
	q CountI
	;Zapsani hlasky o nalezenem problemu
Wri(%)
	s Count=Count+1,CountI=CountI+1,@Gbl@(Count)=%
 	q
.
	;**********************
	;*   Sprava databaze  *
	;**********************
 	
 	;Nacteni adresare pro zalohy - musi existovat
GetDir()
	n Adr
	s Adr=$g(^Settings("Backup"))
	i Adr="" q ""
	i $e(Adr,$l(Adr))'="\" s Adr=Adr_"\"
	i '$$tdir^LIBm(Adr) q ""
	q Adr
	 	
 	;Vytvoreni zalohy do daneho mista
Backup(Dest)
	n i,j
	d TtL^LIBdatop("^Bact",Dest)
	s i=$zdt($h,4)
	s j=$tr($p(i," "),"/",".")_" "_$p($p(i," ",2),":",1,2)
	s ^Settings("Info","Backup")=j
	d LogC^BACTlog($g(C("USER")),"Zaloha databaze")
	q
	
	;Obnoveni dat ze zalohy
Restore(Source)
	d LtT^LIBdatop(Source,"^Bact")
	k @Source
	d LogC^BACTlog($g(C("USER")),"Obnova databaze")
	q
	
	;Spusteni vytvoreni zalohy jako job na pozadi
BackupJ
	n Gbl,Adr,File,i,j,Err
	;Urceni souboru - musi existovat adresar jinak nejde
	s Adr=$$GetDir()
	i Adr="" q
	s File=Adr_"Zaloha-"
	s i=$p($zdt($h,4)," ")
	s File=File_$p(i,"/",3)_$p(i,"/",2)_$p(i,"/")
	s i=0,j=".txt"
	f  q:'$$tfile^LIBm(File_j)  s i=i+1,j="-"_i_".txt"
	;Vytvoreni zaloha
	s Gbl=$na(^Zbackup($j))
	d Backup(Gbl)
	s Err=$$LtF^LIBdatop(Gbl,File_j,"",1)
	k @Gbl
	q
	
	;Obnoveni dat ze zalohy jako job spousteny na pozadi z adresare v nastaveni
RestoreJ(C,%)
	n Adr,File,Gbl,Err
	;Urceni souboru - musi existovat adresar jinak nejde
	s Adr=$$GetDir()
	i Adr="" q
	s File=Adr_%
	i '$$tfile^LIBm(File) q
	s Gbl=$na(^Zbackup($j))
	s Err=$$FtL^LIBdatop(File,Gbl)
	i Err q
	d Restore(Gbl)
	k @Gbl
	q

BACTsearch^INT^1^65524,55820^0
BACTsearch	; Search MELT
.
	;Pro zobrazeni v gridu v packed-mode
GetPacked(Source,Sub)
	q $tr($g(@Source@(Sub)),";","#")
	
	;Udelej pripravu MELT pro zobrazeni
Make(Code,IdMELT,Dest,Filtr)
	n i,j,k,filt
	;Zatim beru posledni melt, pak se bude mozna predavat...
	s IdMELT=$zp(^Bact(Code,"MELT",""))
	i IdMELT="" q
	;Pripadny filtr
	i $g(Filtr)'="" d
	.f i=1:1:$l(Filtr) s j=$p(Filtr,";",i) i j'="" s filt(i)=j
	;Data
	k @Dest@("D")
	;1.radek je hlavicka, neberu.....
	s i=$o(^Bact(Code,"MELT",IdMELT,"D",""))
	f  s i=$o(^Bact(Code,"MELT",IdMELT,"D",i)) q:i=""  d
	.s j=^Bact(Code,"MELT",IdMELT,"D",i)
	.;Kontrola na pripadny filtr, indikace ze nemam brat bude j=""
	.i $d(filt) d  q:j=""
	..s k="" f  s k=$o(filt(k)) q:k=""  i $p(j,";",k+1)'=filt(k) s j="" q
	.s @Dest@("D",$p(j,";"))=j
	;Polozky pro vyber
	d MakeSelect(Dest)
	q
.
	;Udelej pripravu MLST pro zobrazeni
MakeMLST(Code,Dest,Filtr)
	n i,j,k,filt,Head
	;Neni nacteno
	i '$d(^Bact(Code,"MLST")) q
	;Pripadny filtr
	i $g(Filtr)'="" d
	.f i=1:1:$l(Filtr) s j=$p(Filtr,";",i) i j'="" s filt(i)=j
	;Data
	k @Dest@("D")
	m Head=^Bact(Code,"MLSTH")
	s i=""
	f  s i=$o(^Bact(Code,"MLST",i)) q:i=""  d
	.s j=i_";"
	.f k=1:1:Head s j=j_$g(^Bact(Code,"MLST",i,Head(k)))_";"
	.;Kontrola na pripadny filtr, indikace ze nemam brat bude j=""
	.i $d(filt) d  q:j=""
	..s k="" f  s k=$o(filt(k)) q:k=""  i $p(j,";",k+1)'=filt(k) s j="" q
	.s @Dest@("D",$p(j,";"))=j
	;Polozky pro vyber
	d MakeSelect(Dest)
	q
	
	;Udelej pripravu pro uzivatelske zobrazeni
MakeUSER(Sou,Dest,Filtr)
	n i,j,k,filt
	;Pripadny filtr
	i $g(Filtr)'="" d
	.f i=1:1:$l(Filtr) s j=$p(Filtr,";",i) i j'="" s filt(i)=j
	;Data
	k @Dest@("D")
	s i=""
	f  s i=$o(@Sou@("D",i)) q:i=""  d
	.s j=@Sou@("D",i)
	.;Kontrola na pripadny filtr, indikace ze nemam brat bude j=""
	.i $d(filt) d  q:j=""
	..s k="" f  s k=$o(filt(k)) q:k=""  i $p(j,";",k+1)'=filt(k) s j="" q
	.s @Dest@("D",i)=j
	;Polozky pro vyber
	d MakeSelect(Dest)
	q
	
	;Info o hlavicce podle MLSTH
GetHeader(Code)
	n i,j
	s i="",j=$g(^Bact(Code,"MLSTH"))
	f  s i=$o(^Bact(Code,"MLSTH",i)) q:i=""  s j=j_";"_^Bact(Code,"MLSTH",i)
	q j
	
	;Sestaveni moznosti pro vyber
MakeSelect(Dest)
	n i,j,k
	k @Dest@("V")
	s i=""
	f  s i=$o(@Dest@("D",i)) q:i=""  d
	.s j=$g(@Dest@("D",i))
	.f k=1:1:$l(j,";") i $p(j,";",k+1)'="" s @Dest@("V",k,$p(j,";",k+1))=""
	q
	
	;Vytvoreni dat pro export - hlavicka + kopie dat
DataToExport(Head,Source,Dest)
	n Count,i
	k @Dest
	i $e(Head,$l(Head))=";" s Head=$e(Head,1,$l(Head)-1)
	s @Dest@(1)=Head,Count=1
	s i="" f  s i=$o(@Source@("D",i)) q:i=""  s Count=Count+1,@Dest@(Count)=@Source@("D",i)
	q
	
	; ***** Uzivatelska zobrazeni *****
	; Delky sekvenci alel
CalcLen(Code,Place)
	n i,j,k,End
	k @Place
	s @Place@("C")="Delky sekvenci"
	s @Place@("F")="FAS"
	i Code="" q
	s @Place@("H")=$$GetHeader(Code)
	;Zjisteni posledniho ID
	s i="",End=1
	f  s i=$o(^Bact(Code,"MLSTH",i)) q:i=""  s j=$zp(^Bact(Code,"CALC",^Bact(Code,"MLSTH",i),"")) i j>End s End=j
	f i=1:1:End d
	.s j=i_";"
	.s k="" f  s k=$o(^Bact(Code,"MLSTH",k)) q:k=""  s j=j_$g(^Bact(Code,"CALC",^Bact(Code,"MLSTH",k),i,"S","L"))_";"
	.s @Place@("D",i)=j
	q	
	
	;Spocitani teplot
CalcTm(Code,Place)
	n Gbl,ST,Head,i,j,vyp,Alela,ID
	s Gbl=$na(^Bact(Code,"CALC"))
	k @Place
	s @Place@("C")="Teploty"
	i Code="" q
	s @Place@("H")=$$GetHeader(Code)
	
	m Head=^Bact(Code,"MLSTH")
	;Projeti MLST
	s ST=""
	f  s ST=$o(^Bact(Code,"MLST",ST)) q:ST=""  d
	.;Ty, co maji spatna data a jsou vyrazeny, tak nebrat
	.i $g(^Bact(Code,"MLST",ST,"XXX")) q
	.s j=ST
	.f i=1:1:Head s Alela=Head(i) d
	..s ID=$g(^Bact(Code,"MLST",ST,Alela))
	..i ID="" s j=j_";???" q
	..i '$d(@Gbl@(Alela,ID)) s j=j_";???" q
	..;VzorecTm =59.903 + 0,41 x (%G+C) - 675/N
	..s vyp=59.903+(41*(($g(@Gbl@(Alela,ID,"S","C"))+$g(@Gbl@(Alela,ID,"S","G")))/$g(@Gbl@(Alela,ID,"S","L"))))-(675/$g(@Gbl@(Alela,ID,"S","L")))
	..s vyp=$fn(vyp,"",2)
	..s j=j_";"_vyp
	.s @Place@("D",ST)=j
	
	q
	
	;Statistika alely
StatAlela(Code,Alela,Place)
	n Gbl,i,j,ID,Tmp,ST
	s Gbl=$na(^Bact(Code,"CALC"))
	k @Place
	s @Place@("C")="Statistika alely "_Alela
	i Code="" q
	s @Place@("F")="FAS"
	s @Place@("H")="8;A;C;G;T;PrimB;PrimE;Len;X"
	s Tmp=$na(^Zalely($j))
	k @Tmp
	
	;Projeti MLST, ktere FAS se berou
	s ST=""
	f  s ST=$o(^Bact(Code,"MLST",ST)) q:ST=""  d
	.s ID=$g(^Bact(Code,"MLST",ST,Alela))
	.i ID="" q
	.i '$d(^Bact(Code,"FAS",Alela,ID)) q
	.i '$d(@Gbl@(Alela,ID)) q
	.s @Tmp@(ID)=""
	
	;Projeti alel
	s ID=""
	f  s ID=$o(@Tmp@(ID)) q:ID=""  d
	.s j=ID_";"_$g(@Gbl@(Alela,ID,"S","A"))
	.s j=j_";"_$g(@Gbl@(Alela,ID,"S","C"))
	.s j=j_";"_$g(@Gbl@(Alela,ID,"S","G"))
	.s j=j_";"_$g(@Gbl@(Alela,ID,"S","T"))
	.s j=j_";"_$g(@Gbl@(Alela,ID,"S","PrimB"))
	.s j=j_";"_$g(@Gbl@(Alela,ID,"S","PrimE"))
	.s j=j_";"_$g(@Gbl@(Alela,ID,"S","L"))
	.s j=j_";"_$g(@Gbl@(Alela,ID,"X"))
	.s @Place@("D",ID)=j
	
	k @Tmp
	q
.

BACTsystem^INT^1^65490,26712.405182^0
BACTsystem	;Systemove utility
	
	;Pro zobrazeni chyb
GetErr(Subs)
	n i,j,k
	s i=Subs
	s j=$tr($zd($e(i,1,5),4),"/",".")
	s k=(+$e(i,6,$l(j))\60)
	s j=j_" "_(k\60)_":"_(k#60)_"##"_$g(^ERR(1,Subs,1))
	q j
	
.

BACTuser^INT^1^65517,38719.033317^0
BACTuser	;Uzivatele
	
	;Zalozeni uzivatele
New(Code,Pass,Name)
	n Idx
	;Test spravnosti
	i Code="" s Txt="Uzivatele nutno zadat !" q 1
	i $d(^User("C",Code)) s Txt="Tento uzivatel jiz existuje !" q 1
	;Zalozeni
	l +^User
	s Idx=$zp(^User("A",""))+1
	s ^User("A",Idx,"User")=Code
	s ^User("A",Idx,"Password")=Pass
	s ^User("A",Idx,"Name")=Name
	s ^User("C",Code)=Idx
	l -^User
	d LogC^BACTlog($g(C("USER")),"Pridan uzivatel ("_Name_")")
	q 0
	
	;Smazani uzivatele
Del(Idx)
	n Code,Name
	;Test spravnosti
	i Idx="" s Txt="Uzivatele nutno zadat !" q 1
	i '$d(^User("A",Idx)) s Txt="Tento uzivatel neexistuje !" q 1
	;Vlastni smazani
	l +^User
	s Code=^User("A",Idx,"User")
	s Name=$g(^User("A",Idx,"Name"))
	k ^User("A",Idx)
	k ^User("C",Code)
	l -^User
	d LogC^BACTlog($g(C("USER")),"Smazan uzivatel ("_Name_")")
	q 0
.
	;Test, je-li mozne se prihlasit. Pokud projde, vraci se ID uzivatele, jinak prazdny string
Login(Code,Pass)
	n ID
	i Code="" s Txt="Uzivatele nutno zadat !" q ""
	i Pass="" s Txt="Heslo nutno zadat !" q ""
	i '$d(^User("C",Code)) s Txt="Neznamy uzivatel !" q ""
	s ID=$g(^User("C",Code))
	i ID="" s Txt="Nekonzistence uzivatelu !" q ""
	i $g(^User("A",ID,"Password"))'=Pass s Txt="Nespravne heslo !" q ""
	;Uspesne prihlaseni - zapisi posledni datum/cas
	s ^User("A",ID,"Last")=$tr($zdt($h,4),"/",".")
	s C("USER")=ID
	q ID
	
	;Nacteni informace o uzivateli
GetInfo(ID)
	n i
	s i=ID_"#"_$g(^User("A",ID,"Name"))_"#"_$g(^User("A",ID,"User"))
	q i
	
	;Jmeno uzivatele
GetName(ID)
	i $g(ID)="" q "???"
	q $g(^User("A",ID,"Name"))
	
	;Blokovani/odblokovani uzivatele
Blok(ID)
	n i
	s i=$g(^User("A",ID,"Blok"))
	i 'i s ^User("A",ID,"Blok")=1
	e  k ^User("A",ID,"Blok")
	q 0
	
	;Ulozeni profilu
SaveProfile(ID,Data)
	i ID="" q
	i '$d(^User("A",ID)) q
	s ^User("A",ID,"Prof")=Data
	q
	
	;Nacteni profilu
LoadProfile(ID)
	q $g(^User("A",ID,"Prof"))
	
	;Poznamky do pomocneho globalu
LoadNote(ID,Place)
	k @Place
	m @Place=^User("A",ID,"Note")
	q
	
	;Ulozeni poznamek z prechodneho globalu
SaveNote(ID,Place)
	k ^User("A",ID,"Note")
	m ^User("A",ID,"Note")=@Place
	k @Place
	q

LIBXgbl^INT^1^64593,34998.132378^0
LIBXgbl(%)
 ;Operations with data - transfer global data
 ;Copyright Slavek Zmek, 2016
 
 i %?1N.N s xroot=$na(^XMP(%))
 e  s xroot=%
.
 s Data=$g(@xroot@(1))
 i Data="" q
 s Param=$g(@xroot@(2))
 d LtT^LIBdatop(xroot,Data,3)
 q
.
 ;Send global data
Send(Data,Adr)
 n Gb,Err
 s Gb=$na(^Zexpd($j))
 k @Gb
 s @Gb@(1)=Data
 s @Gb@(2)=""
 d TtL^LIBdatop(Data,Gb,1)
 s Err=$$Send^LIBcomm(Adr,"LIBXgbl",9,$zp(@Gb@("")),Gb)
 k @Gb
 q Err

LIBXmsgans^INT^1^64940,34774.564525^0
LIBXmsgans(%)
 ;Message-answer in background
 ;Copyright Slavek Zmek, 2018
 
 n xroot,Place,i,j,Rou
 i %?1N.N s xroot=$na(^XMP(%))
 e  s xroot=%
 ;First node - place to store data
 s Place=@xroot@(1)
 s i=1,j=0
 f  s i=$o(@xroot@(i)) q:i=""  s j=j+1,@Place@("data",j)=@xroot@(i)
 s @Place@("dt")=$h
 s @Place@("rec")=1
 i '$g(@Place@("nowait")) q
 
 ;Nowait - execute routine
 s Rou=@Place@("routine")
 i Rou'="" s i=Rou_"("_$na(@Place@("data"))_")" d @i
 q
 
 ;Function for calling
 ; Data as JSON, and wait
CallJSONWait(Data,Adr,Code,Result)
 n Place,DataO,Err
 s Place=$$GetPlace()
 s DataO(1)=Place
 d EncodeX^LIBjson(Data,"DataO",1)
 d Send^LIBcomm(Adr,Code,2,$zp(DataO("")),"DataO")
 s Err=$$Wait(Place,Result)
 q Err
.
 ; Data as JSON, nowait
CallJSONNowait(Data,Adr,Routine)
 n Place,DataO,Err
 s Place=$$GetPlace()
 d SetNowait(Place,Routine)
 s DataO(1)=Place
 d EncodeX^LIBjson(Data,"DataO",1)
 s Err=$$Send^LIBcomm(Adr,"LIBXmsgans",2,$zp(DataO("")),"DataO")
 q Err
.
.
.
 ;For set as zetrap - returned JSON with error in variable xOutput
JSONtrap
 n lErr
 d WE^LIBerr("REST","MSG")
 s lErr("Code")=1
 s lErr("Message")=$zerror
 s lErr("Status")="Error"
 s xOutput=$$Encode^LIBjson("lErr")
 i $g(xGoLabel)'="" g @xGoLabel
 q
 
 
 
 ;Utilities
 
 ;Get place for received data
GetPlace()
 n i,Place
 s i=$zp(^Zrec($j,""))+1
 s Place=$na(^Zrec($j,i))
 k @Place
 s @Place@("call")=$h
 q Place
 
 ;Wait for answer - returns: 1 - OK, 0 - No answer
Wait(%Place,%Data,%Interval)
 n i,Int
 s Int=+$g(%Interval)
 i 'Int s Int=2000
 s i=0 f  q:$d(@%Place@("rec"))  q:i>Int  h .1  s i=i+1
 i i>Int q 0
 ;Received data
 k @%Data
 m @%Data=@%Place@("data")
 k @%Place
 q 1
 
 ;Nowait indication
SetNowait(%Place,%Routine)
 s @%Place@("nowait")=1
 s @%Place@("routine")=%Routine
 q
.
 ;Cleaning buffer for received answers - old, or without answer
Clean
 n i,j,k
 s i=""
 f  s i=$o(^Zrec(i)) q:i=""  d
 .s k=""
 .f  s k=$o(^Zrec(i,k)) q:k=""  d  i j>10000 k ^Zrec(i,k)
 ..i '$d(^Zrec(i,k,"dt")) s j=$$HorDif($g(^Zrec(i,k,"call"))) q
 ..s j=$$HorDif($g(^Zrec(i,k,"dt")))
 q
 
 ;Horolog difference
HorDif(%)
 n i
 s i=$h
 q ($p(i,",")-$p(%,","))*86400+$p(i,",",2)-$p(%,",",2)

LIBXupdate^INT^1^65045,52448.398954^0
LIBXupdate(%)
 ;Update system - routines, globals, xecute,...
 ;Copyright Slavek Zmek, 2018
 ;Functions: Send updates as messages     - SendRou, SendData, SendXec, SendCls, SendProj
 ;           Send one item as message     - SendOneRou, SendOneData, SendOneExec, SendOneCls, SendOneProj
 ;           Send scenario as messages    - SendScenario
 ;           Save and load whole update   - SaveUpdate, LoadUpdate 
 ;           Save semi-update             - SaveRou, SaveData, SaveXec, SaveCls
 ;           Save one item as semi-update - SaveOneItem, SaveOneRou, SaveOneData, SaveOneXec, SaveOneCls
 ;           Make scenario                - AddStepItem, MakeScenario
 ;           Save and load scenario       - SaveScenario, LoadScenario
 ;           Build update via scenario    - BuildScenario, FiledScenario, LoadAndFiledScenario
 ;           Build update via steps       - BuildSteps
 ;
 ;Process:     Scenario                - SaveScenario/LoadScenario,  FiledScenario, LoadAndFiledScenario, ScToSteps
 ;                |      - ScToSteps  
 ;             Steps                   - SaveSteps/LoadSteps(as Scenario), BuildSteps, FiledSteps, MakeScenario
 ;                |      - BuildUpdate
 ;             Update
 ;                |
 ;            Send, File,...  - SaveUpdate, LoadUpdate
 ;
.
 n xroot,serialized 
 i %?1N.N s xroot=$na(^XMP(%))
 e  s xroot=%
.
 ;Vlastni nacteni updatu, volani i z LoadUpdate
Load
 n Count,Data,Instr,Len 
 s Count=0
 f  s Count=$o(@xroot@(Count)) q:Count=""  d
 .s Data=$g(@xroot@(Count))
 .s Instr=$p(Data,"|")
 .s Len=$p(Data,"|",2)
 .i Instr="R" d ImpRou q
 .i Instr="D" d ImpData q
 .i Instr="X" d ImpXec q
 .i Instr="C" d ImpCls q
 .i Instr="P" d ImpProj q
 .i Instr="F" d ImpFile q
 .i Instr="I" d ImpIniV q
 q
 
 ;Import routine
ImpRou
 n Src,Rou,E,i
 s Rou=$p(Data,"|",3)
 s Src(0)=Len
 f i=1:1:Src(0) s Count=$o(@xroot@(Count)),Src(i)=$g(@xroot@(Count))
 d ROUTINE^%R(Rou,.Src,.E,"SC")
 q
 
 ;Import Data
ImpData
 n Src,end
 s Src=$p(Data,"|",3)
 s Count=$o(@xroot@(Count)),end=Count+Len
 d LtT^LIBdatop(xroot,Src,Count,"",end)
 s Count=end-1
 q
 
 ;Import Xecute
ImpXec
 n i,j
 s i=Len
 f  q:i<1  s Count=$o(@xroot@(Count)) q:Count=""  d  s i=i-1
 .s j=$g(@xroot@(Count))
 .i j'="" x j
 q 
.
 ;Import Class
ImpCls
 n Src,Cls,E,i
 s Cls=$p(Data,"|",3)
 s Src(0)=Len
 f i=1:1:Src(0) s Count=$o(@xroot@(Count)),Src(i)=$g(@xroot@(Count))
 s E=##class(%Compiler.UDL.TextServices).SetTextFromArray("",Cls,.Src)
 q
 
 ;Import Project
ImpProj
 n Proj,Tmp,GbT,Err,tSC,tPrj,i
 s Proj=$p(Data,"|",3)
 s Tmp="TmpProject.xml"
 s GbT=$na(^Ztmpdata($j))
 k @GbT
 f i=1:1:Len s Count=$o(@xroot@(Count)),@GbT@(i)=$g(@xroot@(Count))
 s Err=$$LtF^LIBdatop(GbT,Tmp,"",1)
 i Err q
 s tSC=##class(%Studio.Project).Import(Tmp)
 s tPrj=##class(%Studio.Project).%OpenId(Proj)
 s tSc=tPrj.Compile()
 k @GbT
 d dfile^LIBm(Tmp)
 q
 
 ;Import file
ImpFile
 n File,Dir,DirA
 s File=$p(Data,"|",3)
 s Dir=$p(Data,"|",4),DirA=""
 i Dir'="",$d(Varia(Dir)) s DirA=$g(Varia(Dir)) i DirA'="",$e(DirA,$l(DirA))'="" s DirA=DirA_"\"
 ;s File="TEST.gof"
 s Err=$$LtF^LIBdatop(xroot,DirA_File,"","","decB64^LIBchar",Count+1,Count+Len,"WUNK\RAW\")
 q  
.
 ;Import file with IniValues
ImpIniV
 n File,Err,i,j,GbT
 s File=$p(Data,"|",3)
 s GbT=$na(^Ztmpdata($j))
 k @GbT
 s Err=$$FtL^LIBdatop(File,GbT)
 i Err q
 s i=""
 f  s i=$o(@GbT@(i)) q:i=""  s j=$g(@GbT@(i)) i $p(j,"=")'="" s Varia($p(j,"="))=$p(j,"=",2)
 k @GbT
 q
  
 ;Load routine(INT,OBJ,...) to field Data
xLoad(%)
 n E
 d ROUTINE^%R(%,.Data,.E,"LI")
 i E'="" q 1
 q 0
.
 ;Test routine(INT,OBJ,...) if it is possible to load
xTest(%)
 n Data
 q $$xLoad(%)
  
 ;Prepare
Prepare(type,From,To,IVar)
 i type="R" d PrepRou(From,To) q
 i type="D" d PrepData(From,To) q
 i type="X" d PrepXec(From,To) q
 i type="C" d PrepCls(From,To) q
 i type="P" d PrepProj(From,To) q
 i type="F" d PrepFile(From,To,$g(IVar)) q
 q
 
 ;Prepare one
PrepareOne(type,Item,To)
 n List
 s List(1)=Item
 d Prepare(type,"List",To)
 q
 
 ;Prepare IniValues - from field
PrepIni(Sou,Dest) 
 n i,k,File
 s i=$zp(@Dest@(""))
 s k=""
 f  s k=$o(@Sou@(k)) q:k=""  d
 .s File=@Sou@(k)
 .s i=i+1,@Dest@(i)="I|0|"_File
 q
.
 ;Prepare routines - from field
PrepRou(Sou,Dest)
 n Rou,i,j,k,Data,Err,Ext
 s Ext=$$GetExt("R")
 s i=$zp(@Dest@(""))
 s k=""
 f  s k=$o(@Sou@(k)) q:k=""  d
 .s Rou=@Sou@(k)
 .s Err=$$xLoad(Rou_Ext)
 .i Err q
 .s i=i+1,@Dest@(i)="R|"_Data(0)_"|"_Rou_Ext
 .f j=1:1:Data(0) s i=i+1,@Dest@(i)=Data(j)
 q
   
 ;Prepare data - from structure, one indexed level, value is transported global
PrepData(Sou,Dest)
 n i,j,k,Data
 s j=""
 f  s j=$o(@Sou@(j)) q:j=""  d
 .s Data=@Sou@(j)
 .s i=$zp(@Dest@(""))+1,@Dest@(i)=""
 .d TtL^LIBdatop(Data,Dest,1)
 .s k=$zp(@Dest@(""))
 .s @Dest@(i)="D|"_(k-i)_"|"_Data
 q 
 
 ;Prepare xecute - from structure, one indexed level, value is xecuted string
PrepXec(Sou,Dest)
 n i,j,k,Data
 s i=$zp(@Dest@(""))+1,@Dest@(i)=""
 s j="",k=0
 f  s j=$o(@Sou@(j)) q:j=""  d
 .s Data=@Sou@(j)
 .s k=k+1,@Dest@(i+k)=Data
 s @Dest@(i)="X|"_k
 q
 
 ;Prepare class - from structure, one indexed level, value is transported class
PrepCls(Sou,Dest)
 n Cls,i,j,k,Data,E
 s i=$zp(@Dest@(""))
 s k=""
 f  s k=$o(@Sou@(k)) q:k=""  d
 .s Cls=@Sou@(k)
 .s E=##class(%Compiler.UDL.TextServices).GetTextAsArray("",Cls,.Data)
 .i 'E q
 .s i=i+1,@Dest@(i)="C|"_Data(0)_"|"_Cls
 .f j=1:1:Data(0) s i=i+1,@Dest@(i)=Data(j)
 q
 
 ;Prepare project - via export to temporary file
PrepProj(Sou,Dest)
 n Proj,i,j,k,l,Tmp,GbT,tPrj,tSC,Err,Count
 s Tmp="TmpProject.xml"
 s GbT=$na(^Ztmpdata($j))
 s i=$zp(@Dest@(""))
 s k=""
 f  s k=$o(@Sou@(k)) q:k=""  d
 .s Proj=@Sou@(k)
 .s tPrj=##class(%Studio.Project).%OpenId(Proj)
 .s tSC=tPrj.Export(Tmp) 
 .i 'tSC q
 .s i=i+1,l=i,@Dest@(i)="P||"_Proj
 .s Err=$$FtL^LIBdatop(Tmp,GbT)
 .i Err q
 .s j="",Count=0
 .f  s j=$o(@GbT@(j)) q:j=""  s i=i+1,Count=Count+1,@Dest@(i)=@GbT@(j)
 .s @Dest@(l)="P|"_Count_"|"_Proj
 .k @GbT
 .d dfile^LIBm(Tmp)
 q
 
 ;Prepare file
PrepFile(Sou,Dest,Ref)
 n File,Dir,DirA,i,j,k,m,Err
 s k=""
 f  s k=$o(@Sou@(k)) q:k=""  d
 .s m=@Sou@(k)
 .s File=$p(m,"|")
 .s Dir=$p(m,"|",2),DirA=""
 .s l=$zp(@Dest@(""))+1,@Dest@(l)="F||"_$p(File,"\",*)_"|"_Dir
 .i Dir'="",$g(Ref)'="",$d(@Ref@(Dir)) s DirA=$g(@Ref@(Dir)) i DirA'="",$e(DirA,$l(DirA))'="" s DirA=DirA_"\"
 .;Textak
 .;s Err=$$FtL^LIBdatop(File,Dest,1)
 .;Binarka
 .s Err=$$FtL^LIBdatop(DirA_File,Dest,1,999,"encB64nolf^LIBchar")
 .i Err q
 .s i=$zp(@Dest@(""))
 .s @Dest@(l)="F|"_(i-l)_"|"_$p(File,"\",*)_"|"_Dir
 
 q 
 
 ;Send routines
SendRou(Sou,Adr)
 q $$SendType(Sou,Adr,"R")
 
 ;Send data
SendData(Sou,Adr)
 q $$SendType(Sou,Adr,"D")
 
 ;Send xecute
SendXec(Sou,Adr)
 q $$SendType(Sou,Adr,"X")
 
 ;Send class
SendCls(Sou,Adr)
 q $$SendType(Sou,Adr,"C")
.
 ;Send project
SendProj(Sou,Adr)
 q $$SendType(Sou,Adr,"P")
.
 ;Send one item - routine
SendOneRou(Item,Adr)
 q $$SendOneItem(Item,Adr,"R")
 
 ;Send one item - data
SendOneData(Item,Adr)
 q $$SendOneItem(Item,Adr,"D")
 
 ;Send one item - xecute
SendOneXec(Item,Adr)
 q $$SendOneItem(Item,Adr,"X")
 
 ;Send one item - class
SendOneCls(Item,Adr)
 q $$SendOneItem(Item,Adr,"C")
.
 ;Send one item - project
SendOneProj(Item,Adr)
 q $$SendOneItem(Item,Adr,"P")
 
 ;Save routines
SaveRou(Sou,File)
 q $$SaveType(Sou,File,"R")
.
 ;Save classes
SaveClass(Sou,File)
 q $$SaveType(Sou,File,"C")
 
 ;Save data
SaveData(Sou,File)
 q $$SaveType(Sou,File,"D")
.
 ;Save one item - routine
SaveOneRou(Item,File)
 q $$SaveOneItem(Item,File,"R")
.
 ;Save one item - class
SaveOneClass(Item,File)
 q $$SaveOneItem(Item,File,"C")
 
 ;Save one item - data
SaveOneData(Item,File)
 q $$SaveOneItem(Item,File,"D")
.
 ;Save one item - xecute
SaveOneXec(Item,File)
 q $$SaveOneItem(Item,File,"X")
.
 ;Save one item - project
SaveOneProj(Item,File)
 q $$SaveOneItem(Item,File,"P")
 
 ;Load update
LoadUpdate(File)
 n Err,xroot,Varia
 s xroot=$na(^Zroui($j))
 s Err=$$FtL^LIBdatop(File,xroot)
 i 'Err d Load
 q Err
 
 ;Save update
SaveUpdate(Sou,File)
 n Gb,Err,type
 s Gb=$na(^Zexp($j))
 k @Gb
 s type=""
 f  s type=$o(@Sou@(type)) q:type=""  d Prepare(type,$na(@Sou@(type)),Gb)
 s Err=$$LtF^LIBdatop(Gb,File,"",1)
 k @Gb
 q Err
 
 ;Load one item from update
LoadOne(Sou)
 n Err,xroot,i,j,Data,Len,Instr
 s Err=0
 s i=$o(@Sou@("")),xroot=Sou
 s Data=$g(@xroot@(i))
 s Instr=$p(Data,"|")
 ;Length - it could be edited, and length is different. It must be calculated again...
 s j=i,Len=0
 f  s j=$o(@Sou@(j)) q:j=""  s Len=Len+1
 d Load
 q Err
  
.
AddStepItem(Sou,Type,Dest)
 n i
 i '$d(@Sou) q
 s i=$zp(@Dest@(""))+1
 m @Dest@(i)=@Sou
 s @Dest@(i)=Type
 q
.
 ;Make scenario = Steps -> Scenario
MakeScenario(Sou,Dest)
 n i,j,k,l,type
 k @Dest
 s i="",j=0
 f  s i=$o(@Sou@(i)) q:i=""  d
 .s type=@Sou@(i)
 .s j=j+1,@Dest@(j)="["_$s(type="R":"Routines",type="X":"Xecute",type="D":"Data",type="C":"Classes",type="P":"Projects","F":"Files",1:"???")_"]"
 .s k=""
 .f  s k=$o(@Sou@(i,k)) q:k=""  s j=j+1,@Dest@(j)=@Sou@(i,k)
 q
.
 ;Send field of one type - todo: check accepted types
SendType(Sou,Adr,type)
 n Gb,Err
 s Gb=$na(^Zexp($j))
 k @Gb
 d Prepare(type,Sou,Gb)
 s Err=$$Send(Gb,Adr)
 k @Gb
 q Err
.
 ;Send one item - todo: check accepted types
SendOneItem(Item,Adr,type)
 n Err,List
 s List(1)=Item
 s Err=$$SendType("List",Adr,type)
 q Err
 
 ;Save field of one type - todo: check accepted types
SaveType(Sou,File,type)
 n Gb,Err
 s Gb=$na(^Zexp($j))
 k @Gb
 d Prepare(type,Sou,Gb)
 s Err=$$LtF^LIBdatop(Gb,File,"",1)
 k @Gb
 q Err
.
 ;Save one item - todo: check accepted types
SaveOneItem(Item,File,type)
 n Err,List
 s List(1)=Item
 s Err=$$SaveType("List",File,type)
 q Err
.
 ;Build scenario = Scenario -> Steps -> Update
BuildScenario(Sou,Dest)
 n Gb
 k @Dest
 s Gb=$na(^Zexp($j))
 d ScToSteps(Sou,Gb)
 d BuildSteps(Gb,Dest)
 k @Gb
 q
 
 ;Send scenario = Scenario -> Update -> Send 
SendScenario(Sou,Adr)
 n Gb
 s Gb=$na(^Zexp($j))
 k @Gb
 d BuildScenario(Sou,Gb)
 d Send(Gb,Adr)
 k @Gb
 q
.
 ;File scenario = Scenario -> Update -> File
FiledScenario(Sou,File)
 n Gb,Err
 s Gb=$na(^Zscbuild($j))
 k @Gb
 d BuildScenario(Sou,Gb)
 s Err=$$LtF^LIBdatop(Gb,File,"",1)
 k @Gb
 q Err
 
 ;Load and File scenario = Scenario from file -> Update -> File
LoadAndFiledScenario(FileS,FileU)
 n Gb,Err
 s Gb=$na(^Zscen($j))
 s Err=$$LoadScenario(FileS,Gb)
 i Err q Err
 s Err=$$FiledScenario(Gb,FileU)
 k @Gb
 q Err
 
 ;Scenario To Steps
ScToSteps(Sou,Dest)
 n i,j,k,l,Ok
 k @Dest
 s i="",(Ok,k)=0
 f  s i=$o(@Sou@(i)) q:i=""  d
 .s j=@Sou@(i)
 .i $e(j)="[" d  q
 ..s j=$p($p(j,"[",2),"]")
 ..s (Ok,l)=0
 ..i j="Routines" s Ok=1
 ..i j="Xecute" s Ok=2
 ..i j="Data" s Ok=3
 ..i j="Classes" s Ok=4
 ..i j="Projects" s Ok=5
 ..i j="Files" s Ok=6
 ..i j="IniValues" s @Dest@(0)="I",Ok=7 q
 ..i Ok s k=k+1,@Dest@(k)=$s(Ok=1:"R",Ok=2:"X",Ok=3:"D",Ok=4:"C",Ok=5:"P",Ok=6:"F",1:"???")
 .i 'Ok q
 .i Ok=7 s l=l+1,@Dest@(0,l)=j q
 .s l=l+1,@Dest@(k,l)=j
 q
 
 ;Load initial values
LoadIniVal(Sou,Dest)
 n Gb,i,j,k,Err
 s Gb=$na(^Ziniv($j))
 s k=""
 f  s k=$o(@Sou@(k)) q:k=""  d
 .s Err=$$FtL^LIBdatop(@Sou@(k),Gb)
 .i Err q
 .s i=""
 .f  s i=$o(@Gb@(i)) q:i=""  s j=$g(@Gb@(i)) i $p(j,"=")'="" s @Dest@($p(j,"="))=$p(j,"=",2)
 k @Gb
 q 
 
 
 ;Load steps - from saved scenario
LoadSteps(File,Dest)
 n Err,Gb
 s Gb=$na(^Zesteps($j))
 s Err=$$LoadScenario(File,Gb)
 i Err q Err
 d ScToSteps(Gb,Dest)
 k @Gb
 q Err
 
 ;Save Steps - as Scenario
SaveSteps(Sou,File)
 n eData
 d MakeScenario(Sou,"eData")
 s Err=$$LtF^LIBdatop("eData",File,"",1)
 q Err
 
 ;Build steps = Steps -> Update
BuildSteps(Sou,Dest)
 n i,type,Varia
 k @Dest
 i $d(@Sou@(0)) d LoadIniVal($na(@Sou@(0)),"Varia"),PrepIni($na(@Sou@(0)),Dest)
 s i=""
 f  s i=$o(@Sou@(i)) q:i=""  s type=@Sou@(i) d Prepare(type,$na(@Sou@(i)),Dest,"Varia")
 q
 
 ;Filed steps = Steps -> Update -> File
FiledSteps(Sou,File)
 n Gb,Err
 s Gb=$na(^Zesteps($j))
 d BuildSteps(Sou,Gb)
 s Err=$$LtF^LIBdatop(Gb,File,"",1)
 k @Gb
 q Err
.
 ;Filed steps = Steps -> Update -> Files (separately)
FiledStepsX(Sou,Dir)
 n Err,type,i,j,k,Ext
 i $e(Dir,$l(Dir))'="\" s Dir=Dir_"\"
 s i=""
 f  s i=$o(@Sou@(i)) q:i=""  d
 .s type=@Sou@(i),Ext=$$GetExt(type)
 .i Ext="" q
 .s j=""
 .f  s j=$o(@Sou@(i,j)) q:j=""  d
 ..s k=@Sou@(i,j)
 ..i type="R" s Err=$$SaveOneRou(k,Dir_k_Ext) q
 ..i type="D" s Err=$$SaveOneData(k,Dir_$tr(k,"""^,()","-")_Ext) q
 ..i type="X" s Err=$$SaveOneXec(k,Dir_k_Ext) q
 ..i type="C" s Err=$$SaveOneClass(k,Dir_k_Ext) q
 ..i type="P" s Err=$$SaveOneProj(k,Dir_k_Ext) q
 q Err
 
 ;Load scenario
LoadScenario(File,Dest)
 n Err
 s Err=$$FtL^LIBdatop(File,Dest)
 q Err
 
 ;Save scenario
SaveScenario(Sou,File)
 n Err
 s Err=$$LtF^LIBdatop(Sou,File,"",1)
 q Err 
 
 ;Send data
Send(Data,Adr)
 n Err
 s Err=$$Send^LIBcomm(Adr,"LIBXupdate",9,$zp(@Data@("")),Data)
 q Err
 
 ;Extesion for file, depends on type of items
GetExt(type)
 i type="R" q ".INT"
 i type="D" q ".dat"
 i type="X" q ".xec"
 i type="C" q ".cls"
 i type="P" q ".prj"
 q ""

LIBchar^INT^1^65302,36249.105042^0
LIBchar
 ;Character-coding
 ;Copyright Slavek Zmek, 2016
.
 ;Diacritics - 1-acute, 2-caron, 3-diaresis, 4-ring, 5-grave, 6-double acute, 7-circumflex
 ;Byte-character tables. Order MUST BE same in all codings
 ; A1 a1 A3 a3 C c D d E1 e1 E e I1 i1 L l N n O1 o1 ????R r R r S s T t U1 u1 U u ?? Y1 y1 Z z ? L l u U o O
 ;Codings: 1 - Kamenicky(CP895), 2 - Windows (CP-1250), 3 - Latin II (CP852)
 ;         4 - without diacritics, 5 - UTF-8, 6 - UTF-16, 7 - ISO 8859-2
 ;Remarks: some codings-table doesn't have apropriate character (e.g. in Kamenicky u with double acute).
 ;         Then the byte-code is stored in Win-1250 coding
 ;Problems: character 241(Win1250)-n with acute, in Kamenicky is not, there is +- sign
 ;          character mi (greek alphabet) is not in CP852 : one way is translation to u, second way is not translated
GetTab(coding)
 i coding=1 q $c(143,160,142,132,128,135,133,131,144,130,137,136,139,161,138,141,165,164,149,162,167,147,153,148,158,169,155,168,134,159,151,163,166,150,154,129,157,152,146,145,230,156,140,171,170,251,245,213)
 i coding=2 q $c(193,225,196,228,200,232,207,239,201,233,204,236,205,237,197,229,210,242,211,243,212,244,214,246,216,248,138,154,141,157,218,250,217,249,220,252,221,253,142,158,181,188,190,192,224,251,245,213)
 i coding=3 q $c(193,160,196,132,172,159,210,212,144,130,183,216,214,161,145,146,213,229,224,162,226,147,153,148,252,253,230,231,155,156,233,163,222,133,154,129,237,236,166,167,117,149,150,232,234,251,245,213)
 i coding=4 q "AaAaCcDdEeEeIiLlNnOoOoOoRrSsTtUuUuUuYyZz?lRruoO"
 i coding=5 q "ÁáÄä????Éé??ÍíŠ???Óó§ôÖö??????Úú??ÜüÝý?????«ª??Õ"
 i coding=6 q $c(193,0,225,0,196,0,228,0,12,1,13,1,14,1,15,1,201,0,233,0,26,1,27,1,205,0,237,0,57,1,58,1,71,1,72,1,211,0,243,0,212,0,244,0,214,0,246,0,88,1,89,1,96,1,97,1,100,1,101,1,218,0,250,0,110,1,111,1,220,0,252,0,221,0,253,0,125,1,126,1,230,0,61,1,62,1,84,1,85,1,113,1,81,1,213,0)
 i coding=7 q $c(193,225,196,228,200,232,207,239,201,233,204,236,205,237,197,229,210,242,211,243,212,244,214,246,216,248,169,185,171,187,218,250,217,249,220,252,221,253,174,190,181,188,190,192,224,251,245,213)
 q ""
 
 ;One-way exceptions
Exc(coding)
 i coding=3 q $c(117)
 q ""
 
 ;Convert byte-characters
Conv(str,cod1,cod2)
 n sou,dest,exc,i,j
 s sou=$$GetTab(cod1)
 s exc=$$Exc(cod1)
 s dest=$$GetTab(cod2)
 i exc="" q $tr(str,sou,dest)
 f i=1:1:$l(exc) s j=$f(sou,$e(exc,i)) i j s sou=$e(sou,1,j-2)_$e(sou,j,$l(sou)),dest=$e(dest,1,j-2)_$e(dest,j,$l(dest))
 q $tr(str,sou,dest)
 
 ;Konvert byte-character to 2-byte
Conv2(str,cod1,cod2)
 n sou,dest,i,j,k,l,m
 s sou=$$GetTab(cod1)
 s dest=$$GetTab(cod2)
 s i=""
 f j=1:1:$l(str) s k=$e(str,j) d
 .s l=$a(k)
 .i l<128 s i=i_k_$c(0) q
 .s m=$f(sou,k)
 .i 'm s i=i_k_$c(0) q
 .s m=m-1
 .s i=i_$e(dest,m*2-1)_$e(dest,m*2)
 q i
 
 ;Convert byte-character to 2-byte optional
Conv2x(str,cod1,cod2)
 n sou,dest,i,j,k,l,m
 s sou=$$GetTab(cod1)
 s dest=$$GetTab(cod2)
 s i=""
 f j=1:1:$l(str) s k=$e(str,j) d
 .s l=$a(k)
 .i l<128 s i=i_k q
 .s m=$f(sou,k)
 .i 'm s i=i_k q
 .s m=m-1
 .s i=i_$e(dest,m*2-1)_$e(dest,m*2)
 q i
 
 ;Convert 2-byte character to 1-byte
Conv3(str,cod1,cod2)
 n sou,dest,i,j,k,k2,l,m
 s sou=$$GetTab(cod1)
 s dest=$$GetTab(cod2)
 s i="",j=0
 f  s j=j+1 q:j>$l(str)  s k=$e(str,j),k2=$e(str,j+1),m=0 d
 .f l=1:2:$l(sou) i $e(sou,l)=k,$e(sou,l+1)=k2 s i=i_$e(dest,l\2+1),j=j+1,m=1 q
 .i 'm s i=i_k,j=j+1
 q i
.
 ;Convert 2-byte character to 1-byte optional
Conv3x(str,cod1,cod2)
 n sou,dest,i,j,k,k2,l,m
 s sou=$$GetTab(cod1)
 s dest=$$GetTab(cod2)
 s i="",j=0
 f  s j=j+1 q:j>$l(str)  s k=$e(str,j),m=0 d
 .i j<$l(str) s k2=$e(str,j+1) f l=1:2:$l(sou) i $e(sou,l)=k,$e(sou,l+1)=k2 s i=i_$e(dest,l\2+1),j=j+1,m=1 q
 .i 'm s i=i_k
 q i
  
 ;Some conversion's ....
 ; Kamenicky -> Win1250
KtW(%) q $$Conv(%,1,2)
 ; W1250 -> Kamenicky
WtK(%) q $$Conv(%,2,1)
 ; W1250 -> UTF8
WtU8(%) q $$Conv2x(%,2,5)
 ; Kamenicky -> Latin II
KtL(%) q $$Conv(%,1,3)
 ; Latin II -> Kamenicky
LtK(%) q $$Conv(%,3,1)
 ; Kamenicky -> without diacritics 
KtX(%) q $$Conv(%,1,4)
 ; Kamenicky -> UTF-8
KtU8(%) q $$Conv2x(%,1,5)
 ; Kamenicky -> UTF-16
KtU16(%) q $$Conv2(%,1,6)
 ; UTF-8 -> Kamenicky
U8tK(%) q $$Conv3x(%,5,1)
 ; UTF-8 -> W1250
U8tW(%) q $$Conv3x(%,5,2)
 ; UTF16 -> Kamenicky
U16tK(%) q $$Conv3(%,6,1)
.
 ;BASE64 - Encoding and Decoding
encB64(text)
 n str,char1,char2,char3,char4,out,block,i,len
 i $g(text)="" q ""
 s str="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",out="",len=0
 f i=1:3:$l(text) s block=$e(text,i,i+2) d
 .s:len&&('(len#76)) out=out_$c(13,10)
 .s char1=$a(block,1)\4
 .s char2=($a(block,1)-($a(block,1)\4*4))*16+($a(block,2)\16)
 .s char3=$s($e(block,2)'="":($a(block,2)-($a(block,2)\16*16))*4+($a(block,3)\64),1:64)
 .s char4=$s($e(block,3)'="":($a(block,3)#64),1:64)
 .s out=out_$e(str,char1+1)_$e(str,char2+1)_$e(str,char3+1)_$e(str,char4+1)
 .s len=len+4
 q out
encB64nolf(text)
 q $tr($$encB64(text),$c(13,10))
decB64(text)
 n strBase64,char1,char2,char3,out,block,i
 i $g(text)="" q ""
 s strBase64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",out="",text=$tr(text,$c(13,10))
 f i=1:1:$l(strBase64) s strBase64($e(strBase64,i))=i-1
 
 f i=1:4:$l(text) s block=$e(text,i,i+3) d
 .s char1=(strBase64($e(block,1))*4) + (strBase64($e(block,2))\16)
 .s char2=(strBase64($e(block,2))#16*16) + $s($e(block,3)="=":0,1:strBase64($e(block,3))\4)
 .s char3=$s($e(block,3)="=":"", 1: strBase64($e(block,3))#4*64 + $s($e(block,4)="=":0,1:strBase64($e(block,4))) )
 .;s out=out_$c(char1)_$tr($c(char2,char3),$c(0)) ???? it would be shorter.....
 .s out=out_$c(char1)_$c(char2,char3)
 q out

LIBcomm^INT^1^65031,55141.316471^0
LIBcomm
 ;Communication-messaging, utility
 ;Copyright Slavek Zmek, 2006
.
 ;Start all services according to settings
XSTART
 ;TCP - server
 i $d(^XMAloc("S")) j start^LIBcomms
 ;TCP - client
 i $d(^XMAloc("C")) j start^LIBcommc
 ;X - daemon
 i $d(^XMAloc("X")) j start^LIBcommx
 ;R - daemon
 i $d(^XMAloc("R")) j start^LIBcommr
 ;REST - server
 i $d(^XMAloc("T")) j start^LIBserverr
 q
 ;Stop all services according to settings
XSTOP
 ;TCP - server
 i $d(^XMAloc("S")) d stop^LIBcomms
 ;TCP - client
 i $d(^XMAloc("C")) d stop^LIBcommc
 ;X - daemon
 i $d(^XMAloc("X")) d stop^LIBcommx
 ;R - daemon
 i $d(^XMAloc("R")) d stop^LIBcommr
 ;REST - server
 i $d(^XMAloc("T")) d stop^LIBserverr
 q
   
 ;Get index of message(^XMP)
GetXMP()
 n Idx,End,Next
 ;Limits
 s Idx=+$g(^XMA("P","C"))
 s End=+$g(^XMA("P","E"))
 i 'End s End=1000000
 l +^XMP
 s Next=0
 f  s Idx=Idx+1 d  q:'$d(^XMP(Idx))
 .i Idx>End,'Next s (Next,Idx)=1
 .;Server's synchronization, maybe not neccessary...
 .l +^XMP(Idx)
 .l -^XMP(Idx)
 s ^XMA("P","C")=Idx,^XMP(Idx)=""
 l -^XMP
 q Idx
 
 ;Send message - get index of message(^XMD) (3.level), accept message to process
 ; %1 - To                  - 1.level
 ; %2 - Sender              - 2.level
 ; %3 - Priority            - 1-9, default 5
 ; %4 - Index of message
DoXMD(%1,%2,%3,%4)
 n Ok,i,j
 ;Make 3.level - priority, date, time
 s i=$p($h,",",2),i=$e("0000",1,5-$l(i))_i
 i '%3 s %3=5
 s j=%3_(+$h)_i
 s Ok=0
 f  d  q:Ok
 .s i=$zp(^XMD(%1,%2,j+1))
 .i i'<j s j=j+.001
 .l +^XMD(%1,%2,j):0 e  q
 .i $d(^XMD(%1,%2,j)) l -^XMD(%1,%2,j) q
 .s Ok=1
 
 s ^XMD(%1,%2,j)=%4
 l -^XMD(%1,%2,j)
 q
 
 ;Send message, prepared in variable (local or global)
Send(Adr,MsgI,Pri,%Num,%Data,oKS,oTN)
 ; Adr   - To (logical address)
 ; MsgI  - Identificaton od the message
 ; Pri   - Priority (1-9, 1 fastest)
 ; %Num  - Number of lines in Message
 ; %Data - Message
 ; oKS   - Sender, if not set then default
 ; oTN   - Transaction number
 
 n Err,i,Num,index
 s $zt=$$SetZT^LIBm("syserr^LIBcomm")
 i Adr="" q 1
 s Err=$$Ini(Adr,MsgI,Pri,.Num,.index,$g(oKS),$g(oTN))
 i Err q Err
 ; Body
 f i=1:1:%Num d Li(@(%Data)@(i),index,.Num)
 s Err=$$Cl(index,Num)
 q Err
.
 ;Send message in JSON, content in variable (local or global)
SendJSON(Adr,MsgI,Pri,%Num,%Data,oKS,oTN)
 ; Parameters: same meaning as previous function Send
 
 n Err,Num,index
 s $zt=$$SetZT^LIBm("syserr^LIBcomm")
 i Adr="" q 1
 s Err=$$Ini(Adr,MsgI,Pri,.Num,.index,$g(oKS),$g(oTN))
 i Err q Err
 ; Body
 d EncodeX^LIBjson(%Data,$na(^XMP(index)),1)
 s Num=$zp(^XMP(index,""))
 s Err=$$Cl(index,Num)
 q Err
 
 ;Initializaton - index of message
Ini(Adr,MsgI,Pri,Num,Idx,oKS,oTN)
 ; MsgI  - Identificaton od the message
 ; Pri   - priority - 1 fastest
 ; Num   - counter of lines, must be called by reference (returns value)
 ; Idx   - index, must be caled by reference (returns value)
 ; oKS   - Sender, if not set then default
 ; oTN   - Transaction number
 s $zt=$$SetZT^LIBm("syserr^LIBcomm")
 s Idx=$$GetXMP()
 ;Head
 s Num=0
 i $g(oKS)="" s oKS=$g(^XMAloc("KOM","ADR")) i oKS="" s oKS="???"
 ;First piece was type of message, now constantly "1"
 s ^XMP(Idx,0)="1#"_Adr_"#"_MsgI_"#"_$h_"#"_Num_"#"_oKS_"#"_Pri_"#"_$g(oTN)
 q 0
 
 ;Next line of the message
Li(TXT,Idx,Num)
 s Num=Num+1,^XMP(Idx,Num)=TXT
 q
 
 ;Close message, prepared to send
Cl(Idx,Num)
 n i,j
 s i=^XMP(Idx,0)
 s $p(i,"#",5)=Num
 i $p(i,"#",3)'="LIBcommt",$p(i,"#",8)'="",$g(^XMAloc("KOM","TRACE")) s $p(i,"#",8)=$$GetTN^LIButil()
 s ^XMP(Idx,0)=i
 s j="*"
 i $p(i,"#",2)=$g(^XMAloc("KOM","ADR")) s j=$p(i,"#",2)
 d DoXMD(j,$p(i,"#",6),$p(i,"#",7),Idx)
 q 0
 
syserr
 s $zt=""
 l
 q 1
 
 ;Remove link to a message(XMD)
RemXMD(A1,A2,Id)
 n i,j
 s i=$g(^XMD(A1,A2,Id))
 k ^XMD(A1,A2,Id)
 i i="" q
 l +^XMP(i)
 s j=$g(^XMP(i))-1
 i j<1 k ^XMP(i)
 e  s ^XMP(i)=j
 l -^XMP(i)
 q
 
 ;Pack variables
Pack(Dest,Prom,NoKill)
 n i,j,k,end,c,named,names
 i $g(Dest)="" s Dest="MSG"
 i '$g(NoKill) k @Dest
 s c=$zp(@Dest@(""))
 f i=1:1:$l(Prom,"|") s j=$p(Prom,"|",i) i j'="" d
 .s k=$p(j,":"),j=$p(j,":",2)
 .s end=$s(k[")":$p(k,")")_",",1:k_"(")
 .i j="" s j=k
 .s named=$s(j'[")":j_"(",1:$p(j,")",1,$l(j,")"-1))_",")
 .s names=$s(end'[")":end,1:$p(end,")",1,$l(end,")"-1)))
 .i $d(@k)#10 s c=c+1,@Dest@(c)=j_"="_$$Val(k)
 .f  s k=$q(@k) q:k=""!(k'[end)  d
 ..s c=c+1,@Dest@(c)=named_$e(k,$l(names)+1,999)_"="_$$Val(k)
.
 q
.
 ;Unpack variables
Unpack(Sou,Start,End,Check)
 n i,j,k,l
 i $d(Sou)="" s Sou="MSG"
 i Sou[")" s Sou=$p(Sou,")")
 s Sou=Sou_$s(Sou["(":",",1:"(")_"i)"
 s i=""
 i '$g(Start) s Start=$o(@Sou)
 i '$g(End) s End=$zp(@Sou)
 i $g(Check) d
 .f i=Start:1:End d
 ..s k=@Sou
 ..i $e(k,$l(k))="""" s k=$e(k,1,$l(k)-1)
 ..s j=$f(k,"""")
 ..s l=$e(k,1,j-1),k=$e(k,j,$l(k))
 ..f  q:k=""  d
 ...s j=$f(k,"""")
 ...i 'j s l=l_k,k="" q
 ...s l=l_$e(k,1,j-1)_"""",k=$e(k,j,$l(k))
 ..s @Sou=l_""""
 
 f i=Start:1:End s @@Sou
 q
  
 ;Fill double-quotes for packing
Val(%)
 n i,j,k
 s j=@%
 s i=""
 f k=1:1:$l(j,"""") s $p(i,"""""",k)=$p(j,"""",k)
 q """"_i_""""
 

LIBcommc^INT^1^64671,50195.025843^0
LIBcommc
 ;Communication-messaging, client
 ;Copyright Slavek Zmek, 2005
.
 q
 
 ;Starting point
start
 s ^XMAloc("C","job")=$j
 d SetLic^LIBm("")
 
Loop
 s $zt=$$SetZT^LIBm("ERR^LIBcommc")
 i $g(^XMAloc("C","job"))'=$j q
 
 ;Parameters
 s Srv=$g(^XMAloc("C","IP"))
 i Srv="" d log^LIBcommu("Server is not defined !") q
 s TOh=+$g(^XMAloc("C","TOH"))
 i 'TOh s TOh=1
 s Port=$g(^XMAloc("C","PORT"))
 i Port="" d log^LIBcommu("Port is not defined !") q
 s Cout=$g(^XMAloc("C","CTO"))
 i 'Cout s Cout=10
 s RTo=$g(^XMAloc("C","RTO"))
 i 'RTo s RTo=20
 s Maxb=$g(^XMAloc("C","MXB"))
 i 'Maxb s Maxb=65000
 s Maxs=$g(^XMAloc("C","MXS"))
 i 'Maxs s Maxs=50
 s Coding=+$g(^XMAloc("C","Coding"))
 
 ;Connection with server
 s Socket="|TCP|4"
 s Status=$$CONNECT(Srv,Port)
 i 'Status d log^LIBcommu("Error while connecting to server") g Loop
 d log^LIBcommu("Connected to server "_Srv_" port "_Port)
 
 s KS=$g(^XMAloc("C","KS"))
 s AdrO=$g(^XMAloc("C","KSO"))
 i AdrO="" s AdrO=$g(^XMAloc("KOM","NIS"))
 i AdrO="" s AdrO="*"
.
 f  d  q:'Status
 .s Act=0
 .f KSi=1:1:$l(KS,",") s KSnode=$p(KS,",",KSi) i KSnode'="" d Rcv
 .i 'Status q
 .f KSi=1:1:$l(AdrO,",") s AdrN=$p(AdrO,",",KSi) i $d(^XMD(AdrN))>9 d Snd
 .;Timeout
 .i 'Act h TOh
 .i $g(^XMAloc("C","job"))'=$j s Status=0
 
 d DISCON^LIBcommu
 g Loop
 
 ;Error, wait a moment because cycling
ERR
 d DISCON^LIBcommu
 h 5
 g Loop
 
 ;Stop client
stop
 s ^XMAloc("C","job")=0
 q
 
 ;Receiving messages from server
Rcv
 n Cont,i,IdMSG,Hl,Data,AdMSG,LimZ
 s (LimZ,Cont)=0
 f  d  q:Cont=-1  q:'Status  i $g(^XMAloc("C","job"))'=$j q
 .i Cont=0,LimZ>5 s Cont=-1 q
 .s LimZ=LimZ+1
 .s i=KSnode_"|1|"
 .i Cont>0 s i=i_IdMSG_"|"_Cont_"|"_AdMSG
 .d log^LIBcommu("Question to server")
 .s Status=$$SendMSG(i_"||","")
 .i 'Status q
 .s Status=$$RecMsg^LIBcommu(.Hl,.Data)
 .d log^LIBcommu("Receiving data from server: "_Hl)
 .i 'Status q
 .d log^LIBcommu("Analyze data from server")
 .d Rcv1
 
 q
 
 ;Receiving one message
Rcv1
 n i,j,k,l
 i $p(Hl,"|",2)'=2 d  q
 .d log^LIBcommu("Unexpected message-2"_Hl)
 .s Status=0
 
 s IdMSG=$p(Hl,"|",3)
 i IdMSG="" s Cont=-1 q
.
 s Act=1
 i '$d(MSGco(IdMSG)) s MSGco(IdMSG)=$$GetXMP^LIBcomm()
 s i=MSGco(IdMSG)
.
 f  q:Data=""  d
 .s j=$a(Data,4)*256+$a(Data,3)*256+$a(Data,2)*256+$a(Data)
 .s l=$a(Data,6)*256+$a(Data,5)
 .s k=$e(Data,7,6+l)
 .i Coding s k=$zcvt(k,"I","UTF8")
 .s ^XMP(i,j)=k
 .s Data=$e(Data,7+l,$l(Data))
  
 s Cont=$p(Hl,"|",4)
 i Cont s AdMSG=$p(Hl,"|",5,7) q
 
 s j=$p($g(^XMP(i,0)),"#",7)
 i 'j s j=3
 d DoXMD^LIBcomm($p(Hl,"|",5),$p(Hl,"|",6),j,i)
 
 s i=KSnode_"|3|"_IdMSG_"|"_Cont_"|"_$p(Hl,"|",5)_"|"_$p(Hl,"|",6)_"|"_$p(Hl,"|",7)_"|"
 s Status=$$SendMSG(i,"")
 i 'Status q
 s Status=$$RecMsg^LIBcommu(.Hl,.Data)
 k MSGco(IdMSG)
 q
 
 ;Send message to server. Number is limited because to manage receiving too
Snd
 n Cont,KSnode,Tim,Hl,Data,WFi,LimZ,Exit,MLen,Line,LineP,IdMSG
 s (LimZ,Exit)=0
 s KSnode=""
 f  s KSnode=$o(^XMD(AdrN,KSnode)) q:KSnode=""  d  q:'Status  i $g(^XMAloc("C","job"))'=$j q
 .f  s Tim=$o(^XMD(AdrN,KSnode,"")) q:Tim=""  d  q:'Status  q:Exit  i $g(^XMAloc("C","job"))'=$j q
 ..s LimZ=LimZ+1
 ..i LimZ>Maxs s (Exit,Act)=1 q
 ..s IdMSG=$g(^XMD(AdrN,KSnode,Tim))
 ..i IdMSG="" q
 ..s Cont=0,WFi=""
 ..f  d  q:'Cont  q:'Status
 ...s Hl=AdrN_"|5|"
 ...s Data=""
 ...s Line=$s(Cont:Cont,1:"")
 ...s (Cont,MLen,LineP)=0
 ...f  s Line=$o(^XMP(IdMSG,Line)) q:Line=""  q:Cont  d
 ....s k=^XMP(IdMSG,Line)
 ....i Coding s k=$zcvt(k,"O","UTF8")
 ....s MLen=MLen+$l(k)+6
 ....;Send one node at least...
 ....i LineP,MLen>Maxb s Cont=Line-1 q
 ....s LineP=1,i=$l(k)
 ....s Data=Data_$c(Line#256,Line\256#256,Line\65536#256,Line\16777216)_$c(i#256,i\256)_k
 ...s Hl=Hl_WFi_"|"_Cont_"|"_AdrN_"|"_KSnode_"|"_Tim_"|"
 ...s Status=$$SendMSG(Hl,Data)
 ...i 'Status q
 ...s Status=$$RecMsg^LIBcommu(.Hl,.Data)
 ...i 'Status q
 ...i $p(Hl,"|",2)'=6 s Status=0 q
 ...i 'Cont d RemXMD^LIBcomm(AdrN,KSnode,Tim) q
 ...s WFi=$p(Hl,"|",3)
 ...s LimZ=LimZ+1
 
 q
 
 ;Send message to server
SendMSG(Hl,Data)
 n Status,HLen,DataLen
 s HLen=$l(Hl)
 s DataLen=$l(Data)
 i 'DataLen s DataLen=65535
 s Hl=Hl_$j("",98-HLen)_$c(DataLen#256,DataLen\256)
 
 s Status=$$Send^LIBcommu(Hl)
 i 'Status d  q Status
 .d log^LIBcommu("Error while sending question to server")
 .d DISCON^LIBcommu
.
 i Data="" q Status
 
 s Status=$$Send^LIBcommu(Data)
 i 'Status d
 .d log^LIBcommu("Error while sending question-data to server")
 .d DISCON^LIBcommu
 
 q Status
 
 ;Connect to server
CONNECT(Srv,Port)
 s $zt=$$SetZT^LIBm("CONERR^LIBcommc")
 o Socket:(Srv:Port:"S":):Cout
 q $t
 
 ;Error in communication with server
CONERR
 n i
 s i=$ze
 s $zt=""
 d log^LIBcommu("Error: "_i)
 i $ze["NOTOPEN" s HALT=1
 q 0

LIBcomme^INT^1^64671,57599.041409^0
LIBcomme
 ;Communication-messaging, non-delivered messages
 ;Copyright Slavek Zmek, 2018
.
 ;Returning message for delivery
Return(%)
 n i,j,k,Idx
 s i=^XME(%,0),k=$zp(^XME(%,"")),j=$p(i,"#",5)
 i j'=k s Txt=$$Get^ISBnls("X","MsgDifLen")_"("_j_" - "_k_")" q 1
 f k=1:1:j q:'$d(^XME(%,k))
 i k<j s Txt=$$Get^ISBnls("X","MsgNoNode")_" ("_k_")" q 1
.
 ;Now all is OK, and return.....
 s Idx=$$GetXMP^LIBcomm()
 m ^XMP(Idx)=^XME(%)
 s j="*"
 i $p(i,"#",2)=$g(^XMAloc("KOM","ADR")) s j=$p(i,"#",2)
 d DoXMD^LIBcomm(j,$p(i,"#",6),$p(i,"#",7),Idx)
 k ^XME(%)
 q 0

LIBcommr^INT^1^65162,31652.36106^0
LIBcommr
 ;Communication-messaging, real-daemon
 ;Copyright Slavek Zmek, 2005
 
 q
 
 ;Starting point
start
 s $zt=$$SetZT^LIBm("err^LIBcommr")
 s ip=$g(^XMA("P","IP"))
 d SetLic^LIBm(ip)
 s ^XMAloc("R","job")=$j
 i '$g(^XMAloc("R","MID")) s ^XMAloc("R","MID")=$h-1
 
 ;Basic loop
LOOP
 s $zt=$$SetZT^LIBm("err^LIBcommr")
 i '$g(^XMAloc("R","job")) g stop
 
 s xActionCont=0
 ;Midnight's program
 i ^XMAloc("R","MID")'=+$h d Midn
 ;Network - messages,...
 i $g(^XMAloc("R","NET")) d NET
 ;Background jobs
 i $g(^XMAloc("R","BGJ"))'="" d BGjob
 ;User-defined procedure - called in every loop
 i $g(^XMAloc("R","USER"))'="" d User
 ;User-defined job - test in every loop
 i $g(^XMAloc("R","USERJ")) d
 .s i=""
 .f  s i=$o(^XMAloc("R","USERJ",i)) q:i=""  d
 ..s j=$g(^XMAloc("R","USERJ",i,"C"))-1
 ..i j>0 s ^XMAloc("R","USERJ",i,"C")=j q
 ..;Test, if run is possible
 ..s j=$g(^XMAloc("R","USERJ",i,"R"))
 ..i j'="",$$USERJT(i) j USERJ(i)
 ..;Set next run
 ..s j=$g(^XMAloc("R","USERJ",i,"Cx"))
 ..i 'j s j=30
 ..s ^XMAloc("R","USERJ",i,"C")=j
 
 i '$g(^XMAloc("R","job")) g stop
 ;Second run - stop
 i $g(^XMAloc("R","job"))'=$j q
 ;Loop must not be so quick...
 i '$g(xActionCont) h .2
 l
 g LOOP
 
 ;Network - communication
NET
 n xCou,Sname,xx,xI1,xI2,name,xNETSTOP
 s $zt=$$SetZT^LIBm("NETerr^LIBcommr")
 ;Test - communication's break
 s xx=$g(^XMAloc("R","NETB"))
 i xx'="" d  q
 .i $p(xx,",")>$h q
 .i $p(xx,",")=+$h,$p(xx,",",2)>$p($h,",",2) q
 .k ^XMAloc("R","NETB")
 
 s Sname=$g(^XMAloc("R","ADR"))
 i Sname="*" q
 i Sname="" s Sname=^XMAloc("KOM","ADR")
 f xx=1:1:$l(Sname,",") s xCou=0 d  i xCou>10 s xActionCont=1 q
 .s name=$p(Sname,",",xx)
 .s xI1=""
 .f  s xI1=$o(^XMD(name,xI1)) q:xI1=""  d  q:xCou>10
 ..f  s xI2=$o(^XMD(name,xI1,"")) q:xI2=""  d  q:xCou>10
 ...d Accept^LIBcommx(name,xI1,xI2)
 ...i $g(xNETSTOP) s xCou=9999
 ...s xCou=xCou+1
 
 q
 
NETerr
 s $zt=""
 d WE^LIBerr("R-daemon NET","R-D")
 q
 
 ; Jobs - background, print, ....
BGjob
 n Co,i,D,T,Id,Type,Mode
 ;Recent free types
 s Co=""
 f i="T","J","F" i '$g(^XMAloc("RC",i)) s Co=Co_i
 i Co="" q
 s D=""
 f  s D=$o(^XJOB(D)) q:D=""  q:D>+$h  d  q:Co=""
 .s T=""
 .f  s T=$o(^XJOB(D,T)) q:T=""  q:(D=+$h)&(T>$p($h,",",2))  d  q:Co=""
 ..s Id=""
 ..f  s Id=$o(^XJOB(D,T,Id)) q:Id=""  i '$g(^XJOB(D,T,Id,"E")) d
 ...i $g(^XJOB(D,T,Id,"E")) q
 ...s Type=^XJOB(D,T,Id,"Type")
 ...i '$f(Co,Type) q
 ...s Mode=^XJOB(D,T,Id,"Mode")
 ...i 'Mode j JOB(D,T,Id)
 ...i Mode j JOBX(Type)
 ...s Co=$tr(Co,Type)
 q
 ;Job - one task
JOB(D,T,Id)
 s $zt=$$SetZT^LIBm("JOBerr^LIBcommr")
 s Type=^XJOB(D,T,Id,"Type")
 s ^XMAloc("RC",Type)=$j
 d Run^LIBjob(D,T,Id)
 k ^XMAloc("RC",Type)
 q
 ;Job - all tasks for one type
JOBX(Type)
 s $zt=$$SetZT^LIBm("JOBerr^LIBcommr")
 s ^XMAloc("RC",Type)=$j
 s Typx=$s(Type="J":1,Type="F":2,1:0)
 s D=""
 f  s D=$o(^XJOB(D)) q:D=""  q:D>+$h  d
 .s T=""
 .f  s T=$o(^XJOB(D,T)) q:T=""  q:(D=+$h)&(T>$p($h,",",2))  d
 ..s Id=""
 ..f  s Id=$o(^XJOB(D,T,Id)) q:Id=""  d
 ...i $g(^XJOB(D,T,Id,"E")) q
 ...i Type=^XJOB(D,T,Id,"Type") d Run^LIBjob(D,T,Id)
 
 k ^XMAloc("RC",Type)
 q
JOBerr
 s $zt=""
 d WE^LIBerr("Run task "_$g(Prg),"R-D")
 k ^XMAloc("RC",Type)
 q
.
 ;User jobs-cyclic
USERJ(%)
 s $zt=$$SetZT^LIBm("USERJE^LIBcommr")
 s Rou=$g(^XMAloc("R","USERJ",%,"R"))
 i Rou="" q
 s ^XMAloc("R","USERJ",%,"J")=$j
 d @Rou
 k ^XMAloc("R","USERJ",%,"J")
 q
USERJE
 s $zt=""
 d WE^LIBerr("User-C","R-D")
 k ^XMAloc("R","USERJ",%,"J")
 q
 ;Test if run job is posssible
USERJT(%)
 n i,j
 i $g(^XMAloc("R","USERJ",%,"J")) q 0
 s i=$g(^XMAloc("R","USERJ",%,"T"))
 i i="" q 1
 s i="j=$$"_i
 s @i
 q j
 
 ;Stop
stop
 s ^XMAloc("R","job")=0
 q
 
 ;Reset - indication of subprocceses
reset
 n i
 f i="T","J","F","C" k ^XMAloc("RC",i)
 q
  
err
 s $zt=""
 ;For loop....
 h 2
 s $zt=$$SetZT^LIBm("LOOP^LIBcommr")
 d WE^LIBerr("R-daemon","R-D")
 g LOOP
.
 ;Procedure to call from other routines - break of communication on x seconds (parameter)
SetNETb(%)
 n i
 s i=$h
 s i=$p(i,",")_","_($p(i,",",2)+%)
 s xNETSTOP=1
 s ^XMAloc("R","NETB")=i
 q
 
 ;Midnight's program
Midn
 n Rou
 s $zt=$$SetZT^LIBm("ErrM^LIBcommr")
 s Rou=$g(^XMAloc("R","MIDR"))
 i Rou'="" d @Rou
 s ^XMAloc("R","MID")=+$h
 q 
 
ErrM
 s $zt=""
 d WE^LIBerr("R-daemon MID","R-D")
 s ^XMAloc("R","MID")=+$h
 q
 
 ;User-defined procedure
User
 n Rou
 s $zt=$$SetZT^LIBm("ErrU^LIBcommr")
 s Rou=$g(^XMAloc("R","USER"))
 i Rou'="" d @Rou
 q 
 
ErrU
 s $zt=""
 d WE^LIBerr("R-daemon USER","R-D")
 q 

LIBcomms^INT^1^64671,49139.51927^0
LIBcomms
 ;Communication-messaging, server
 ;Copyright Slavek Zmek, 2005
 
 q
 
 ;Starting point
start
 s ^XMAloc("S","job")=$j
 d SetLic^LIBm("")
 
 ;Server-parameters
 s Port=$g(^XMAloc("S","PORT"))
 i Port="" d log^LIBcommu("Port is not defined !") q
 s CTo=$g(^XMAloc("S","CTO"))
 i 'CTo s CTo=10
 
 s $zt=$$SetZT^LIBm("err^LIBcomms")
 s Socket="|TCP|"_Port
 c Socket
 d log^LIBcommu("Starting server, port "_Port)
 o Socket:(:Port:"SA"::32767:32767:10):CTo
 i '$t d log^LIBcommu("Cannot start server !") g end
 
 u Socket
 d log^LIBcommu("Listening...")
 
 ;Listen loop
Loop
 i '$g(^XMAloc("S","job")) g end
 r xX:20
 i '$t g Loop
 
 s i=$zu(111,0)
 s j=$a(i,1)_"."_$a(i,2)_"."_$a(i,3)_"."_$a(i,4)
 d log^LIBcommu("Connection with "_j_":"_($a(i,5)*256+$a(i,6))_", starting subprocess")
 i $v(0,-2,$zu(40,0,1))\(2**16)#2 d log^LIBcommu("Stopping server") g end
 j child(j,Port):(:24):CTo
 i '$t d log^LIBcommu("Cannot start subprocess") w *-2 
 g Loop
 
 ;Stop server
stop
 s ^XMAloc("S","job")=0
 q
  
 ;Error...
err
 s $zt=""
 d log^LIBcommu("Error..."_$ze)
 q
 
end
 i $g(Socket)'="" c Socket
 d log^LIBcommu("Server stopped")
 s ^XMAloc("S","job")=0
 q
 
 ;Subprocess - child for one client
child(ip,port)
 s $zt=$$SetZT^LIBm("errc^LIBcomms")
 d log^LIBcommu("Starting subprocess..."_$j)
 u $zu(53)
 ;Makes the last device in use the principal I/O device
 d $zu(132)
 u 0:(::"+S"::32767:32767)
 d SetLic^LIBm(ip)
 d log^LIBcommu("Subprocess runs...")
 
 s Socket=$p
 s RTo=$g(^XMAloc("S","RTO"))
 i 'RTo s RTo=20
 s Maxb=$g(^XMAloc("S","MXB"))
 i 'Maxb s Maxb=65000
 s Coding=+$g(^XMAloc("S","Coding"))
 
 ;Child's message loop
child2
 s Err=$$RecMsg^LIBcommu(.Hl,.Xx)
 i 'Err g:$g(HALT) halt g child2
 
 d log^LIBcommu("Receive message "_Hl)
 s Adr=$p(Hl,"|")
 i Adr="" d log^LIBcommu("Unknown adress") g child2
 s Type=$p(Hl,"|",2)
 s IdMSG=$p(Hl,"|",3)
 s Cont=$p(Hl,"|",4)
 
 s (MsgOK,Err)=0
 i Type=1 s Err=$$GetMsg,MsgOK=1
 i Type=3 s Err=$$DelMsg,MsgOK=1
 i Type=5 s Err=$$RcvMsg,MsgOK=1
 
 i '$g(^XMAloc("S","job")) s Err=0
 i Err g child2
 i 'MsgOK d log^LIBcommu("Unknown type of message "_Type)
 i $g(^XMAloc("S","job")) g child2
.
 d log^LIBcommu("Stopping subprocess...")
 w *-3
 c Socket
 q
 
 ; Child's error
errc
 s $zt=""
 d log^LIBcommu($ze)
 i $ze["READ" g halt
 g child2
 
 ;Halt child connection  
halt
 d log^LIBcommu("Subprocess stopped")
 q
 
 ;Odeslani dat klientovi
SendMSG(Hl,Data)
 n HLen,DLen,Status
 d log^LIBcommu("Answer:"_Hl)  
 s HLen=$l(Hl)
 s DLen=$l(Data)
 i 'DLen s DLen=65535
 s Hl=Hl_$j("",98-HLen)_$c(DLen#256,DLen\256)
 s Status=$$Send^LIBcommu(Hl)
 i 'Status d  q Status
 .d log^LIBcommu("Error while sending data to client")
 .d DISCON^LIBcommu
  
 i Data="" q Status
 s Status=$$Send^LIBcommu(Data)
 i 'Status d  q Status
 .d log^LIBcommu("Error while sending data to client")
 .d DISCON^LIBcommu
  
 q Status
 
 ;Pozadavek na zpravy ze serveru
GetMsg()
 n i,j,Adr1,Nr1,MLen,Line
 s i=Adr_"|2|",j=""
 i IdMSG'="" d
 .s Adr1=$p(Hl,"|",6)
 .s Nr1=$p(Hl,"|",7)
 i IdMSG="" d
 .s Adr1=$o(^XMD(Adr,""))
 .i Adr1="" q
 .s Nr1=$o(^XMD(Adr,Adr1,""))
 .i Nr1="" q
 .s IdMSG=^XMD(Adr,Adr1,Nr1)
  
 s i=i_IdMSG_"|"
 i IdMSG'="" d
 .s Line=$s(Cont:Cont,1:"")
 .s (Cont,MLen)=0
 .f  s Line=$o(^XMP(IdMSG,Line)) q:Line=""  q:Cont  d
 ..s k=^XMP(IdMSG,Line)
 ..i Coding s k=$zcvt(k,"O","UTF8")
 ..s MLen=MLen+$l(k)+6
 ..i MLen>Maxb s Cont=Line-1 q
 ..s l=$l(k)
 ..s j=j_$c(Line#256,Line\256#256,Line\65536#256,Line\16777216)_$c(l#256,l\256)_k
 .s i=i_Cont_"|"_Adr_"|"_Adr1_"|"_Nr1_"|"
 
 q $$SendMSG(i,j)
 
 ;Delete message
DelMsg()
 d RemXMD^LIBcomm($p(Hl,"|",5),$p(Hl,"|",6),$p(Hl,"|",7))
 q $$SendMSG(Adr_"|4||","")
 
 ;Receive message
RcvMsg()
 n i,j,k
 i IdMSG="" s IdMSG=$$GetXMP^LIBcomm
 f  q:Xx=""  d
 .s i=$a(Xx,4)*256+$a(Xx,3)*256+$a(Xx,2)*256+$a(Xx)
 .s j=$a(Xx,6)*256+$a(Xx,5)
 .s k=$e(Xx,7,6+j)
 .s Xx=$e(Xx,7+j,$l(Xx))
 .i Coding s k=$zcvt(k,"I","UTF8")
 .s ^XMP(IdMSG,i)=k
 
 i 'Cont d
 .s i=+$p($g(^XMP(IdMSG,0)),"#",7)
 .i i>9 s i=9
 .i 'i s i=3
 .d DoXMD^LIBcomm($p(Hl,"|",5),$p(Hl,"|",6),i,IdMSG)
 
 q $$SendMSG(Adr_"|6|"_IdMSG_"|"_Cont_"|","")

LIBcommt^INT^1^64901,48621.518775^0
LIBcommt(%)
 ;Communication-messaging, tracing
 ;Copyright Slavek Zmek, 2018
 ;*
 
 ;Receive tracing-messages
 i %?1N.N s xroot=$na(^XMP(%))
 e  s xroot=%
 ;Header
 s cHeader=$g(@xroot@(0))
 ;Data
 s Oper=$g(@xroot@(1))
 s Header=$g(@xroot@(2))
 s Data=$g(@xroot@(3))
 s Horolog=$g(@xroot@(4))
 i Oper="" q
 s LC=$p(Header,"#",8)
 i LC="" s LC="???"
 s From=$p(Header,"#",2)
 s To=$p(Header,"#",6)
 s Adr=$p(Data,"#")
 i Horolog="" s Horolog=$h
 i $e(Oper,1,4)="PING" g Ping
 ;Index
 s Ref=$na(^XMT("M",LC,"L",Horolog))
 s Idx=$$GetUniq^LIButil(Ref)
 ;Header
 s i="",Ok=0
 f  s i=$o(^XMT("M",LC,"H",i)) q:i=""  i ^XMT("M",LC,"H",i)=Header s Ok=1 q
 i 'Ok d
 .s i=$zp(^XMT("M",LC,"H",""))+1
 .s ^XMT("M",LC,"H",i)=Header
 .s ^XMT("I","F",From,LC)=""
 .s ^XMT("I","T",To,LC)=""
 .s i=$p(Header,"#",3)
 .i i="" s i="???"
 .s ^XMT("I","H",i,LC)=""
 ;Indexing - via horolog
 s ^XMT("H",Horolog,LC,Idx)=""
 ;Analyzing Operation
 i Oper="Send" d Send
 i Oper="Receive" d Rec
 i Oper="Resp" d Resp
 l -@Ref@(Idx)
 q
 
 ;Ping
Ping
 n DataO
 ;Place
 s DataO(1)=Data
 s DataO(2)="PINGans"
 s DataO(3)=$h
 s Err=$$Send^LIBcomm($p(cHeader,"#",6),"LIBXmsgans",9,4,"DataO")
 q 
.
 ;Sending message
Send
 s @Ref@(Idx,1)="Send"
 s @Ref@(Idx,2)=Adr
 q
 
 ;Receive message
Rec
 s @Ref@(Idx,1)="Receive"
 s @Ref@(Idx,2)=Adr
 q
.
 ;Response message
Resp
 s @Ref@(Idx,1)="Response"
 s @Ref@(Idx,2)=Adr
 q
 
 ;Procedure for tracing
SendTrace(Idx,Op)
 n Data,Err,Adr
 s Adr=$g(^XMA("P","TRACE"))
 i Adr="" s Adr=$g(^XMAloc("R","ADR"))
 i Adr="" q
 s Data(1)=Op
 s Data(2)=$g(^XMP(Idx,0))
 s Data(3)=$g(^XMAloc("KOM","ADR"))
 s Data(4)=$h
 s Err=$$Send^LIBcomm(Adr,"LIBcommt",9,4,"Data")
 q
.
 ;Procedures for PING
SendPing(Adr)
 n Data,Err,Place,Data
 s Place=$$GetPlace^LIBXmsgans()
 s Data(1)="PINGreq"
 s Data(2)=""
 s Data(3)=Place
 s Data(4)=$h
 s Err=$$Send^LIBcomm(Adr,"LIBcommt",9,4,"Data")
 ;Wait for answer
 s Err=$$Wait^LIBXmsgans(Place,"DataI")
 i Err q
 ;No answer - mail or other warning
 q
 

LIBcommu^INT^1^63939,34706^0
LIBcommu
 ;Communication-messaging, utility for server/client
 ;Copyright Slavek Zmek, 2005
 ;*
.
RecMsg(Hea,Data)
 n Buf,DLen,Status
 s Status=$$Read(100,.Buf)
 i 'Status q Status
  
 s Hea=Buf
 s DLen=$a(Buf,100)*256+$a(Buf,99)
 i DLen=65535 s Data="" q Status
  
 s Status=$$Read(DLen,.Buf)
 i 'Status d  q Status
 .d log("Chyba pri cteni dat")
 .d DISCON
 
 s Data=Buf
 q Status
.
 ;Read data
Read(Len,Dest)
 n Buf,RLen,Rest,Status
 s $zt=$$SetZT^LIBm("CONERR^LIBcommu")
 s RLen=0,Rest=Len,Dest=""
 f  d  q:((RLen=Len)!('Status))
 .s Rest=Len-RLen
 .u Socket r Buf#Rest:RTo s Status=$t
 .s RLen=RLen+$l(Buf),Dest=Dest_$g(Buf)
 q Status
 
 ;Sending data
Send(%)
 s $zt=$$SetZT^LIBm("CONERR^LIBcommu")
 u Socket w % w *-3
 q 1
 
 ;Osetreni chyby pro spojeni, cteni i zapis
CONERR
 n i
 s i=$ze
 s $zt=""
 d log("Error: "_i)
 i $ze["NOTOPEN" s HALT=1
 q 0
.
 ;Disconnect
DISCON
 d log("Disconnect "_Socket)
 i Socket'="" c Socket s Socket=""
 q
.
 ;Logs
log(mess)
 ;For looging comment
 q
 n i
 s i=$zp(^log(""))+1
 s ^log(i)=mess
 q
 

LIBcommx^INT^1^65080,55782.551828^0
LIBcommx
 ;Communication-messaging, message-daemon
 ;Copyright Slavek Zmek, 2005
 
 q
 
 ;Starting point
start
 s user=$g(^XMAloc("X","USER"))
 d SetLic^LIBm(user)
 s ^XMAloc("X","job")=$j
 
 ;Basic loop
loop
 s $zt=$$SetZT^LIBm("err^LIBcommx")
 s sAdr=$g(^XMA("P","ADR"))
 i sAdr="" d W^LIBerr("Not defined logical address !","X-D") q
 
 f  q:^XMAloc("X","job")'=$j  d
 .s xActionCont=0
 .s Sou=""
 .f  s Sou=$o(^XMD("*",Sou)) q:Sou=""  d
 ..s msgC=0
 ..f  s Pri=$o(^XMD("*",Sou,"")) q:Pri=""  d  i msgC>50 s xActionCont=1 q
 ...s msgC=msgC+$e(Pri)
 ...d One
 .l
 .i '$g(xActionCont) h 0.3
 .;Midnight -> general clean-up
 .q:+$h=$g(^XMA("P","X-N"))
 .d RemXMP
 .s ^XMA("P","X-N")=+$h
 
 q
 
 ;Error
err
 s $zt=""
 k
 s $zt=$$SetZT^LIBm("start^LIBcommx")
 d WE^LIBerr("X-daemon","X-D")
 g loop
 
 ;Stop
stop
 s ^XMAloc("X","job")=0
 q
 
 ;One message
One
 n Dest
 l +^XMD("*",Sou,Pri)
 s $zt=$$SetZT^LIBm("err1^LIBcommx")
 s mIdx=^XMD("*",Sou,Pri)
 s mHea=^XMP(mIdx,0)
 i $g(^XMA("JOU")),$$CheckJ d Jou(mIdx)
 s mOde=$p(mHea,"#",6)
 i mOde="" s mErr="Sender not defined !" g err1
 s mTyp=+mHea
 s mAdr=$p(mHea,"#",2)
 s mKey=$p(mHea,"#",3)
 
 ; Analyzing field "To", spread to (maybe) more addres
 s (ref,Err)=0
 f i=1:1:$l(mAdr,",") s Ad=$p(mAdr,",",i) i Ad'="" d  q:Err
 .i $f(Ad,"|") d
 ..i $p(Ad,"|")=sAdr s Ad=$p(Ad,"|",2,1000) q
 ..s ref=1
 .s Ad1=$p(Ad,"|"),SADR=mOde
 .i '$d(^XMA("L",Ad1)) s mErr="'To' does not defined ! :"_Ad,Err=1 q
 .i '$d(^XMA("L",Ad1,SADR)) s SADR="*"
 .s dAdr=""
 .f  s dAdr=$o(^XMA("L",Ad1,SADR,dAdr)) q:dAdr=""  d  q:Err
 ..i $d(^XMA("L",Ad1,SADR,dAdr))<10 s Dest(dAdr)="" q
 ..i $d(^XMA("L",Ad1,SADR,dAdr,mKey)) s Dest(dAdr)=""
 
 i Err g err1
 
 s dAdr="",i=0
 f  s dAdr=$o(Dest(dAdr)) q:dAdr=""  s i=i+1
 
 s ^XMP(mIdx)=i
 i ref d
 .i $p(mOde,"|")=sAdr q
 .s $p(mHea,"#",6)=sAdr_"|"_mOde,mOde=$p(mHea,"#",6)
 .s ^XMP(mIdx,0)=mHea
 
 ;  Spread message
 s dAdr="" f  s dAdr=$o(Dest(dAdr))  q:dAdr=""  d DoXMD^LIBcomm(dAdr,sAdr,$e(Pri),mIdx)
 k ^XMD("*",Sou,Pri)
 l -^XMD("*",Sou,Pri)
 q
 
 ;Any problems -> move meassage to "Undeliverable pool"
err1
 s $zt=""
 i $g(mErr)="" s mErr=$zerror
 d DoXME
 d RemXMD^LIBcomm("*",Sou,Pri)
 l -^XMD("*",Sou,Pri)
 d W^LIBerr(mErr,"X-D")
 s mErr=""
 q
 
 ;Accept message
Accept(%1,%2,%3)
 n mIdx,mHea,mKey,mRou,xID,mPoc,i,mErr,xERROR,mNSP
.
 s mIdx=^XMD(%1,%2,%3)
 i '$d(^XMP(mIdx)) d  q
 .k ^XMD(%1,%2,%3)
 .d W^LIBerr("Remove link to non-existing message ! :"_mIdx_"  ("_%1_","_%2_","_%3_")","X-D")
 
 s $zt=$$SetZT^LIBm("err2^LIBcommx")
 s mHea=$g(^XMP(mIdx,0))
 i mHea="" d W^LIBerr("Message without header ! :"_mIdx,"X-D") g err2
 s i=$g(^XMA("NSP",%1))
 i i'="" d
 .s mNSP=$$GetNSP^LIBm()
 .d SetNSP^LIBm(i)
 s mTyp=+mHea
 s mKey=$p(mHea,"#",3)
 s mRou=$p(mKey,"$")
 ;Change destination's routine
 i $d(^XDE(mRou)) s mRou=$g(^XDE(mRou))
 e  i $d(^XDE("*")) s mRou=$g(^XDE("*"))
 i mRou="" s mRou=mKey
 f xID=1:1:$l(mRou,"$") s i=$p(mRou,"$",xID) i i'="" d Run(i,mIdx)
 i $g(xERROR) g err2
 
 d RemXMD^LIBcomm(%1,%2,%3)
 q
 
 ;Run destination routine
Run(%,%1)
 n (%,%1,xERROR)
 d @("^"_%_"("_%1_")")
 l
 q
.
 ;Some problem... move to undeliveralble
err2
 s $zt=""
 i $g(mErr)="" s mErr=$zerror
 d DoXME
 d RemXMD^LIBcomm(%1,%2,%3)
 l
 d W^LIBerr(mErr,"X-D")
 s mErr=""
 i $g(mNSP)'="" d SetNSP^LIBm(mNSP)
 q 
 
 ;Move message to "Undeliverable pool"
DoXME
 n i,j
 s i=$h,j=""
 s i=+i*100000+$p(i,",",2)
 f  d  q:j'=""  s i=i+.001
 .l +^XME(i):0 e  q
 .i $d(^XME(i)) l -^XME(i) q
 .s j=i
 m ^XME(j)=^XMP(mIdx)
 l -^XME(j)
 q
 
 ;Fill ^XMD with indexes of messages (^XMP)
FillXMD
 n i,j,k
 s i=""
 f  s i=$o(^XMP(i)) q:i=""  d
 .s j=$p(^XMP(i,0),"#",6)
 .s k=$zp(^XMD("*",j,""))+1
 .s ^XMD("*",j,k)=i
 
 q
 
 ;Remove messages (XMP) with non-existing reference (XMD)
RemXMP
 n i,j,k
 l +^XMP,+^XMD
 ;Temporary list of messages
 k ^Zxmp($j)
 s i="" f  s i=$o(^XMD(i)) q:i=""  d
 .s j="" f  s j=$o(^XMD(i,j)) q:j=""  d
 ..s k="" f  s k=$o(^XMD(i,j,k)) q:k=""  d
 ...s ^Zxmp($j,^XMD(i,j,k))=""
 ;Removing...
 s i=""
 f  s i=$o(^XMP(i)) q:i=""  i '$d(^Zxmp($j,i)) k ^XMP(i)
 k ^Zxmp($j)
 l
 q
.
 ;Check, if journaling is active and some rule is fullfiled
CheckJ()
 n i,j,Typ,Adr,Rou
 s i="",Ok=0
 f  s i=$o(^XMA("JOU",i)) q:i=""  d  q:Ok
 .s j=^XMA("JOU",i)
 .s Typ=$p(j,"|"),Adr=$p(j,"|",2),Rou=$p(j,"|",3)
 .i Typ="*",Rou="" d  q
 ..i Adr="" s Ok=1 q
 ..i Adr=$p(mHea,"#",2) s Ok=1 q
 ..i Adr=$p(mHea,"#",6) s Ok=1 q
 .i Typ=1,$p(mHea,"#",2)'=Adr q
 .i Typ=2,$p(mHea,"#",6)'=Adr q
 .i Rou'="",$p(mHea,"#",3)'=Rou q
 .s Ok=1
 q Ok
  
 ;Journal
Jou(ID)
 n IDJ,Ok
 s IDJ=$p($h,",")*100000+$p($h,",",2),Ok=0
 f  d  q:Ok  s IDJ=IDJ+.001
 .l +^XMJ(IDJ):1  e  q
 .i $d(^XMJ(IDJ)) l -^XMJ(IDJ) q
 .s Ok=1
 
 m ^XMJ(IDJ)=^XMP(ID)
 l -^XMJ(IDJ)
 q
.

LIBdatop^INT^1^65288,42691.27188^0
LIBdatop
 ;Operations with data - linearization, file, ...
 ;Copyright Slavek Zmek, 2016
 
 ;Linearization ( tree data -> linear data )
TtL(sou,dest,nokill,trans)
 n Idx,IdF,k,j
 i '$g(nokill) k @dest
 s Idx=+$zp(@dest@(""))
 s trans=$g(trans)
 i trans'="" s trans="k=$$"_trans_"(k)"
 ;Head -  data on node, sublevel, source
 s j=$d(@sou)
 d wri((j#2)_(j>9)_"|"_sou)
 s IdF=Idx
 i j#2 s k=@sou s:trans'="" @trans d wri(k)
 i j>9 d TtL1(sou)
 d wri("@")
 ;Overwrite Head with "Last index"
 s @dest@(IdF)=(j#2)_(j>9)_Idx_"|"_sou
 q
.
TtL1(Gb)
 n i,j,k,l
 s i=""
 f  s i=$o(@Gb@(i)) q:i=""  d
 .s l=$na(@Gb@(i))
 .s j=$d(@l)
 .d wri((j#2)_(j>9)_i)
 .i j#2 s k=@l s:trans'="" @trans d wri(k)
 .i j>9 d TtL1(l)
 d wri("@")
 q
 
 ;Writing data
wri(%)
 s Idx=Idx+1,@dest@(Idx)=%
 q
 
 ;Delinearizaton ( linear data -> tree data )
LtT(sou,dest,start,trans,end)
 n Idx,i,j,k,Fin
 s Idx=$g(start)
 s end=$g(end),Fin=0
 i Idx="" s Idx=$o(@sou@(""))
 s i=@sou@(Idx)
 s dest=$g(dest)
 i dest="" s j=$f(i,"|"),dest=$e(i,j,$l(i)+1)
 k @dest
 s trans=$g(trans)
 i trans'="" s trans="k=$$"_trans_"(k)"
 i $e(i)'="0" s Idx=$o(@sou@(Idx)),k=@sou@(Idx) s:trans'="" @trans s @dest=k
 i $e(i,2)'="0" d LtT1(dest)
 q
.
LtT1(Gb)
 n i,k,sub
 f  s Idx=$o(@sou@(Idx)),i=@sou@(Idx) q:i="@"  d  q:Fin
 .i end'="",Idx=end s Fin=1 q
 .s sub=$e(i,3,$l(i))
 .i $e(i)'="0" s Idx=$o(@sou@(Idx)),k=@sou@(Idx) s:trans'="" @trans s @Gb@(sub)=k
 .i $e(i,2)'="0" d LtT1($na(@Gb@(sub)))
 q
 
 ;Linear data to file
LtF(sou,file,kill,lf,trans,start,end,mode)
 n i,k,sub
 s $zt=$$SetZT^LIBm("ERRS^LIBdatop")
 s trans=$g(trans)
 i trans'="" s trans="k=$$"_trans_"(k)"
 s lf=$g(lf)
 s mode=$g(mode)
 i mode="" s mode="W"
 s i=$$ofile^LIBm(file,mode)
 i i="" q 1
 u i
 s end=$g(end)
 i end="" s end=$zp(@sou@(""))
 s sub=$g(start)
 i sub'="" s sub=$zp(@sou@(sub))
 f  s sub=$o(@sou@(sub)) q:sub=""  q:sub>end  d
 .s k=$g(@sou@(sub))
 .i trans'="" s @trans
 .w k
 .i lf w !
 c i
 i $g(kill) k @sou
 q 0
.
 ;Linear data to file, two levels
L2tF(sou,file,kill,lf,ff,trans)
 n i,j,k,l,m
 s $zt=$$SetZT^LIBm("ERRS^LIBdatop")
 s trans=$g(trans)
 i trans'="" s trans="k=$$"_trans_"(sou,j,l)"
 s i=$$ofile^LIBm(file,"W")
 i i="" q 1
 u i
 s j="",m=0
 f  s j=$o(@sou@(j)) q:j=""  d
 .i $g(ff),m w # s m=1
 .s l=""
 .f  s l=$o(@sou@(j,l)) q:j=""  d
 ..i trans'="" s @trans
 ..i trans="" s k=$g(@sou@(j,l))
 ..w k
 ..i lf w !
 c i
 i $g(kill) k @sou
 q 0
 
 ;File to linear data
FtL(file,dest,nokill,len,trans,mode)
 n i,j,txt
 s $zt=$$SetZT^LIBm("ERRS^LIBdatop")
 i '$$tfile^LIBm(file) q 1
 s trans=$g(trans)
 i trans'="" s trans="txt=$$"_trans_"(txt)"
 s mode=$g(mode)
 i mode="" d
 .i '$g(len) s mode="R"
 .i $g(len) s mode="RUK\RAW\"
 s i=$$ofile^LIBm(file,mode)
 i i="" q 1
 u i
 i '$g(nokill) k @dest
 s j=$zp(@dest@(""))
 s $zt=$$SetZT^LIBm("ERRL^LIBdatop")
 f  d  s j=j+1,@dest@(j)=txt
 .i '$g(len) r txt
 .i $g(len) r txt#len
 .i trans'="" s @trans
 c i
 q 0
 
 ;Error while file writing/reading
ERRS
 s $zt=""
 i $g(i)'="" c i
 q 2
 
 ;Error while reading - no error, end of file...
ERRL
 c i
 q 0
 
 ;Size of linear data
LiSi(sou)
 n i,j
 s i="",j=0
 f  s i=$o(@sou@(i)) q:i=""  s j=j+$l($g(@sou@(i)))
 q j
 
 ;Compare to linearized data, 0 - Ok, else - index of difference
CompL(sou,dest)
 n i,j,Ok
 s i="",Ok=0
 f  s i=$o(@sou@(i)) q:i=""  d  q:Ok
 q Ok 
.
 ;Compact linearized data - merge more nodes to one, optionally add CRLF. 
CompactL(sou,dest,crlf,limit)
 n i,j,k,GbT
 i sou=dest s GbT=$na(^Zcmpt($j)) m @GbT=@sou
 k @dest
 i $g(GbT)'="" s sou=GbT
 s limit=+$g(limit)
 i 'limit s limit=2000
 s crlf=$g(crlf)
 s (i,j)="",k=0
 f  s i=$o(@sou@(i)) q:i=""  d
 .s j=j_@sou@(i)
 .i crlf s j=j_$c(13,10)
 .i $l(j)>limit s k=k+1,@dest@(k)=$e(j,1,limit),j=$e(j,limit+1,$l(j))
 i j'="" s k=k+1,@dest@(k)=j
 i $g(GbT)'="" k @GbT
 q
 
 ;Create OK file
FOK(file)
 n i
 s $zt=$$SetZT^LIBm("ERRS^LIBdatop")
 s i=$$ofile^LIBm(file,"W")
 i i="" q 1
 u i
 w "OK",!
 c i
 q 0
  
 ;******* Operation with CSV **********************
 ; Split line in CSV-format(%) into fields(%1)
 ; Variable %1 is nessesary to call as reference (dot syntax) !!!
 ; Optional parameter separator (%2), default ","
SpCSV(%,%1,%2)
 n i,j,p,b
 k %1
 i $g(%2)="" s %2=","
 s (b,p,i)=0
 f  s i=i+1 q:i>$l(%)  d
 .i 'b d  q
 ..i $e(%,i)="""" s j="",b=1 q
 ..i $e(%,i)=%2 s p=p+1,%1(p)="",%1(p,1)=2 q
 ..s j=$e(%,i),b=2
 .i b=1 d  q
 ..i $e(%,i)'="""" s j=j_$e(%,i) q
 ..i $e(%,i+1)="""" s j=j_$e(%,i),i=i+1 q
 ..s p=p+1,%1(p)=j,%1(p,1)=b,b=0
 ..s i=i+1
 .i b=2 d
 ..i $e(%,i)'=%2 s j=j_$e(%,i) q
 ..s p=p+1,%1(p)=j,%1(p,1)=b,b=0
 
 ;Rest..
 i b s p=p+1,%1(p)=j,%1(p,1)=b
 q 
  
 ; CSV -> Tree
CSVtT(sou,dest,nokill,start,delim,struc,idxmode)
 n i,j,Data,Str,Idx
 i '$g(nokill) k @dest
 s struc=$g(struc)
 s idxmode=$g(idxmode)
 s i="",Idx=0
 i $g(start)'="" s i=$zp(@sou@(start))
 f  s i=$o(@sou@(i)) q:i=""  d
 .d SpCSV(@sou@(i),.Data,$g(delim))
 .i idxmode="" s Idx=Idx+1
 .i idxmode'="" s Idx=Data(idxmode)
 .i struc="" d  q
 ..s j=""
 ..f  s j=$o(Data(j)) q:j=""  s @dest@(Idx,j)=Data(j)
 .;According to structure
 .s j=""
 .f  s j=$o(@struc@(j)) q:j=""  s @dest@(Idx,@struc@(j))=Data(j)
 q
   
 ;******* Operations with Cache's listbuilds *******
 ;Change data format ListBuild->Structure
LBtoSTRUC(sou,dest,nokill,desc)
 n ID,i,j,k
 i '$g(nokill) k @dest
 s ID=""
 f  s ID=$o(@sou@(ID)) q:ID=""  d LBtoSTRUC1(@sou@(ID),$na(@dest@(ID)),$g(desc))
 q
 
LBtoSTRUC1(value,dest,desc)
 n i,j,k,Ref
 ;Cela struktura
 i $g(desc)="" d  q
 .i value="" q
 .f i=1:1:$ll(value) s j=$lg(value,i) i j'="" d
 ..s Ref=$na(@dest@("Col"_i))
 ..i '$listvalid(j) s @Ref=j q
 ..d LBtoSTRUC1(j,Ref)
 ;Data podle popisu
 s i=""
 f  s i=$o(@desc@(i)) q:i=""  d
 .s k=$g(@desc@(i))
 .i k="" s k="Col"_i
 .s j=$lg(value,i)
 .s Ref=$na(@dest@(k))
 .i $d(@desc@(i))<10 s @Ref=j q
 .d LBtoSTRUC1(j,Ref,$na(@desc@(i)))
 q  
.
 ;Change data format Structure->ListBuild
STRUCtoLB(sou,dest)
 q
 
 ;Transformation of data - linear structure
TRANSFORM(sou,dest,rules)
 n i,j,field,field2
 f i=1:1:$l(rules,",") s j=$p(rules,",",i) i j'="" d
 .s field=$p(j,":"),field2=$p(j,":",2)
 .i (field="")!(field2="") q
 .i field2="*" s field2=field
 .s @dest@(field2)=$g(@sou@(field))
 q
 
 ;Compare content of two trees.
 ; Parameters:  Reference to first tree (as string), reference to second tree(as string), reference to result (as string)
 ; Returns:  number of differences, or -1 (bad input)
 ; Differences: <Code>|<Reference in first tree>|<Value in first tree>|<Reference in second tree>|<Value in second tree>|<Optional - subscript>
 ;               Codes: 1  - Data difference in both
 ;                      2  - Data in first tree, second has not
 ;                      3  - Data in second tree, first has not
 ;                      4  - Reference exists in first tree, but not in second 
 ;                      5  - Reference exists in second tree, but not in first
 ;                      6  - Reference is tree in first, but not in second 
 ;                      7  - Reference is tree in second, but not in first
TreeCmp(%,%1,%2)
 n Count,g1,g2,X,X2
 i %="" q -1
 i %1="" q -1
 i %2="" q -1
 i %=%1 q 0
 k @%2
 s Count=0,g1=%,g2=%1
 s X=$d(@g1),X2=$d(@g2)
 i X#10=0,X2#10=0 g Cont
 i X#10,X2#10 d:(@g1'=@g2) DiffData g Cont
 i X#10 d DiffSet("2|"_g1_"|"_@g1_"|"_g2_"|") g Cont
 i X2#10 d DiffSet("3|"_g1_"||"_g2_"|"_@g2)
Cont
 i (X+X2)>10 d ChckLevel(g1,g2)
 q Count
.
ChckLevel(gl1,gl2)
 n i,j,X,X2,glo1,glo2
 s i=$o(@gl1@("")),j=$o(@gl2@(""))
 f  q:(i="")&(j="")  d
 .i i=j d  q
 ..s glo1=$na(@gl1@(i)),glo2=$na(@gl2@(j))
 ..;Test values
 ..s X=$d(@glo1),X2=$d(@glo2)
 ..i (X#10)!(X2#10) d
 ...i X#10,X2#10 d:(@glo1'=@glo2) DiffData q
 ...i X#10 d DiffSet("2|"_glo1_"|"_@glo1_"|"_glo2_"|") q
 ...i X2#10 d DiffSet("3|"_glo1_"||"_glo2_"|"_@glo2)
 ..;Test tree
 ..i (X+X2)>10 d
 ...i X+X2>19 d ChckLevel(glo1,glo2) q
 ...i X>9 d DiffAct(6) q
 ...d DiffAct(7)
 ..s i=$o(@gl1@(i)),j=$o(@gl2@(j))
 .i i="" d DiffMore(5,j) s j=$o(@gl2@(j)) q
 .i j="" d DiffMore(4,i) s i=$o(@gl1@(i)) q
 .i $$CHK(i,j)=1 d DiffMore(5,j) s j=$o(@gl2@(j)) q
 .d DiffMore(4,i) s i=$o(@gl1@(i)) q
 
 q
.
 ;Check suffixes - collation order 
CHK(G1,G2)
 n test,ref
 s test(G1)=1,test(G2)=2
 s ref=$q(test(""))
 q @ref
 
 ;Differences.....
DiffMore(%,%1) d DiffSet(%_"|"_gl1_"||"_gl2_"||"_%1) q
DiffData d DiffSet("1|"_glo1_"|"_@glo1_"|"_glo2_"|"_@glo2) q
DiffAct(%) d DiffSet(%_"|"_glo1_"||"_glo2_"|") q
DiffSet(%) s Count=Count+1,@%2@(Count)=% q
 

LIBdbx^INT^1^64971,48961.929498^0
LIBdbx
 ;Database access (as fields)
 ;Copyright Slavek Zmek, 2010
 
 ;Returned values / error codes:
 ;  0 - OK
 ;  1 - Bad description of field's list
 ;  2 - Bad data reference
 ;  3 - Load empty data without lock
 ;  4 - Data locked
 
 ;Structure of objects and field's description (e.g. ^XDES)
 ;    1.level - abbreviation, name (in value)
 ;    2.level - fields. Subscript is abbreviation, value:
 ;                <type>$<name>$<flag-storage in local variable>$<editing-type of component>$<editing-order>
 ;    3.level - additional properties:
 ;                  init - initial value for new record               
 ; Fields: type -  0 - normal value, scalar
 ;                98 - normal value, stored at sublevel (backward compatibility with some IS)
 ;                99 - tree
 
 ;Empty record initialization - fill fields
Init(R)
 n fd,fl,fi,type
 i '$g(R("DES"))="" q 1
 s fd=R("DES")
 i $e(fd)'="^" s fd=$na(^XDES(fd))
 i '$d(@fd) q 1
 s fl=$g(R("FL"))
 i fl="" s R("FL")="FL",fl="FL"
 s fi=""
 f  s fi=$o(@fd@(fi)) q:fi=""  d
 .s type=+@fd@(fi)
 .i type=98 s @fl@(fi)=1,@fl@(fi,1)="" q
 .i type=99 s:$p(@fd@(fi),"$",3) R("LOC",fi)="" s @fl@(fi)=$$GetT() q
 .s @fl@(fi)=$g(@fd@(fi,"init"))
 q 0
.
 ;Empty record initialization - fill fields of variable
InitX(Des,Dest)
 n Err,X
 s X("DES")=Des
 s X("FL")=Dest
 s Err=$$Init(.X)
 q Err
 
 ;Load record
Load(R,X)
 n fd,fl,fi,type,data,i
 i $g(R("DES"))="" q 1
 s data=$g(R("DATA"))
 i data="" q 2
 s fd=R("DES")
 i $e(fd)'="^" s fd=$na(^XDES(fd))
 i '$d(@fd) q 1
 i $g(R("IDX"))'="" d
 .i data["(" s data=$e(data,1,$l(data)-1)_","
 .e  s data=data_"("
 .s data=data_R("IDX")_")"
 ;Load data without lock
 s R("LK")=+$g(R("LK"))
 i '$d(@data),'R("LK") q 3
 i R("LK") i $$Lock^LIBlck(data) q 4
 ;Lock only, not load data into fields
 q:R("LK")=2 0
 ;Field's list
 s fl=$g(R("FL"))
 i fl="" s R("FL")="FL",fl="FL"
 i $g(R("SUB"))'="" d
 .i data["(" s data=$e(data,1,$l(data)-1)_","
 .e  s data=data_"("
 .s data=data_R("SUB")_")"
 k @R("FL")
 i $p(@fd,"$",2)=1 s @fl=$g(@data)
 s fi=""
 f  s fi=$o(@fd@(fi)) q:fi=""  d
 .i $d(X),'$d(X(fi)) q
 .s type=+@fd@(fi)
 .i type=98 d  q
 ..i $d(@data@(fi)) m @fl@(fi)=@data@(fi) q
 ..s @fl@(fi)=1,@fl@(fi,1)=""
 .i type=99 s:$p(@fd@(fi),"$",3) R("LOC",fi)="" s i=$$GetT() s @fl@(fi)=i m @i=@data@(fi) q
 .s @fl@(fi)=$g(@data@(fi))
 
 q 0
 
 ;Save record
Save(R,X)
 n fl,fd,fi,type,data,data2,i
 s data=$g(R("DATA"))
 i data="" q 5
 i $g(R("IDX"))'="" d
 .i data["(" s data=$e(data,1,$l(data)-1)_","
 .e  s data=data_"("
 .s data=data_R("IDX")_")"
 ;Unlock only
 i $g(R("LK"))=-1 l -@data q 0
 s fd=R("DES")
 i $e(fd)'="^" s fd=$na(^XDES(fd))
 s fl=$g(R("FL"))
 s data2=data
 i $g(R("SUB"))'="" d
 .i data2["(" s data2=$e(data2,1,$l(data2)-1)_","
 .e  s data2=data2_"("
 .s data2=data2_R("SUB")_")"
 i $p(@fd,"$",2)=1 s @data2=$g(@fl)
 s fi=""
 f  s fi=$o(@fd@(fi)) q:fi=""  d
 .i $d(X),'$d(X(fi)) q
 .k @data2@(fi)
 .s i=@fl@(fi)
 .i i="" q
 .s type=+@fd@(fi)
 .i type=98 d  q
 ..i i=1,$g(@fl@(fi,1))="" q
 ..m @data2@(fi)=@fl@(fi)
 .i type=99 m @data2@(fi)=@i q
 .s @data2@(fi)=i
 
 l -@data
 q 0
 
 ;Delete record
Del(R)
 n data
 s data=$g(R("DATA"))
 i data["(" s data=$e(data,1,$l(data)-1)_","
 e  s data=data_"("
 s data=data_R("IDX")_")"
 i $$Lock^LIBlck(data) q 4
 k @(data)
 l -@(data)
 q 0
 
 ;Release allocated space/globals
Release(R)
 n fl,fd,fi,type,data,i
 s data=$g(R("DATA"))
 i data'="" d
 .i $g(R("IDX"))'="" d
 ..i data["(" s data=$e(data,1,$l(data)-1)_","
 ..e  s data=data_"("
 ..s data=data_R("IDX")_")"
 ..l -@data
 s fl=$g(R("FL"))
 i fl'="" d
 .s fd=R("DES")
 .i $e(fd)'="^" s fd=$na(^XDES(fd))
 .s fi=""
 .f  s fi=$o(@fd@(fi)) q:fi=""  d
 ..s type=+@fd@(fi)
 ..i type=99 s i=$g(@fl@(fi)) i i'="" k @i
 .k @fl
 k R
 q
.
 ;Temporary global for big data
GetT()
 n Idx
 i '$d(R("LOC",fi)) d
 .s Idx=$g(^Zxiz($j))+1
 .s ^Zxiz($j)=Idx
 .s Idx=$na(^Zxiz($j,Idx))
 e  s Idx=$na(@fl@(fi))
 
 k @Idx
 q Idx
.
 ;General release of temporary global
GenRelease
 k ^Zxiz($j)
 q
 
 ;Write error message
Err(X,Prg)
 n i
 s i="ERC="_$g(ERC)_" DATA="_$g(X("DATA"))_" DES="_$g(X("DES"))_" IDX="_$g(X("IDX"))
 d W^LIBerr(i,$g(Prg))
 q
.
 ;Load metadata to record
LoadMeta(%DATA,%META)
 n i
 s i=""
 f  s i=$o(^XMETA(%META,i)) q:i=""  d
 .i '$d(@%DATA@(i)) s @%DATA@(i)=""
 q
  
 ;Save (remove empty metadata) from record
SaveMeta(%DATA,%META)
 n i
 s i=""
 f  s i=$o(@%DATA@(i)) q:i=""  d
 .i $g(@%DATA@(i))="" k @%DATA@(i)
 q
  
 ;Load descriptors from file. Location: ^XDES or non-obligatory parameter
XLoad(File,What,Loc)
 n Dest,Sub,i,j
 s Dest=$na(^Zdese($j))
 i $$FtL^LIBdatop(File,Dest) w "Error while loading descriptor" q
 s What=$g(What)
 s Loc=$g(Loc)
 i Loc="" s Loc="^XDES"
 i What'="" s What=","_What_","
 s Sub=""
 f  s Sub=$o(@Dest@(Sub)) q:Sub=""  d
 .s i=@Dest@(Sub)
 .i $e(i)'="@" q
 .i i="@" q
 .i What'="",(","_Sub_",")[What q
 .d XLoad1
 k @Dest
 q
XLoad1
 s j=$p($e(i,2,$l(i)),"|")
 k @Loc@(j)
 s @Loc@(j)=$p(i,"|",2)
 f  s Sub=$o(@Dest@(Sub)) q:Sub=""  s i=@Dest@(Sub) q:i="@"  s @Loc@(j,$p(i,"|"))=$p(i,"|",2)
 q
 ;Save descriptors to file. Location: ^XDES or non-obligatory parameter
XSave(File,What,Loc)
 n Dest,Cou,Sub,Loo
 s Dest=$na(^Zdese($j))
 s What=$g(What)
 s Loc=$g(Loc)
 i Loc="" s Loc="^XDES"
 k @Dest
 s Cou=0
 i What="" d
 .s Sub=""
 .f  s Sub=$o(@Loc@(Sub)) q:Sub=""  d XSave1(Sub)
 i What'="" d
 .f Loo=1:1:$l(What,",") s Sub=$p(What,",",Loo) i Sub'="" d XSave1(Sub)
 d LtF^LIBdatop(Dest,File,1,1)
 q
XSave1(%)
 n i
 s Cou=Cou+1,@Dest@(Cou)="@"_%_"|"_@Loc@(%)
 s i=""
 f  s i=$o(@Loc@(%,i)) q:i=""  s Cou=Cou+1,@Dest@(Cou)=i_"|"_@Loc@(%,i)
 s Cou=Cou+1,@Dest@(Cou)="@"
 q

LIBerr^INT^1^64134,59135^0
LIBerr
 ;Error's management
 ;Copyright Slavek Zmek, 2005
 
 ;Write error's text
 ;Parameters: %1 - text of error
 ;            %2 - section
 ;            %3 - category, default 1
 ;         Optional:
 ;            %4 - node or client-specification 
 ;            %5 - user
 ;            %6 - part of code, (name, identification ,...)
W(%1,%2,%3,%4,%5,%6)
 n i,j,k
 q:%1=""
 i $g(%3)="" s %3=1
 l +^ERR(%3)
 ;Make index
 s i=+$h_$e("0000",$l($p($h,",",2)),5)_$p($h,",",2)
 i $d(^ERR(%3,i)) s i=$zp(^ERR(%3,i+1))+0.001
 ;Repeated error -> only count
 s k=$zp(^ERR(%3,i))
 i $e(k,1,5)=+$h,%2=$g(^ERR(%3,k,2)),%1=$g(^ERR(%3,k,1)) d  q
 .s ^ERR(%3,k)=$s($g(^ERR(%3,k)):^ERR(%3,k)+1,1:2)
 .l -^ERR(%3)
 
 ;Write
 s ^ERR(%3,i,1)=%1
 s ^ERR(%3,i,2)=%2
 i $g(%4)'="" s ^ERR(%3,i,3)=%4
 i $g(%5)'="" s ^ERR(%3,i,4)=%5
 i $g(%6)'="" s ^ERR(%3,i,5)=%5
 l -^ERR(%3)
 q
 
 ;Write error in $zerror
WE(%1,%2)
 n i
 s i=$zerror
 s i=$g(%1)_" "_i
 d W(i,%2)
 q
 
 ;Delete messages
Del(%1)
 k ^ERR(%1)
 q
 

LIBg^INT^1^64426,36975.142044^0
LIBg
 ;Global editor
 ;Copyright Slavek Zmek, 2011
 
 n
 ;Terminal mode
 u 0:(80:"IS")
 s $zt="Err^LIBg"
 d CON(0)
 s Gb="^UTILITY(""GLO"")"
 ;Colors C1 - basic, C2 - focused subscript, C3 - unfocused subscript, C4 - data
 s C1="7,1",C2="1,5",C3="5,1",C4="6,1"
 d List
 d Win
 s Lev=0
 s Edit=0
K0
 k Pos 
 s Pos(-1)=4
 d Tree(0)
 ;Input from keyboard
K1
 d Tree(Lev)
 s v=Lev(Lev)
 s G=$$RefL(Lev)
 s x=$$Write(23,2,G,C1,78,1)
 s x=$$GetC()
 d CUP(3,3) w x,"------"
 i x?1.N d  g K1
 .i Lev=0,'Edit,x>47,x<58 q
 .s:'Edit Lev(Lev)="" s Lev(Lev)=Lev(Lev)_$c(x),Edit=1
 s Edit=0
 i x="Hom" s Lev(Lev)="",x="CRg" k ^A 
 i x="End" s Lev(Lev)="",x="CLf" k ^A 
 i x="CLf" s G=$$Ref(Lev),S=$$Prev(G) i S'="" s Lev(Lev)=S g K1
 i x="CRg" s G=$$Ref(Lev),S=$$Order(G) i S'="" s Lev(Lev)=S g K1
 i x="CDn",v'="" d:v'=Lev(Lev)  s Lev=Lev+1 g K1
 .s Lev(Lev)=v d Tree(Lev)
 i x="CUp",Lev>0 s Lev=Lev-1 g K1
 i x="Ent" d EditV g K1
 ;i x="F1" g K0
 i x="F3",Lev d EditS(0) g K1
 i x="F4",Lev d EditS(1) g K1
 i x="F5",Lev d ListL g K0
 i x="F7" d  g K0
 .i $$YesNo("Delete whole subtree?") s G=$$Ref(Lev) k @G
 i x'="Esc" g K1
End
 d CON(1) 
 u 0:(80:"")
 d COLOR(0,7)
 d ED
 q
.
Err
 w $zerror
 q
  
 ;Input char
GetC()
 n x,y,z
 r *x
 s y=$a($k)
 ;Escape-sequence
 i y=27 d  q z
 .r *x:0
 .i x=-1 s z="Esc" q
 .s z="" f  r *y:0 q:y=-1  s z=z_$s(z'="":",",1:"")_y
 .;Arrows...
 .i x=91 s z=$s(z="49,126":"Hom",z="52,126":"End",z="51,126":"Del",z=68:"CLf",z=67:"CRg",z=66:"CDn",z=65:"CUp",z="53,126":"PgUp",z="54,126":"PgDn",z="49,55,126":"F6",z="49,56,126":"F7",1:"??k"_z) q
 .;F-keys
 .i x=79 s z=$s(z=80:"F1",z=81:"F2",z=82:"F3",z=83:"F4",z=84:"F5",1:"??f"_z) q
 .s z=x_","_z
 i y>31,y<127 q y
 ;Control characters
 i x=8 q "Bsp"
 i x=13 q "Ent"
 q x
  
 ;Paint window
Win
 n Li,i
 s Li="",$p(Li,"-",78)="-"
 ;Set color
 d COLOR(7,1)
 ;Erase display - doesn't function with color...
 d ED
 ;Frame, header,...
 f i=1,3,22,24 d CUP(i,1) w "+",Li,"+"
 f i=2,4:1:21,23 d CUP(i,1) w "|" d CUP(i,80) w "|"
 d CUP(2,3) w "$j=",$j d CUP(2,30) w "Global editor" d CUP(2,70) w "<",$znspace,">"
 q
 
 ;Paint data-tree
Tree(%,%1)
 n i,x,y,d,p,n,s,g,f,o,a
 s %1=$g(%1)
T0
 ;Starting reference
 s Lev(%)=$g(Lev(%))
 s:%'<%1 Lev(%+1)="" s g=$$Ref(%),f=$g(Pos(%-1))
 i $g(Lev(%))="" s Lev(%)=$$Order(g) s:%=0 g=$$Ref(%)
 s d=$$Data(g),o=$s(d#2=0:"",1:@g)
 ;Right, left, ...
 s p=$$Prev(g),n=$$Order(g)
 i %>0 d
 .s a="",s=" ...-----+---------------------------+---------------------------+----...   "
 .i p="" s $e(s,1,37)=$j("",37)
 .i n="" s $e(s,39,76)=$j("",37)
 .i p=n s $e(s,38)="|"
 .i p'="",$zp(^(p))="" s $e(s,1,9)=$j("",9)
 .i n'="",$o(^(n))="" s $e(s,67,76)=$j("",9)
 i %=0 s s="",a="^"
 i Lev(%)="",%>0 s Pos(%,1)=f g T1
 ;Write level's data
 i %>0 s f=f+$$Write(f,40,"|",C1,75)
 s f=f+$$Write(f,2,s,C1)
 s i=$$Write(f,14,a_$e(p,1,20),C1,22)
 s i=$$Write(f,66,a_$e(n,1,20),C1,22)
 s Pos(%,1)=f
 s f=f+$$Write(f,40,a_Lev(%),$s(d=0:C3,%=Lev:C2,1:C1),34)
 i d#2 s f=f+$$Write(f,40,">"_$$KtW^LIBchar(o)_"<",C4,75)
 s v=Lev(%)
T1
 s Pos(%)=f i Lev(%)'="" s %=%+1 g T0
 ;Erase the rest
 f y=f:1:21 s i=$$Write(y,2,"",C1,78,1)
 q
 
 ;Write value, may be centered
Write(x,y,v,c,l,t)
 n i,r,o,s1,s2
 s r=0,l=$g(l)
W0
 s s1="",s2=""
 i l d
 .s i=$l(v)
 .i i<l d
 ..i $g(t)'=2 s s1=$j("",(l-i)\2),s2=$j("",l-i-((l-i)\2)) q
 ..s s2=$j("",l-i)
 .s o=$e(v,1,l),v=$e(v,l+1,$l(v)),i=$s('$g(t):l\2+1,1:0)
 i 'l s o=v,v="",i=0
 d CUP(x+r,y-i)
 w s1
 i $g(c)'="" d COLOR($p(c,","),$p(c,",",2))
 w o
 i $g(c)'="" d COLOR($p(C1,","),$p(C1,",",2))
 w s2
 i v'="" s r=r+1,x=x+1 g W0
 q r+1
 
 ;Order...
Order(%r)
 i $d(%),'$d(Lev(%)) q ""
 q:%r["(" $o(@%r)
 q:%r="^"&($d(^A)) $g(^A)
 i %r="^" q $o(^UTILITY("GLO","A"))
 s %r=$p(%r,"^",2)
 q $o(@Gb@(%r))
 
 ;Prev...
Prev(%r)
 q:%r["(" $zp(@%r)
 s:%r="^" %r="^zzzzzzzzzzzzz"
 s %r=$p(%r,"^",2)
 q $zp(@Gb@(%r))
 
 ;Data...
Data(%r)
 n i,j,k
 q:%r="^" 0
 
 i %r["Lev(" d  q:j="" 0
 .s k="s j=Lev"_"("_$p($p(g,"Lev(",$l(g,"Lev(")),")")_")"
 .x k
 s gx=$p(%r,"(")_$s(%r["Lev(":"(",1:"")
 f i=1:1:$l(%r,"Lev(")-1 d
 .s gx=gx_$s(Lev(i)'=+Lev(i):"""",1:"")_Lev(i)_$s(Lev(i)'=+Lev(i):"""",1:"")_$s(i'=($l(%r,"Lev(")-1):",",1:"")
 s Znaked=gx_$s(%r["Lev(":")",1:"")
 q $d(@%r)
 
 ;Make reference
Ref(%)
 n i,j
 s i="^"_Lev(0)
 i %=0 q i
 s i=i_"("
 f j=1:1:% s i=i_"Lev("_j_"),"
 s i=$e(i,1,$l(i)-1)_")"
 q i
 
 ;Make reference with Lev(*)-fill
RefL(%)
 n i,j
 s i="^"_Lev(0)
 i %=0 q i
 s i=i_"("
 f j=1:1:% d
 .s i=i_$s(Lev(j)'=+Lev(j):"""",1:"")_Lev(j)_$s(Lev(j)'=+Lev(j):"""",1:"")_","
 s i=$e(i,1,$l(i)-1)_")"
 q i
 
 ;List of level
ListL
 n x,i,j,k1,kl,l,m
 d WinS
 s j=$$RefL(Lev-1)
 s k1=$zp(@j@(Lev(Lev)))
L0
 s l=0,i=k1
 f  q:l=16  s i=$o(@j@(i)),kl=i q:i=""  d
 .s l=l+1
 .s m=$$Write(4+l,3,i,C1,25,2)
 .s m=$$Write(4+l,30,$e($g(@j@(i)),1,48),C1,48,2)
 f i=l+1:1:16 s m=$$Write(4+i,3,"",C1,75,2)
 s x=$$GetC()
 i x="Hom" s k1="" g L0
 i x="End" d  g L0
 .s i="",l=0 f  s i=$zp(@j@(i))  q:i=""  s l=l+1 q:l=18  s k1=i
 i x="PgDn",kl'="" s k1=kl g L0
 i x="PgUp",k1'="" d  g L0
 .s i=k1,l=0 f  s i=$zp(@j@(i))  q:i=""  s l=l+1 q:l=18  s k1=i
 i x'="Esc" g L0
 d ClearS
 q
 
 ;Edit value
EditV
 n %r,i
 d CUP(3,12) w "Edit"
 s %r=$$Ref(Lev)
 s i=$$KtW^LIBchar($g(@%r))
 i $$Input(.i,Pos(Lev,1)+1) s @%r=$$WtK^LIBchar(i)
 d CUP(3,12) w "------"
 q
 
 ;Edit subscript
EditS(%)
 n %r,%r1,i
 s %r=$$RefL(Lev)
 s i=Lev(Lev)
 i $$Input(.i,Pos(Lev,1)) s Lev(Lev)=i,%r1=$$RefL(Lev) m @%r1=@%r i '$g(%) k @%r
 q
 
 ;Input value
Input(%1,%2)
 n x,m,p,Edit,i
 s i=%1
 s Edit=0,p=$l(i)
I0
 s m=$$Write(%2,40,i,C1,75)
 s x=$$GetC()
 i x?1.N s:'Edit i="",p=0 s i=$e(i,1,p)_$c(x)_$e(i,p+1,$l(i)),Edit=1,p=p+1 g I0
 s Edit=1
 i x="Hom" s p=0 g I0
 i x="End" s p=$l(i) g I0
 i x="Bsp" s:p i=$e(i,1,p-1)_$e(i,p+1,$l(i)),p=p-1 g I0
 i x="Del" s:p i=$e(i,1,p)_$e(i,p+2,$l(i)),p=p-1 g I0
 i x="CLf" s:p p=p-1 g I0
 i x="CRg" s p=p+1 s:p>$l(i) p=$l(i) g I0
 i x="Ent" s %1=i q 1
 i x="Esc" q 0
 g I0
 
 ;Yes/No
YesNo(%)
 n m,x
 d WinS
 s m=$$Write(10,40,%,C1,70)
 s m=$$Write(12,50,"Press <A/a>",C1,20)
 s x=$$GetC()
 i (x=65)!(x=97) q 1
 q 0
 
 ;Paint sub-window
WinS
 n Li,i
 s Li="",$p(Li,"-",76)="-"
 ;Set color
 d COLOR(7,1)
 d ClearS
 ;Frame, header,...
 f i=4,21 d CUP(i,2) w "+",Li,"+"
 f i=5:1:20 d CUP(i,2) w "|" d CUP(i,79) w "|"
 q
 
 ;Erase subwindow
ClearS
 n i
 f i=4:1:21 d CUP(i,2) w $j("",78)
 q
 
 ;Escape sequences for color
COLOR(%1,%2) ; Set IBM PC Color - foreground %1, background %2
 n %3,%4 s %3=%1#8,%4=%2#8
 s %3=$s(%3=0:30,%3=1:34,%3=2:32,%3=3:36,%3=4:31,%3=5:35,%3=6:33,%3=7:37,1:"")
 s %4=$s(%4=0:40,%4=1:44,%4=2:42,%4=3:46,%4=4:41,%4=5:45,%4=6:43,%4=7:47,1:"")
 w $c(27,91)_$s(%1<9:"0;",1:"")_%3_";"_%4_$s(%1>8:";1",1:"")_"m"
 q
 
 ;Cursor ON/OFF
CON(%)
 w $c(27,91),"?25",$s($g(%):"h",1:"l")
 q
 
CUP(%2,%1) ; Cursor position (column %1, line %2)
 s %1=+$g(%1,1),%2=+$g(%2,1) w $c(27,91)_%2_";"_%1_"H"
 s $zt="ecup",$x=%1-1,$zt="erdy",$y=%2-1 q
ecup s $x=0,$zt="erdy",$y=%2-1
 q
erdx s $x=0 q
erdy s $y=0 q
 
ED
 n i 
 f i=1:1:24 d CUP(i,1) w $j("",80)
 q
 
 ;Global's list
List
 l +^UTILITY("GLO")
 k ^UTILITY("GLO"),^UTILITY("GLO-HIDDEN")
 d ^%GLO
 ;Ensamble has different place, uncomment there...
 m ^UTILITY=^||CacheTempUtil
 k ^UTILITY("GLO",0)
 l -^UTILITY("GLO")
 q

LIBjob^INT^1^64671,50272.81913^0
LIBjob
 ;Jobs agenda
 ;Copyright Slavek Zmek, 2005
 
 ;New job
New(%Type,%Name,%Rou,%Var,%When,%Mode,%VMode)
 n Id,D,T
 i $g(%Rou)="" d W^LIBerr("Not defined routine for task","BG") q
 s %When=$g(%When)
 i %When="" s %When=$h
 s D=$p(%When,","),T=$p(%When,",",2)
 s Id=$$GetUniq^LIButil($na(^XJOB(D,T)))
 s ^XJOB(D,T,Id,"Type")=%Type
 s ^XJOB(D,T,Id,"Name")=%Name
 s ^XJOB(D,T,Id,"Rou")=%Rou
 s ^XJOB(D,T,Id,"Mode")=+$g(%Mode)
 s ^XJOB(D,T,Id,"VMode")=+$g(%VMode)
 i $g(%Var)'="" m ^XJOB(D,T,Id,"Var")=@%Var
 l -^XJOB(D,T,Id)
 q
 
 ;Delete job
Del(%D,%T,%Id)
 n i
 l +^XJOB(%D,%T,%Id):5
 e  q 4
 k ^XJOB(%D,%T,%Id)
 l -^XJOB(%D,%T,%Id)
 q 0 
 
 ;Run job
Run(%D,%T,%Id)
 n (%D,%T,%Id)
 s $zt=$$SetZT^LIBm("RunE^LIBjob")
 l +^XJOB(%D,%T,%Id):5
 e  d W^LIBerr("Not possible to run background job !","BG") q
 s ^XJOB(%D,%T,%Id,"E")=1
 s %V=^XJOB(%D,%T,%Id,"VMode")
 s %P=^XJOB(%D,%T,%Id,"Rou")
 
 i '$f(%P,"^") s %P="^"_%P
 i '%V d LoadVar(%D,%T,%Id)
 i %V d
 .s %Data=$na(^Zca($j))
 .s %P=%P_"("""_%Data_""")"
 .m @%Data@("Var")=^XJOB(%D,%T,%Id,"Var")
 
 d @%P
 
 i %V k @%Data
 k ^XJOB(%D,%T,%Id)
 l -^XJOB(%D,%T,%Id)
 q
 
RunE
 s $zt=""
 d WE^LIBerr("Running task: "_$g(%P),"BG")
 s ^XJOB(%D,%T,%Id,"E")=2
 l -^XJOB(%D,%T,%Id)
 q
.
 ;Returning saved variables - simple or as field
LoadVar(D,T,Id)
 d RetVar($na(^XJOB(D,T,Id)))
 q
 
 ;Returning saved variables from common place - simple or field
RetVar(%)
 n i
 s i=""
 f  s i=$o(@%@("Var",i)) q:i=""  d
 .i $e(i)="@" m @($e(i,2,$l(i)))=@%@("Var",i) q
 .s @i=@%@("Var",i)
 q

LIBjson^INT^1^65337,40633.195896^0
LIBjson
 ;JSON conversion
 ;Copyright Slavek Zmek, 2010
.
 ;********* Simple JSON *******************
 ;
 ;***************************************** 
 
 ;Data to JSON-string
Encode(Gbl)
 n vysl,sub,ref,val
 i '$data(@Gbl) q ""
 s vysl="{",val=0
 s:$d(@Gbl)'=10 vysl=vysl_""""":"_$$ToEx(@Gbl,0),val=1
 s sub="" f  s sub=$o(@Gbl@(sub)) q:sub=""  d
 .i val s vysl=vysl_","
 .s val=1
 .s vysl=vysl_""""_sub_""":"
 .i $d(@Gbl@(sub))=1 s vysl=vysl_$$ToEx(@Gbl@(sub),0) q
 .s ref=$na(@Gbl@(sub))
 .s vysl=vysl_$$Encode(ref)
 s vysl=vysl_"}"
 q vysl
.
 ;Data to JSON-flat
 ;Reflist - describe structure. Value: 1 - list, 2 - boolean, 3 - optional list
EncodeX(Gbl,Dest,NoKill,RefList)
 n Cou,vysl
 i '$g(NoKill) k @Dest
 i '$d(@Gbl) q
 s Cou=+$zp(@Dest@("")),vysl=""
 d EncodeX1(Gbl,$g(RefList),0)
 d EncW("")
 q
EncodeX1(Gbl,RefO,listO)
 n sub,val,list,Ref
 s list=0
 i 'listO,$g(RefO)'="" s list=+$g(@RefO) i list=3 s list=$s($d(@Gbl)>9:1,1:"")
 i list=1 s vysl=vysl_"["
 e  s vysl=vysl_"{"
 s val=0
 s:$d(@Gbl)'=10 vysl=vysl_""""":"_$$ToEx(@Gbl,list),val=1
 s sub="" f  s sub=$o(@Gbl@(sub)) q:sub=""  d
 .i val d EncW(",")
 .s val=1
 .i list'=1 s vysl=vysl_""""_sub_""":"
 .i RefO'="" s:list'=1 Ref=$na(@RefO@(sub)) s:list=1 Ref=RefO
 .i $d(@Gbl@(sub))=1 s vysl=vysl_$$ToEx(@Gbl@(sub),$s($g(Ref)'="":+$g(@Ref),1:0)) q
 .d EncodeX1($na(@Gbl@(sub)),$g(Ref),(list=1))
 i list=1 s vysl=vysl_"]"
 e  s vysl=vysl_"}"
 q
EncW(%) 
 s Cou=Cou+1,@Dest@(Cou)=vysl_%,vysl=""
 q
.
 ;Data to JSON-string - as LIST/ARRAY
EncodeL(Gbl)
 n vysl,sub,ref,ok
 i $data(@Gbl)<10 q ""
 s vysl="{",ok=0
 s sub="" f  s sub=$o(@Gbl@(sub)) q:sub=""  d
 .i ok s vysl=vysl_","
 .s vysl=vysl_"["
 .s ref=$na(@Gbl@(sub))
 .s vysl=vysl_$$Encode(ref)
 .s vysl=vysl_"]",ok=1
 s vysl=vysl_"}"
 q vysl
 
 ;JSON-string to data. Returned code: 0 - OK, 1 - error
Decode(json,var)
 n length,pos
 s length=$l(json)
 q:length=0 1
 s pos=0
 q $$Decode1(var,0,0)
Decode1(var,isobject,inarray)
 n status,first,sub,ref,end,value,char,nextisname
 s (status,end)=0
 s nextisname=isobject
 s ref=var
 f  q:pos>length  q:status'=0  q:end=1  d
 .s pos=pos+1,first=$e(json,pos)
 .;Whitespace
 .i $c(9,10,13,32)[first q
 .;End of data - object, field
 .i "]}"[first s end=1 q
 .;Continues with value - not examined
 .i first=":" q
 .;Field - begin
 .i first="[" s status=$$Decode1(var,0,1) q
 .;Data continuing
 .i first="," d  q
 ..i $g(inarray,0)>0 s sub=inarray,inarray=inarray+1
 ..e  d
 ...f  s pos=pos+1,char=$e(json,pos) q:char=""""  q:char=""
 ...s sub="" f  s pos=pos+1,char=$e(json,pos) q:char=""""  q:char=""  s sub=sub_char
 ..s var=$na(@ref@(sub))
 .;Any data... add starting subscript 0
 .s:$g(inarray,0)=1 var=$na(@ref@(0))
 .;Data - begin
 .i first="{" s status=$$Decode1(var,1,0) q
 .;String
 .i first="""" d  q
 ..s value=""
 ..f  s char=$e(json,pos+1) q:char=""""  d  
 ...i char'="\" s value=value_char,pos=pos+1 q
 ...d GetEsc
 ..i 'nextisname s @var=value
 ..e  s:value'="" var=$na(@ref@(value)) s nextisname=0
 ..s pos=pos+1
 .;Booolean - false
 .i first_$e(json,pos+1,pos+4)="false" s @var=0,pos=pos+4 q
 .;Boolean - true
 .i first_$e(json,pos+1,pos+3)="true" s @var=1,pos=pos+3 q
 .;Null
 .i first_$e(json,pos+1,pos+3)="null" s @var="null",pos=pos+3 q
 .;The last is number...it should be
 .s @var=$g(@var,"")_first
 q status
.
 ;JSON-flat to data. Not implemented yet, transformed to Decode
DecodeX(Gbl,Dest,Start)
 n i,j
 s (i,j)=""
 i $g(Start) s i=$zp(@Gbl@(Start))
 f  s i=$o(@Gbl@(i)) q:i=""  s j=j_@Gbl@(i)
 q $$Decode(j,Dest)
 
 ;**************** ComplexJSON ***********************
 ;
 ; Types: num  - numeric
 ;        str  - string
 ;        null - null
 ;        bool - boolean
 ; Procedures: EncodeCx     - encode ComplexData -> JSON-string
 ;             DecodeCx     - decode JSON-string -> ComplexData
 ;             CvtSimToCom  - convert SimpleData -> ComplexData
 ;             Verify       - verify JSON string according to ComplexData structure
 ;          Manipulation with ComplexData:
 ;             AddDataCx    - add item(s)
 ;             SetValCx     - set value of item
 ;             GetValCx     - get value of item
 ;             FillSimToCom - fill ComplexData by SimpleData
 ;
 ;****************************************************
 
 ;ComplexData to JSON-string
EncodeCx(Gbl)
 n vysl,sub,ref,refi,val,list,type
 i '$d(@Gbl) q ""
 s (list,val)=0
 s type=$g(@Gbl@("type"))
 i type="list" s vysl="[",list=1
 e  s vysl="{" i type'="",type'="object" s vysl=vysl_""""":"_$$GetCxValue(Gbl),val=1
 s Gbl=$na(@Gbl@("i"))
 s sub="" f  s sub=$o(@Gbl@(sub)) q:sub=""  d
 .s refi=$na(@Gbl@(sub))
 .i val s vysl=vysl_","
 .s val=1
 .i list'=1 s vysl=vysl_""""_sub_""":"
 .i $g(@refi@("type"))="list" s vysl=vysl_$$EncodeCx(refi) q
 .i $g(@refi@("type"))="object" s vysl=vysl_$$EncodeCx(refi) q
 .i $d(@refi@("val"))=1 s vysl=vysl_$$GetCxValue(refi) q
 .i $d(@refi@("i")) s vysl=vysl_$$EncodeCx(refi)
 i list=1 s vysl=vysl_"]"
 e  s vysl=vysl_"}"
 q vysl
 
 ;Convert SimpleData (Field/Tree) -> ComplexData
CvtSimToCom(Sou,Dest,Spec)
 k @Dest
 d CvtSimToCom1(Sou,Dest,"")
 q
CvtSimToCom1(Sou,Dest,Ref)
 n i,RefL
 s i=""
 f  s i=$o(@Sou@(i)) q:i=""  d
 .s RefL=$s(Ref="":i,1:Ref_","_i)
 .i $d(@Sou@(i))#2 d AddDataCx(Dest,RefL,$$GetItemType(Spec,RefL),@Sou@(i))
 .i $d(@Sou@(i))>9 d CvtSimToCom1($na(@Sou@(i)),Dest,RefL)
 q
 
 ;Fill ComplexData by SimpleData
FillSimToCom(Sou,Dest)
 d FillSimToCom1(Sou,Dest,"")
 q
.
FillSimToCom1(Sou,Dest,Ref)
 n i,j,RefL
 s i=""
 f  s i=$o(@Sou@(i)) q:i=""  d
 .s RefL=$s(Ref="":i,1:Ref_","_i)
 .i $d(@Sou@(i))#2 s j=$$SetValCx(Dest,RefL,@Sou@(i))
 .i $d(@Sou@(i))>9 d FillSimToCom1($na(@Sou@(i)),Dest,RefL)
 q
.
 ;JSON-string to ComplexData. Returned code: 0 - OK, 1 - error
DecodeCx(json,var)
 n length,pos
 s length=$l(json)
 q:length=0 1
 s pos=0
 q $$DecodeCx1("",0,0)
DecodeCx1(ref,isobject,inarray)
 n status,end,first,value,char,refl,nextisname
 s (status,end)=0
 s nextisname=isobject
 s refl=ref
 f  q:pos>length  q:status'=0  q:end=1  d
 .s pos=pos+1,first=$e(json,pos)
 .;Whitespace
 .i $c(9,10,13,32)[first q
 .;End of data - object, field
 .i "]}"[first s end=1 q
 .;Field - begin
 .i first="[" d AddDataCx(var,refl,"list") s status=$$DecodeCx1(refl,0,1) q
 .;Object - begin
 .i first="{" d  q
 ..s char=""
 ..i refl'="" s char=$$AddDataCx(var,refl,"object")
 ..i inarray s char="#"_char
 ..e  s char=""
 ..s status=$$DecodeCx1(refl_char,1,0)
 .;Data continuation
 .i first="," s:isobject nextisname=1 q
 .;Continues with value - not evaluated, only in object
 .i first=":" s:isobject nextisname=0 q
 .;String
 .i first="""" d  q
 ..s value=""
 ..f  s char=$e(json,pos+1) q:char=""""  d  
 ...i char'="\" s value=value_char,pos=pos+1 q
 ...d GetEsc
 ..i 'nextisname d AddDataCx(var,refl,"str",value)
 ..i nextisname s:value'="" refl=$s(ref="":value,1:ref_","_value)
 ..s pos=pos+1
 .;Booolean - false
 .i first_$e(json,pos+1,pos+4)="false" d AddDataCx(var,refl,"bool","false") s pos=pos+4 q
 .;Boolean - true
 .i first_$e(json,pos+1,pos+3)="true" d AddDataCx(var,refl,"bool","true") s pos=pos+3 q
 .;Null
 .i first_$e(json,pos+1,pos+3)="null" d AddDataCx(var,refl,"str","null") s pos=pos+3 q
 .;The last is number...it should be
 .s value=first
 .f  s char=$e(json,pos+1) q:"0123456789.eE+-"'[char  s pos=pos+1,value=value_char
 .d AddDataCx(var,refl,"num",value)
 q status
 
 
 ; ComplexData - Add
AddDataCx(Struc,Ref,Type,Val)
 n Gbl,i
 s i=""
 s Gbl=$$MakeRefCx(Struc,Ref)
 i Type="cxdata" d  q i
 .k @Gbl
 .m @Gbl=@Val
 i '$d(@Gbl),Type="list" s @Gbl@("type")="list" q i
 i '$d(@Gbl),Type="object" s @Gbl@("type")="object" q i
 i $d(@Gbl),$g(@Gbl@("type"))="list" s i=$zp(@Gbl@("i",""))+1,Gbl=$na(@Gbl@("i",i))
 s @Gbl@("type")=Type
 s @Gbl@("val")=$g(Val)
 q i
 
 ;ComplexData - test if node has child
HasCxChild(Sou,Ref)
 n Gbl
 s Gbl=$$MakeRefCx(Sou,Ref)
 q ($d(@Gbl@("i"))>9)
  
 ;ComplexData - GetValue from reference
GetCxValue(Ref)
 n Type,Val
 s Type=$g(@Ref@("type"))
 s Val=$g(@Ref@("val"))
 i Type="" s Type="str"
 i Type="str" s Val=$$ToEx(Val,0)
 i Type="bool" s Val=$$ToEx(Val,2)
 i Type="null" s Val="null"
 q Val
 
 ;ComplexData - Get type
GetTypeCx(Sou,Ref)
 n Gbl
 s Gbl=$$MakeRefCx(Sou,Ref)
 q $g(@Gbl@("type"))
 
 ;ComplexData - Get value of item
GetValCx(Sou,Ref)
 n Gbl
 s Gbl=$$MakeRefCx(Sou,Ref)
 q $g(@Gbl@("val"))
 
 ;ComplexData - Set value to item. Return: 0 - OK, 1 - Error
SetValCx(Sou,Ref,Val)
 n Gbl
 s Gbl=$$MakeRefCx(Sou,Ref)
 i '$d(@Gbl@("val")) q 1
 s @Gbl@("val")=Val
 q 0
.
 ;ComplexData - Set field to item
SetFieCx(Sou,Ref,Fie,Val)
 n Gbl
 s Gbl=$$MakeRefCx(Sou,Ref)
 s @Gbl@(Fie)=Val
 q 0
 
 ;ComplexData - Test reference of item
TestRefCx(Sou,Ref)
 n Gbl
 s Gbl=$$MakeRefCx(Sou,Ref)
 q $d(@Gbl)
  
 ;Make global-reference to item in ComplexData
MakeRefCx(Sou,Ref)
 n Gbl,i,j,k,l
 s Gbl=Sou
 f i=1:1:$l(Ref,",") d
 .s j=$p(Ref,",",i)
 .s l=$p(j,"#",2),j=$p(j,"#")
 .s k=$na(@Gbl@("i",j))
 .i $g(@k@("type"))="list",l'="" s k=$na(@k@("i",l))
 .s Gbl=k
 q Gbl
.
 ;Get type from Spec
GetItemType(Spec,Ref)
 n Gbl,i,j,k
 s Gbl=Spec
 f i=1:1:$l(Ref,",") s j=$p(Ref,",",i),Gbl=$na(@Gbl@(j))
 s i=$g(@Gbl),k="str"
 i i=2 s k="bool"
 q k
 
 ;Verify JSON according to ComplexData. Returned value: 0 - OK, 1 - errors (in field Result)
Verify(Sou,RefX,Result)
 n Err,Gbl,Ref,Etalon
 s Err=0
 k @Result
 s Gbl=$na(^Zjsonver($j))
 k @Gbl
 s Err=$$Decode(@Sou,Gbl)
 s Ref="Etalon"
 m @Ref=@RefX
 ;Verification
 d Verify1(Gbl,"",0)
 ;View X-remarks
 d VerifyX(Ref,"")
 k @Gbl
 q Err
Verify1(Subj,VRef,List)
 n i,j,RefL,type
 s i=""
 f  s i=$o(@Subj@(i)) q:i=""  d
 .s j=i
 .i List s j=j+1
 .s RefL=$s(VRef="":j,1:VRef_","_j)
 .s type=$$GetTypeCx(Ref,RefL)
 .i $d(@Subj@(i))#2 d
 ..i type="" s Err=Err+1,@Result@(Err)="Undef.: "_RefL q
 ..i type="num",@Subj@(i)'?1.N.".".N s Err=Err+1,@Result@(Err)="No numeric value: "_RefL
 ..i type="bool",@Subj@(i)'="true",@Subj@(i)'="false",@Subj@(i)'=0,@Subj@(i)'=1 s Err=Err+1,@Result@(Err)="No boolean value: "_RefL
 ..s j=$$SetFieCx(Ref,RefL,"X","")
 .i $d(@Subj@(i))>9 d
 ..i type="list" d Verify1($na(@Subj@(i)),RefL,1) q
 ..d Verify1($na(@Subj@(i)),RefL,0)
 q  
VerifyX(Gbl,VRef)
 n sub,list,RefL,i
 i '$d(@Gbl) q
 s list=0
 i $g(@Gbl@("type"))="list" s list=1
 s Gbl=$na(@Gbl@("i"))
 s sub="" f  s sub=$o(@Gbl@(sub)) q:sub=""  d
 .i 'list s RefL=$s(VRef="":sub,1:VRef_","_sub)
 .i $d(@Gbl@(sub,"i")) d VerifyX($na(@Gbl@(sub)),RefL) q
 .s i=$g(@Gbl@(sub,"flag"))
 .i i="opt" q
 .i '$d(@Gbl@(sub,"X")) s Err=Err+1,@Result@(Err)="Unsatisf.: "_RefL
 q
.
 ;**************** Utilities  ***********************
 ;
 ;***************************************************
.
 ;Conversion of some characters
ToEx(txt,mode)
 n i,j,k,m
 i mode=2 d  q i
 .i +txt s i="true"
 .e  s i="false"
 
 s j="",m="0123456789ABCDEF"
 f i=1:1:$l(txt) d
 .s k=$a(txt,i)
 .i ((k>31)&(k'=34)&(k'=92)&(k'=123)&(k'=125)) s j=j_$c(k) q
 .i k=8 s j=j_"\b" q
 .i k=9 s j=j_"\t" q
 .i k=10 s j=j_"\n" q
 .i k=12 s j=j_"\f" q
 .i k=13 s j=j_"\r" q
 .i k=34 s j=j_"\""" q
 .i k=92 s j=j_"\\" q
 .s j=j_"\u00"_$e(m,k\16#16+1)_$e(m,k#16+1)
 
 q """"_j_""""
 
 ;Get escaped-chars
GetEsc
 s pos=pos+1,char=$e(json,pos)
 i char="""" s value=value_char,pos=pos+1 q
 i char="\" s value=value_char,pos=pos+1 q
 i char="/" s value=value_char,pos=pos+1 q
 i char="b" s value=value_$c(8),pos=pos+1 q
 i char="t" s value=value_$c(9),pos=pos+1 q
 i char="f" s value=value_$c(12),pos=pos+1 q
 i char="n" s value=value_$c(10),pos=pos+1 q
 i char="r" s value=value_$c(13),pos=pos+1 q
 i char="u" s value=value_$$UniToChar($e(json,pos+1,pos+4)),pos=pos+5 q
 ;Other possibilities not in standard
 s value=value_char,pos=pos+1
 q
 
 ;Conversion UNICODE to char
UniToChar(%)
 n i,m
 s %=$zcvt(%,"U")
 s m="0123456789ABCDEF"
 s i=(((($f(m,$e(%))-2))*16+($f(m,$e(%,2))-2))*16+($f(m,$e(%,3))-2))*16+($f(m,$e(%,4))-2)
 q $c(i)
.
 ;ComplexData to XML-string
EncodeXMLCx(Data,Root)
 n vysl
 i $g(Root)="" s Root="root"
 s vysl="<?xml version=""1.0"" encoding=""utf-8""?>"_$c(13,10)_"<"_Root_">"_$c(13,10)
 s vysl=vysl_$$EncodeXMLCx1(Data)
 s vysl=vysl_"</"_Root_">"
 q vysl
 ;ComplexData to XML-string
EncodeXMLCx1(Gbl,Parent)
 n vysl,sub,ref,refi,list
 i '$d(@Gbl) q ""
 s list=0
 i $g(@Gbl@("type"))="list" s list=1,Parent=$g(Parent)
 s vysl=""
 s Gbl=$na(@Gbl@("i"))
 s sub="" f  s sub=$o(@Gbl@(sub)) q:sub=""  d
 .s refi=$na(@Gbl@(sub))
 .i list,$d(@refi@("i"))<10 d  q
 ..s vysl=vysl_"<"_$g(Parent)_" id="""_sub_""" >"_$g(@refi@("val"))_"</"_Parent_">"_$c(13,10)
 .i list=1 s list=2,vysl=vysl_"<"_Parent_">"
 .i $g(@refi@("type"))="list" s vysl=vysl_$$EncodeXMLCx1(refi,sub) q
 .s vysl=vysl_"<"_sub_">"
 .i $g(@refi@("type"))="object" s vysl=vysl_$$EncodeXMLCx1(refi)
 .i $d(@refi@("val"))=1 s vysl=vysl_$g(@refi@("val"))
 .i $d(@refi@("i")) s vysl=vysl_$$EncodeXMLCx1(refi)
 .s vysl=vysl_"</"_sub_">"_$c(13,10)
 i list=2 s vysl=vysl_"</"_Parent_">"
 q vysl
 
 ;Test
Test(%)
 n X
 k @%
 d AddDataCx^LIBjson(%,"Dalsi","bool",1)
 d AddDataCx^LIBjson(%,"Moje","num",67)
 d AddDataCx^LIBjson(%,"Uroven,Druha","bool",1)
 d AddDataCx^LIBjson(%,"Uroven,Treti","str","ABC")
 d AddDataCx^LIBjson(%,"Uroven,Ctvrta","num",456)
 d AddDataCx^LIBjson(%,"Uroven,Listik","list")
 d AddDataCx^LIBjson(%,"Uroven,Listik","str","A")
 d AddDataCx^LIBjson(%,"Uroven,Listik","num",333)
 zw @%
 w $$EncodeXMLCx^LIBjson(%),!
 q
 w $$SetValCx(%,"Uroven,Ctvrta",335),!
 w $$SetValCx(%,"Uroven,Listik,2",334),!
 zw @%
 s X("Uroven","Ctvrta")=336
 s X("Uroven","Listik",2)=337
 d FillSimToCom("X",%)
 zw @%
 q

LIBlck^INT^1^64358,49864^0
LIBlck
 ;* Modul : LIBlck
 ;* Funkce: Locking system
 ;*
 
 ;Lock
Lock(Ref)
 n i,j,l,m,Ok
 l +@Ref:5
 e  q 1
 i $g(C("SESS"))="" q 0
 s i=$$MakeRef(Ref)
 ;Test sub-locks
 s j="^XLOCK("_i_")",k="",l=1,Ok=1
 f  s m=$na(@j,l) q:m=k  s l=l+1,k=m i $d(@m) s Ok=0 q
 i 'Ok l -@Ref q 1
 ;Write Lock
 s @("^XLOCK("_i_")")=C("SESS")
 s ^XLOCKI(C("SESS"),i)=$h
 q 0
 
 ;Unlock
Unlock(Ref)
 n i
 l -@Ref
 i $g(C("SESS"))="" q
 s i=$$MakeRef(Ref)
 k @("^XLOCK("_i_")")
 k ^XLOCKI(C("SESS"),i)
 q
 
 ;General unlock
GU
 l
 i $g(C("SESS"))'="" d GUS(C("SESS"))
 q
.
 ;General unlock of the session
GUS(%)
 n i,j
 s i=""
 f  s i=$o(^XLOCKI(%,i)) q:i=""  s j="^XLOCK("_i_")" k @j,^XLOCKI(%,i)
 q
 
 ;Make semi-reference
MakeRef(%)
 n i
 i %'["(" q """"_$e(%,2,$l(%))_""""
 s i=$p(%,"(")
 q """"_$e(i,2,$l(i))_""","_$p($p(%,"(",2),")")

LIBm^INT^1^65044,36686.82704^0
LIBm
 ;Mumps unification, file operation
 ;Copyright Slavek Zmek, 2013
.
 ;Power - X to Y
Power(X,Y)
 ;Cache
 q $zpower(X,Y)
 ;GTM
 ;q $$FUNC^%EXP(X,Y)
 
 ;Square root
SRoot(X)
 ;Cache
 q $zsqr(X)
 ;GTM
 ;q $$FUNC^%SQROOT(X)
 
 ;Setting ztrap - zetrap $zt
SetZT(X)
 i X="" q ""
 ;Cache
 q X
 ;GTM
 ;i X?1"*B".E q "B"
 ;q "ZG "_($ZL-1)_":"_X
.
 ;Get actual namespace
GetNSP()
 ;Cache
 q $znspace
 ;GTM
 ;????? q "" 
 
 ;Set namespace
SetNSP(X)
 ;Cache
 zn X
 ;GTM
 ;?????
 q
 
 ;Last reference to global
GetREF()
 ;Cache
 q $zr
 ;GTM
 ;q $reference
 
 ;Current time with double precision
ActualTime()
 ;Cache
 q $zutil(188)
 ;GTM
 ;q $h
 
 ;Set run-license
SetLic(%)
 n i
 ;Cache
 i $g(%)="" s %="127.0.0.1"
 s i=$system.License.Login(%)
 ;GTM
 q
 
 ;Open file. Returns handle, if error it is empty string
ofile(file,mode)
 n t
 s $zt=$$SetZT^LIBm("errf^LIBm")
 i mode="W" s mode="WNS"
 i mode="RF" s mode="S"
 i mode'="S" d
 .;Cache
 .o file:mode:0 s t=$t
 i mode="S" d
 .;Cache
 .o file:("S"::$c(0)_$c(255)):0 s t=$t
 .;GTM
 .;o file:(readonly:chset="M"):0 s t=$t
 i t q file
 q ""
 
errf
 s $zt=""
 q ""
.
 ;Test if file exists
tfile(%)
 q ($$files(%)'="") 
 
 ;List of files with specified mask
files(%,%1)
 q $$ldir(%,$g(%1),1)
 
 ;Test, if directory exists
tdir(%)
 n i
 ;Cache
 s i=$zu(140,7,%)
 i (i\16)#2=1 q 1
 q 0 
 
 ;Make directory
mkdir(%)
 d Run("md "_$g(%))
 q
 
 ;Delete file
dfile(%)
 d Run("del "_$g(%))
 q
.
.
 ;Run OS command
Run(%)
 n x
 ;Cache
 s x=$zf(-1,%)
 ;GTM
 ;???
 q
 
 ;List directory
ldir(dir,dest,sys)
 n file,res,i,j,k,name,size
 s res=""
 ;Cache
 s file=$zsearch(dir)
 ;GTM
 ;???
 i file="" q res
 f  q:file=""  d
 .;Cache
 .s i=$zu(140,7,file),size=$zu(140,1,file)
 .i size'<0 d
 ..;Test if it is directory, only for Windows
 ..i sys'=100,(i\16)#2=1 q
 ..s name=$p(file,"\",$l(file,"\"))
 ..s j=name_";"_i_";"_size_";"
 ..s k=$zdatetime(+$zu(140,2,file))
 ..s j=j_$p(k," ")_";"_$p(k," ",2)_";"_name
 ..i dest="" s res=res_j_$c(10)
 ..e  s @dest@(name)=j
 .;Cache
 .s file=$zsearch("")
 q res
.
 ;Manipulation with M-routine - using command $t ....
 ; Get line from routine
GetLine(Ro,La,Po)
 n i
 s i=La
 i Po'="" s i=i_"+"_Po
 s i=i_"^"_Ro
 q $t(@i)
 ; Get entire routine, lines are separated with #10. Second parameter - number of white lines in the end
GetSource(%,%1)
 n i,j,k,Rou
 i $g(%)="" q ""
 s %1=+$g(%1)
 s Rou="",k=%1
 f i=1:1 s j=$$GetLine(%,"",i) q:(j="")&'k  s Rou=Rou_j_$c(10) s:(j="")&k k=k-1 s:j'="" k=%1
 q Rou
 ;Fill field by data from routine
FillFld(Dest,Rou,Lab,Len)
 n i,j,k,l
 k @Dest
 f i=1:1 s j=$$GetLine(Rou,Lab,i) q:j'[";;"  d
 .s k=$p(j,";;",2,Len+1)
 .s @Dest@(i)=$p(k,";")
 .f l=2:1:Len s @Dest@(i,l-1)=$p(k,";",l)
 q
 ;Fill field by data from routine - variant with subscripts
FillFldS(Dest,Rou,Lab,Len)
 n i,j,k,l,m
 k @Dest
 s Dict=+$g(Dict)
 f i=1:1 s j=$$GetLine(Rou,Lab,i) q:j'[";;"  d
 .s k=$p(j,";;",2,Len+1)
 .s m=$p(k,";") i m="" q
 .s @Dest@(m)=$p(k,";",2)
 .f l=3:1:Len s @Dest@(m,l-2)=$p(k,";",l)
 q
 
 

LIBprttex^INT^1^65304,31818.051804^0
LIBprttex
 ;LIBprttex - print via TeX (typographic system)
 ;Copyright Slavek Zmek, 2019
 ;Using TeX
 
 ;One template - more data
MakeTeXH(xTemp,xData,xDest)
 n TeX,i
 s TeX=$$New^LIBprttexu(xTemp)
 i TeX="" q
 s i=""
 f  s i=$o(@xData@(i)) q:i=""  d Add($na(@xData@(i)),xTemp)
 g Fin
 
 ;One template - one data
MakeTeX(xTemp,xData,xDest)
 n TeX
 s TeX=$$New^LIBprttexu(xTemp)
 i TeX="" q
 d Add(xData,xTemp)
Fin
 d SaveAndFree^LIBprttexu(TeX,xDest)
 q
 
 ;Add one step data-template
Add(Data,Temp)
 n band,bType,bHeader,bFooter,a,i,dPar
 ;Initialize, first settings
 m a("con")=@Temp@("const")
 f i="C","THea","TFoo","PgT" s a(i)=""
 s i=""
 f  s i=$o(a("con",i)) q:i=""  i $e(a("con",i))="@" s a("con",i)=$$GetVal($p(a("con",i),"@",2))
 s i=""
 f  s i=$o(@Temp@("transformations",i)) q:i=""  d
 .i '$g(@Temp@("transformations",i,"type")) d Transf(i,"")
 
 s i=$na(@Temp@("header"))
 d FillStr(i,.dPar,"FN:font,FoS:fontsize")
 d FillNum(i,.dPar,"dWid:width,dHei:h,Ori:orient")
 i dPar("FN")="" s dPar("FN")="csbx12"
 i $d(@Temp@("script")) d Script
 d InitFonts^LIBprttexu
 ;Dodelat pokud to pujde - zmena orientace
 ;i dPar("Ori") 
 i 'dPar("dHei") s dPar("dHei")=25
 s a("Beg")=1
 s a("Top")=dPar("dHei")
 s (bHeader,bFooter)=""
 f i="Num","dHea","dPat" s a(i)=0
 
 ;Loop over all bands
 s band=""
 f  s band=$o(@Temp@("bands",band)) q:band=""  d
 .i $g(@Temp@("bands",band,"header","ff")) d NewPage(band)
 .s bType=+$g(@Temp@("bands",band,"header","type"))
 .i 'bType d RegHea q
 .i bType=2 d RegFoo q
 .i bType=4 s a("THea")=band q
 .i bType=5 s a("TFoo")=band q
 .i a("Beg"),bHeader d NewPage s a("Beg")=0
 .d PrintComment^LIBprttexu("Band "_band)
 .i bType=3 d WriteTable(band)
 .i bType'=3 d WriteBand(band,0)
 
 i bFooter'="" d WriteFoo
 ;Nakonec - pocitani poctu stranek
 i a("PgT")'="" s a("X","pgTotal")=a("Num") d Substitute^LIBprttexu(TeX,$na(a("X")))
 q
 
 ;Register headings band
RegHea
 n ref
 s ref=$na(@Temp@("bands",band,"header"))
 d PrintComment^LIBprttexu("Header definition")
 d Add^LIBprttexu(TeX,"\def\header"_band_"{")
 d WriteBand(band,1)
 d Add^LIBprttexu(TeX,"}")
 d FillNum(ref,.a,"dHea:h,dPage:page")
 i a("dPage")="" k bHeader s bHeader=band q
 s bHeader(a("dPage"))=band
 i a("Beg"),a("Num")=a("dPage") s bHeader=band
 q
 
 ;Register footer band
RegFoo
 n ref
 s ref=$na(@Temp@("bands",band,"header"))
 d PrintComment^LIBprttexu("Footer definition")
 d Add^LIBprttexu(TeX,"\def\footer"_band_"{")
 d WriteBand(band,1)
 d Add^LIBprttexu(TeX,"}")
 d FillNum(ref,.a,"dPat:h,dPage:page,dDown:down")
 i a("dPage")="" k bFooter s bFooter=band q
 s bFooter(a("dPage"))=band
 i a("Beg"),a("Num")=a("dPage") s bFooter=band
 q
 
 ;Write footer band
WriteFoo
 n i
 i $g(a("dDown")) d
 .s i=a("Top")-a("dPat")
 .i i>0 d
 ..d OpenBand^LIBprttexu(i)
 ..d CloseBand^LIBprttexu
 
 s a("Top")=a("dPat")
 d Add^LIBprttexu(TeX,"\footer"_bFooter)
 q  
 
 ;Write band - standard
WriteBand(bnd,def)
 n bP,eP,d,value,i,iLoo
 d LoadB
 i 'def,'$$LinkB("") q
 i 'def,(a("Top")-bP("He"))<a("dPat"),bnd'=bFooter d NewPage(bnd)
 i $g(bP("Tr"))'="" d Transf(bP("Tr"),"")
 d OpenBand^LIBprttexu(bP("He"))
 s d="",iLoo=0
 f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ItemB(d,"",1) d
 .i $e(eP("Na"),$l(eP("Na")))="%" s iLoo=1 q
 .;Type - what to do...
 .i eP("type")=0 d TText($s(eP("Fl"):eP("Na"),1:"")) q
 .i eP("type")=1 d  q
 ..i eP("Na")'="" s value=$$GetVal(eP("Na"))
 ..d TText($s(eP("Fl"):eP("Na"),1:""))
 .i eP("type")=2 d THLine q
 .i eP("type")=3 d TVLine q
 .i eP("type")=4 d TConst q
 .i eP("type")=5 d TImage q
 
 i bP("Loo")'="",iLoo d Loop("")
 d CloseBand^LIBprttexu
 i 'def s a("Top")=a("Top")-bP("He")
 q
 
 ;Write band - cyclic(table)
WriteTable(bnd)
 n bP,eP,d,value,Idx,ev,tok,bDef,bGrp,eR,iLoo
 d Group
 i '$d(bGrp) q
 s tok=0
 s (Idx,bDef)=""
 f  s Idx=$o(@Data@(bP("Na"),Idx)) q:Idx=""  d
 .s ev=$g(@Data@(bP("Na"),Idx,"e"))
 .s eR=bP("Na")_"."_Idx
 .;Go through the group
 .s bnd=""
 .f  s bnd=$o(bGrp(bnd)) q:bnd=""  d
 ..i bnd'=bDef d LoadB s bDef=bnd
 ..i '$$LinkB(eR) q
 ..i (a("Top")-bP("He"))<a("dPat") d NewPage(bnd) s tok=0
 ..i $g(bP("Tr"))'="" d Transf(bP("Tr"),eR)
 ..;Table's head
 ..i 'tok,a("THea")'="" d WriteBand(a("THea"),0) s tok=1
 ..d OpenBand^LIBprttexu(bP("He"))
 ..s d="",iLoo=0
 ..f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ItemB(d,eR,0) d
 ...i $e(eP("Na"),$l(eP("Na")))="%" s iLoo=1 q
 ...i eP("type")=1,eP("Na")'="" s value=$$GetValI(eP("Na"),$na(@Data@(bP("Na"),Idx)))
 ...d TText($s(eP("Fl"):eR_"."_eP("Na"),1:""))
 ..i bP("Loo")'="",iLoo d Loop(eR)
 ..d CloseBand^LIBprttexu
 ..s a("Top")=a("Top")-bP("He")
 
 i tok,a("TFoo")'="" d WriteBand(a("TFoo"),0)
 q
 
 ;Fill list of the band's group
Group
 n i,j,grp,Ok
 s j=$na(@Temp@("bands"))
 s bP("Na")=$g(@j@(bnd,"header","name"))
 i bP("Na")="" q
 s bGrp(bnd)=""
 s grp=$g(@j@(bnd,"header","group"))
 i grp="" q
 s i=bnd,Ok=1
 f  s i=$o(@j@(i)) q:i=""  d  q:'Ok
 .i $g(@j@(i,"header","name"))'=bP("Na") s Ok=0 q
 .i $g(@j@(i,"header","group"))'=grp s Ok=0 q
 .s band=i
 .s bGrp(i)=""
 q
 
 ;Load band's parameters
LoadB
 n ref
 s ref=$na(@Temp@("bands",bnd,"header"))
 d FillNum(ref,.bP,"He:h,Fl:flexible,Fr:frame")
 d FillStr(ref,.bP,"FNa:font,FSi:fontsize,Loo:loop,Tr:trans")
 d FillVal(ref,.bP,"Na:name,LI:link")
 i bP("FNa")="" s bP("FNa")=dPar("FN")
 i 'bP("FSi") s bP("FSi")=dPar("FoS")
 q
 
 ;Link of band
LinkB(%)
 n i,j,Ok
 s Ok=0,j=bP("LI")
 i j="" s Ok=1
 i j'="" d
 .i %'="" s j=%_"."_j
 .s i=$$Ref(j)
 .i i="" q
 .i $d(@i) s Ok=1
 i 'Ok q 0
 i bP("Fl") d FlexB(%)
 i 'bP("He") q 0
 q 1
 
 ;Flexibility of band, height is set according to elements
FlexB(%)
 n i,j,d,He
 s He=0
 s d=""
 f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ItemB(d,%,1) d
 .s j=eP("Na")
 .i %'="" s j=%_"."_j i '$$DataVal(j) q
 .i eP("Fl") d
 ..s i="" f  s i=$$OrderVal(j,i) q:i=""  s y=y+eP("h")
 ..i %'="" s y=y-eP("h")
 .i (eP("y")+eP("h"))>He s He=(eP("y")+eP("h"))
 i He s bP("He")=He+bP("Fl")
 q
 
 ;Parameters of band's item
ItemB(%,%1,%2)
 n ref,link,i
 s ref=$na(@Temp@("bands",bnd,"data",%))
 s link=$g(@ref@("link"))
 i '%2,$e(link,$l(link))="%" s link=""
 i link'="" d  i 'i q 0
 .i $e(link)="%" s i=$$GetNum(link) q
 .i %1'="" s link=%1_"."_link
 .s i=$$DataVal(link)
 
 d FillVal(ref,.eP,"Na:name,Ev:onevent,prefix:prefix,bx:basex,by:basey")
 d FillNum(ref,.eP,"Start:start,End:end,Fr:frame,x:x,y:y,w:w,h:h,align:align,valign:valign,type:type,Bo:boxed")
 
 s eP("Fl")=$s(bP("Fl"):$g(@ref@("flexible")),1:0)
 s value=$$GetStr($g(@ref@("value")))
 i value="" s value=$g(@ref@("default"))
 ;Base
 i eP("bx")'="" s eP("x")=eP("x")+$$GetNum(eP("bx"))
 i eP("by")'="" s eP("y")=eP("y")+$$GetNum(eP("by"))
 q 1
.
Loop(%)
 n l1,l2,l3,l4,l5
 s l1=$$GetNum($p(bP("Loo"),","))
 s l2=$$GetNum($p(bP("Loo"),",",2))
 s l3=$$GetNum($p(bP("Loo"),",",3))
 s d=""
 f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ItemB(d,%,0) d
 .s l5=eP("Na")
 .i $e(l5,$l(l5))'="%" q
 .s l5=$e(l5,1,$l(l5)-1)
 .f l4=l1:1:l2 s eP("Na")=l5_l4 d  s eP("x")=eP("x")+l3,eP("w")=eP("w")+l3
 ..i '$$LinkL(d,%,l4) q
 ..s a("con","loop")=l4
 ..i eP("type")=0 d TText($s(eP("Fl"):eP("Na"),1:"")) q
 ..i eP("type")=1 d  q
 ...i %="" d  q
 ....s value=$$GetVal(eP("Na"))
 ....d TText($s(eP("Fl"):eP("Na"),1:""))
 ...s value=$g(@Data@(bP("Na"),Idx,eP("Na")))
 ...d TText($s(eP("Fl"):%_Idx_"."_eP("Na"),1:""))
 ..i eP("type")=4 d TConst q
 q
.
 ;Link in loop
LinkL(%,%1,%2)
 n ref,link
 s ref=$na(@Temp@("bands",bnd,"data",%))
 s link=$g(@ref@("link"))
 i $e(link,$l(link))'="%" q 1
 s link=$e(link,1,$l(link)-1)_%2
 i %1'="" s link=%1_"."_link
 q $$DataVal(link)
   
 ;Make reference
Ref(%)
 n i,j
 i %="" q ""
 i '$f(%,".") s i=$na(@Data@(%))
 i $f(%,".") d
 .s i=Data
 .f j=1:1:$l(%,".") s i=$na(@i@($p(%,".",j)))
 q i
.
 ;Make reference - for subs
RefI(%,%1)
 n i,j
 i %="" q ""
 i '$f(%,".") s i=$na(@%1@(%))
 i $f(%,".") d
 .s i=%1
 .f j=1:1:$l(%,".") s i=$na(@i@($p(%,".",j)))
 q i
 
 ;Get value of item
GetVal(x)
 n i
 s i=$$Ref(x)
 i i="" q ""
 q $g(@i)
.
 ;Get value of item - for subs
GetValI(x,y)
 n i
 s i=$$RefI(x,y)
 i i="" q ""
 q $g(@i)
 
 ;Set value of item
SetVal(x,y) 
 n i
 s i=$$Ref(x)
 i i'="" s @i=y
 q
 
 ;Test existence dat
DataVal(x)
 n i,j
 s i=$$Ref(x)
 i i="" q 0
 s j=$g(@i)
 i j'="" q 1
 q $d(@i)
 
 ;Order of item
OrderVal(x,y)
 n i
 s i=$$Ref(x)
 i i="" q ""
 q $o(@i@(y))
 
 ;New page
NewPage(band)
 i 'a("Beg"),bFooter,bFooter'=band d WriteFoo
 s a("Num")=a("Num")+1
 d PrintComment^LIBprttexu("Page "_a("Num"))
 d NewPage^LIBprttexu
 s a("Top")=dPar("dHei")
 i $d(bHeader(a("Num"))) s bHeader=bHeader(a("Num")) k bHeader(a("Num"))
 i bHeader d Add^LIBprttexu(TeX,"\header"_bHeader) s a("Top")=a("Top")-a("dHea")
 q
 
 ;Text
TText(sub)
 n i,j,fN,fS
 ;Truncate
 i eP("Start")!eP("End") d
 .i 'eP("Start") s eP("Start")=1
 .i 'eP("End") s eP("End")=$l(value)
 .s value=$e(value,eP("Start"),eP("End"))
 i value="",sub="" q
 s fN=$$GetStr($g(@Temp@("bands",bnd,"data",d,"font")))
 s fS=$$GetNum($g(@Temp@("bands",bnd,"data",d,"fontsize")))
 i fN="" s fN=bP("FNa")
 i 'fS s fS=bP("FSi")
 s j=0
 i value'="" d TText1
 ;Sub-elements
 i sub'="" d
 .i 'eP("h") s eP("h")=bP("FSi")
 .s i=""
 .f  s i=$$OrderVal(sub,i) q:i=""  d
 ..i j s eP("y")=eP("y")+eP("h")
 ..s value=$$GetVal(sub_"."_i)
 ..d TText1
 q
 
TText1
 n i,j,comm
 ;Prefix
 i eP("prefix")'="" s value=eP("prefix")_" "_value
 ;Font
 i (fN'=a("FN"))!(fS'=a("FS")) d
 .i value="" q
 .s i=$$RegisterFont^LIBprttexu(TeX,fN,fS)
 .i i'="" s value="\"_@TeX@("F",i,"zkr")_" "_value
 ;Alignment 
 d TAlign
 ;Tiskovy bod je na panelu vlevo nahore
 s j="{"_eP("x")_"}{-"_(eP("y"))_"}{"_eP("h")_"}{"_eP("w")_"}"
 i $g(eP("Bo")) s comm="\pointflex"
 e  d
 .i '$g(eP("align")) s comm="\pointtxt" q
 .s comm="\pointtxtw"
 d Add^LIBprttexu(TeX,comm_j_"{"_value_"}")
 i $g(eP("Fr")) d Add^LIBprttexu(TeX,"\pointbox"_j)
 q
 
 ;Text-alignment
TAlign
 i 'eP("align") s value=value_" \hfil" q
 i eP("align")=1 s value="\hfil "_value q
 i eP("align")=2 s value="\hfil "_value_" \hfil" q
 q
.
 ;Line - horizontal
THLine
 n i
 s i=eP("h")
 i 'i d Add^LIBprttexu(TeX,"\pointhline{"_eP("x")_"}{-"_eP("y")_"}{"_eP("w")_"}")
 i i d Add^LIBprttexu(TeX,"\pointhlinew{"_eP("x")_"}{-"_eP("y")_"}{"_i_"}{"_eP("w")_"}")
 q
.
 ;Line - vertical
TVLine
 n i
 s i=eP("w")
 i 'i d Add^LIBprttexu(TeX,"\pointvline{"_eP("x")_"}{-"_(eP("y")+eP("h"))_"}{"_eP("h")_"}")
 i i d Add^LIBprttexu(TeX,"\pointvlineh{"_eP("x")_"}{-"_(eP("y"))_"}{"_eP("h")_"}{"_i_"}")
 q
 
 ;Special constants
TConst
 n k
 s k=value
 s value=$$GetSConst(value)
 d TText("")
 s value=k
 q
 
 ;Image
TImage
 d Add^LIBprttexu(TeX,"\inspic{"_value_"}{"_eP("x")_"}{-"_eP("y")_"}{"_eP("h")_"}{"_eP("w")_"}")
 q 
.
 ;Transformation
Transf(sub,tbl)
 n i,j,k,ref,sou,op,arg1,arg2,arg3,arg1x
 s i=""
 f  s i=$o(@Temp@("transformations",sub,"data",i)) q:i=""  d
 .s ref=$na(@Temp@("transformations",sub,"data",i))
 .s sou=$g(@ref@("source"))
 .i tbl'="" s sou=tbl_"."_sou
 .s j=""
 .i $g(@ref@("type")) s j=$$GetVal(sou)
 .s op=$g(@ref@("op")),arg1=$g(@ref@("arg1")),arg1x=arg1
 .i tbl'="" s arg1x=tbl_"."_arg1
 .i 'op s j=j_arg1
 .i op=1 s j=j_$$GetVal(arg1x)
 .i op=2 d
 ..s k=$$GetVal(arg1x)
 ..s arg2=$g(@ref@("arg2")),arg3=$g(@ref@("arg3"))
 ..i 'arg2 s arg2=1
 ..i 'arg3 s arg3=$l(k)
 ..s j=j_$e(k,arg2,arg3)
 .i op=3 d
 ..s k=$$GetVal(arg1x)
 ..s arg2=$g(@ref@("arg2")),arg3=$g(@ref@("arg3"))
 ..i (arg2="")!('arg3) s j=j_k q
 ..s j=j_$p(k,arg2,arg3)
 .i op=4 s j=j_$$GetSConst(arg1)
 .d SetVal(sou,j)
 q
 
 ;Script
Script
 n sc,i,line,len,Ok
 s sc=$na(@Temp@("script"))
 s i="",Ok=0
 f  s i=$o(@sc@(i)) q:i=""  d  q:Ok
 .s line=@sc@(i),len=$l(line)
 .i $e(line,1,2)="IF" d IF q
 .i $e(line,1,4)="EXIT" s Ok=1 q
.
 q 
 ;Script-If
IF
 n type,Exp1,Exp2,i,j
 s type=0,j=3,len=$l(line)
 i $e(line,j)'="(" d  i type=-1 q
 .s type=-1
 .i $e(line,j)="L" s type=1
 .i $e(line,j)="G" s type=2
 .i $e(line,j)="N" s type=3
 .s j=j+1
 ;1.expression
 s j=j+1
 s Exp1=""
 f  q:j>len  q:$e(line,j)=","  q:$e(line,j)=")"  s Exp1=Exp1_$e(line,j),j=j+1
 s Exp1=$$GetVal(Exp1)
 ;2.expression
 i $e(line,j)'=")" s j=j+1
 s Exp2=""
 f  q:j>len  q:$e(line,j)=")"  s Exp2=Exp2_$e(line,j),j=j+1
 s j=j+1
 s line=$$trim^SYSutil($e(line,j,len)),j=1,len=$l(line)
 ;Compare
 s i=0
 i type=0,Exp1=Exp2 s i=1
 i type=1,Exp1<Exp2 s i=1
 i type=2,Exp1>Exp2 s i=1
 i type=3,Exp1'=Exp2 s i=1
 i 'i q
 ;Set
 s a("con",$p(line,"="))=$p(line,"=",2)
 q
.
 ;Read value as number. Test - it could be constant...
GetNum(%)
 i $e(%)'="%" q +%
 s %=$e(%,2,$l(%))
 i %="" q 0
 i %["+" q +$g(a("con",$p(%,"+")))+$p(%,"+",2)
 i %["-" q +$g(a("con",$p(%,"-")))+$p(%,"-",2) 
 q +$g(a("con",%))
 ;Read value as string. Test - it could be constant...
GetStr(%)
 i $e(%)'="%" d  q %
 .i $e(%,1,2)="\%" s %=$e(%,2,$l(%))
 s %=$e(%,2,$l(%))
 i %="" q ""
 q $g(a("con",%))
 ;Get special constant
GetSConst(%)
 n i
 s i=""
 i '% s i="\the\pageno "
 i %=1 s i=$$HtD^ISBdt(+$h)
 i %=2 d
 .i a("PgT")="" s a("PgT")="%#pgTotal "
 .s i=a("PgT")
 i %=3 s i=$$NOWR^ISBdt()
 i %=5 s i=$g(a("con","loop"))
 q i
 ;Fill values
FillVal(%Ref,%Sou,%Data)
 n i,j
 f i=1:1:$l(%Data,",") s j=$p(%Data,",",i) i j'="" s %Sou($p(j,":"))=$g(@%Ref@($p(j,":",2)))
 q
 ;Fill numeric-values
FillNum(%Ref,%Sou,%Data)
 n i,j
 f i=1:1:$l(%Data,",") s j=$p(%Data,",",i) i j'="" s %Sou($p(j,":"))=$$GetNum($g(@%Ref@($p(j,":",2))))
 q
 ;Fill string-values
FillStr(%Ref,%Sou,%Data)
 n i,j
 f i=1:1:$l(%Data,",") s j=$p(%Data,",",i) i j'="" s %Sou($p(j,":"))=$$GetStr($g(@%Ref@($p(j,":",2))))
 q

LIBprttexu^INT^1^65304,27546.736896^0
LIBprttexu
 ;LIBprttex - print via TeX, utilities
 ;Copyright Slavek Zmek, 2018
 ;Using TeX
 
 ;Create temporary global, initialization
New(%)
 n Gbl,i
 s Gbl=$na(^Zprttex($j))
 k @Gbl
 ;Some constants from template
 i %'="" d
 .s i=$g(@%@("const","unit"))
 .i i="" s i="cm"
 .d SetConst(Gbl,"unit",i)
 d Init(Gbl)
 q Gbl
  
 ;Initialization, first sequence
Init(%)
 n unit
 ;Constants
 s unit=$$GetConst(%,"unit")
 i unit="" s unit="cm"
 ;Hlavicka souboru
 d Add(%,"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
 d Add(%,"%   Generating by library LIBprttex                                    %")
 d Add(%,"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
 d Add(%,"\nopagenumbers")
 d Add(%,"\voffset=-1in")
 d Add(%,"\advance\voffset by 1cm")
 d Add(%,"\hoffset=-1in")
 d Add(%,"\advance\hoffset by 1cm")
 d Add(%,"\hsize=19cm")
 d Add(%,"\vsize=27.7cm")
 d Add(%,"\parindent=0cm")
 ;Macros
 d Add(%,"\newdimen\unit")
 d Add(%,"\unit=1"_unit)
 ;Protoze u hboxu nedrzim sirku, nejsou tam ted preteceni. Pokud by byly, da se to timto vypnout...
 ;d Add(%,"\overfullrule=0pt")
 d Add(%,"% Macros - print box,... %")
 d Add(%,"\def\printsaved#1#2{\setbox6=\hbox{\kern#1\unit \leavevmode \raise#2\unit \box3} \ht6=0pt \wd6=0pt \dp6=0pt \box6 \nointerlineskip}")
 d Add(%,"\def\printval#1#2#3{\vbox{\hbox{\vbox to #1{\hbox to #2{#3}\vfil}}}}")
 d Add(%,"\def\pointhline#1#2#3{\setbox3=\hbox{\vbox{\hrule width#3\unit}} \printsaved{#1}{#2}}")
 d Add(%,"\def\pointhlinew#1#2#3#4{\setbox3=\hbox{\vbox{\hrule height#3\unit width#4\unit}} \printsaved{#1}{#2}}")
 d Add(%,"\def\pointvline#1#2#3{\setbox3=\hbox{\vbox{\hbox{\vrule height#3\unit}}} \printsaved{#1}{#2}}")
 d Add(%,"\def\pointvlineh#1#2#3#4{\setbox3=\hbox{\vbox{\hbox{\vrule height#3\unit width#4\unit}}} \printsaved{#1}{#2}}")
 d Add(%,"\def\pointflex#1#2#3#4#5{\setbox4=\vbox to #3\unit{\hsize #4\unit \raggedright #5 \vfil} \setbox3=\hbox{\printval{#3\unit}{#4\unit}{\box4}} \printsaved{#1}{#2}}")
 d Add(%,"\def\pointtxt#1#2#3#4#5{\setbox3=\hbox{#5} \printsaved{#1}{#2}}")
 d Add(%,"\def\pointtxtw#1#2#3#4#5{\setbox3=\hbox to #4\unit{#5} \printsaved{#1}{#2}}")
 d Add(%,"\def\pointbox#1#2#3#4{\setbox3=\hbox{\vrule \vbox to #3\unit{\hrule \hbox to #4\unit{\hfil}\vfil \hrule}\vrule} \printsaved{#1}{#2}}")
 d Add(%,"% Macro - from opmac.tex - picture insert%")
 ;d Add(%,"\def\inspic#1#2#3#4#5{\setbox3=\hbox{\kern#2\unit \raise#3\unit \vbox{\pdfximage height#4\unit width#5\unit {\picdir#1}%")
 d Add(%,"\def\inspic#1#2#3#4#5{\setbox3=\hbox{\vbox{\pdfximage height#4\unit width#5\unit {#1}%")
 d Add(%,"\pdfrefximage\pdflastximage}} \printsaved{#2}{#3}}")
 q
 
 ;Finalization
SaveAndFree(%,%1)
 d Add(%,"\end")
 k @%1
 m @%1=@%@("T")
 k @%
 q
 
 ;******* Fonts **********
 ;Init fonts
InitFonts
 n bnd,d,fn,fs,fontx,Ref
 d PrintComment("Fonts")
 ;List of all fonts
 s fontx=$$RegisterFont(TeX,dPar("FN"),dPar("FoS"))
 ;Bands
 s Ref=$na(@Temp@("bands"))
 s bnd=""
 f  s bnd=$o(@Ref@(bnd)) q:bnd=""  d
 .s d=""
 .f  s d=$o(@Ref@(bnd,"data",d)) q:d=""  d
 ..s fn=$$GetStr^LIBprttex($g(@Ref@(bnd,"data",d,"font")))
 ..s fs=$$GetStr^LIBprttex($g(@Ref@(bnd,"data",d,"fontsize")))
 ..i fn'="" s fontx=$$RegisterFont(TeX,fn,fs)
 ;Events
 s Ref=$na(@Temp@("event"))
 s d=""
 f  s d=$o(@Ref@(d)) q:d=""  d
 .s fn=$$GetStr^LIBprttex($g(@Ref@(d,"font")))
 .s fs=$$GetStr^LIBprttex($g(@Ref@(d,"fontsize")))
 .i fn'="" s fontx=$$RegisterFont(TeX,fn,fs)
 
 ;Set default font
 f d="FN","FS" s a(d)=""
 d SetFont(TeX,dPar("FN"),dPar("FoS"))
 q 
 
 ;Register font
RegisterFont(%,%1,%2)
 n i,Ok
 s (i,Ok)="",%2=$g(%2)
 f  s i=$o(@%@("F",i)) q:i=""  d  q:Ok'=""
 .i $g(@%@("F",i,"name"))=%1,$g(@%@("F",i,"scale"))=%2 s Ok=i
 i Ok="" d
 .s Ok=$zp(@%@("F",i))+1
 .s @%@("F",Ok,"name")=%1
 .s @%@("F",Ok,"scale")=%2
 .s @%@("F",Ok,"zkr")="fxx"_$c(64+Ok)
 .s i="\font\"_@%@("F",Ok,"zkr")_"="_%1
 .i +$g(%2) s i=i_" scaled "_%2
 .d Add(%,i)
 q Ok
.
 ;Set font
SetFont(%,%1,%2)
 n i,font
 i %1=a("FN"),%2=a("FS") q
 s i=$$RegisterFont(%,%1,%2)
 i i="" q
 s font=@%@("F",i,"zkr")
 d Add(%,"\"_font)
 s a("FN")=$g(@%@("F",i,"name"))
 s a("FS")=$g(@%@("F",i,"scale"))
 q
.
 ;****  Commands ***********
 
 ;NewPage
NewPage
 d Add(TeX,"\vfil \break")
 q
 
 ;Open band
OpenBand(%)
 n Frame,i,j
 s Frame=+$g(bP("Fr"))
 s j=%_"\unit"
 s i="\vbox to "_j_"{"
 i Frame s i=i_"\hrule"
 d Add(TeX,i)
 s i="\hbox to \hsize{"
 i Frame s i=i_"\vrule"
 d Add(TeX,i)
 d Add(TeX,"\vbox to "_j_"{")
 q
 
 ;Close Band
CloseBand
 n Frame,i
 s Frame=+$g(bP("Fr"))
 d Add(TeX,"\vfil }")
 s i="\hfil "
 i Frame s i=i_"\vrule"
 s i=i_"}"
 d Add(TeX,i)
 s i="\vfil "
 i Frame s i=i_"\hrule"
 s i=i_"}"
 d Add(TeX,i)
 q    
 
 ;Print commentary
PrintComment(%)
 n i,j
 s %="% "_%_" %",j=""
 f i=1:1:$l(%) s j=j_"%"
 d Add(TeX,j),Add(TeX,%),Add(TeX,j)
 q 
 
 ;Add commandd
Add(%,%1)
 n i
 s i=$zp(@%@("T",""))+1
 s @%@("T",i)=%1
 q
 
 ;Add command, returns index to other purposes
AddX(%,%1)
 n i
 s i=$zp(@%@("T",""))+1
 s @%@("T",i)=%1
 q i
 
 ;Set constant
SetConst(%,%1,%2)
 s @%@("C",%1)=%2
 q
 
 ;Get measure and measurment
GetMeasure(%)
 q %_$$GetConst(TeX,"unit")
 
 ;Get constant
GetConst(%,%1)
 q $g(@%@("C",%1))
.
 ;Substitute values in whole TeXt
Substitute(%,%1)
 n Ref,i,j,Chn,Pos,Val
 s Ref=$na(@%@("T"))
 s i=""
 f  s i=$o(@Ref@(i)) q:i=""  d
 .s j=@Ref@(i),Chn=0
 .f  s Pos=$f(j,"%#") q:'Pos  d
 ..s Chn=1
 ..s Val=$p($e(j,Pos,$l(j))," ")
 ..s j=$e(j,1,Pos-3)_$g(@%1@(Val))_$e(j,Pos+$l(Val),$l(j))
 .i Chn s @Ref@(i)=j
 q 
  
 ;;********** TEMPLATES ************** 
LoadTemplate(Sou,Dest)
 n Wrk,Err,Ret,Ret1,Ret2,i,j,k,l,Ref,Ref2,ID,ID1
 k @Dest
 s Wrk=$$Init^LIBxml()
 s Err=$$Analyze^LIBxml(Wrk,Sou)
 s Ret=">Template>header>"
 s i=$$Val^LIBxml(Ret_"name",Wrk)
 s @Dest@("header","name")=i
 s Ret=">Template>const>citem#"
 f i=1:1 s ID=$$Atrib^LIBxml(Ret_i,Wrk,"id") q:ID=""  d
 .s j=$$Atrib^LIBxml(Ret_i,Wrk,"name")
 .i j'="" s @Dest@("const",j)=$$Atrib^LIBxml(Ret_i,Wrk,"value")
 s Ret=">Template>transformations>trans#"
 f i=1:1 s ID=$$Atrib^LIBxml(Ret_i,Wrk,"id") q:ID=""  d
 .s Ret1=Ret_i,Ref=$na(@Dest@("transformations",ID))
 .f l="type","name" s j=$$Atrib^LIBxml(Ret1,Wrk,l) s @Ref@("header",l)=j
 .f k=1:1 s ID1=$$Atrib^LIBxml(Ret1_">titem#"_k,Wrk,"id") q:ID1=""  d
 ..s Ret2=Ret1_">titem#"_k,Ref2=$na(@Ref@("data",k))
 ..f l="type","name","source","op","arg1","arg2","arg3" s j=$$Atrib^LIBxml(Ret2,Wrk,l) i j'="" s @Ref2@(l)=j
 s Ret=">Template>bands>band#"
 f i=1:1 s ID=$$Atrib^LIBxml(Ret_i,Wrk,"id") q:ID=""  d
 .s Ret1=Ret_i,Ref=$na(@Dest@("bands",ID)),Ref2=$na(@Ref@("header"))
 .s @Ref2@("h")=$$Atrib^LIBxml(Ret1,Wrk,"height")
 .f l="type","name" s j=$$Atrib^LIBxml(Ret1,Wrk,l) s @Ref2@(l)=j
 .f l="frame","flexible","down" s j=$$Atrib^LIBxml(Ret1,Wrk,l) i j s @Ref2@(l)=j
 .f l="font","trans","link" s j=$$Atrib^LIBxml(Ret1,Wrk,l) i j'="" s @Ref2@(l)=j
 .f k=1:1 s ID1=$$Atrib^LIBxml(Ret1_">item#"_k,Wrk,"id") q:ID1=""  d
 ..s Ret2=Ret1_">item#"_k,Ref2=$na(@Ref@("data",ID1))
 ..s @Ref2@("h")=$$Atrib^LIBxml(Ret2,Wrk,"height")
 ..s @Ref2@("w")=$$Atrib^LIBxml(Ret2,Wrk,"width")
 ..f l="type","name","x","y","value","frame","font","fontsize","align","valign","prefix","start","end","boxed","flexible","link","basex","basey" d
 ...s j=$$Atrib^LIBxml(Ret2,Wrk,l)
 ...i j'="" s @Ref2@(l)=j
 d Release^LIBxml(Wrk)
 q
 
SaveTemplate(Sou,Dest)
 n Ref,Ref2,i,j,k,l,m,Count
 k @Dest
 s Count=0
 d AddXMLline("<?xml version=""1.0"" encoding=""UTF-8""?>")
 d AddXMLline("<Template>")
 d AddXMLline("<header>")
 d AddXMLline("<name>"_$g(@Sou@("header","name"))_"</name>")
 d AddXMLline("</header>")
 i $d(@Sou@("const")) d
 .d AddXMLline("<const>")
 .s i="",j=0
 .f  s i=$o(@Sou@("const",i)) q:i=""  d
 ..s j=j+1
 ..s k="id="""_j_""" "
 ..s k=k_"name="""_i_""" "
 ..s k=k_"value="""_$g(@Sou@("const",i))_""" "
 ..d AddXMLline("<citem "_k_"/>")
 .d AddXMLline("</const>")
 i $d(@Sou@("transformations")) d
 .d AddXMLline("transformations")
 .s i=""
 .f  s i=$o(@Sou@("transformations",i)) q:i=""  d
 ..s Ref=$na(@Sou@("transformations",i))
 ..s k="id="""_i_""" "
 ..f m="type","name" s k=k_m_""""_$g(@Ref@("header",m))_""" "
 ..d AddXMLline("<trans "_k_">")
 ..i $d(@Ref@("data")) d
 ...s j=""
 ...f  s j=$o(@Ref@("data",j)) q:j=""  d
 ....s Ref2=$na(@Ref@("data",j))
 ....s k="id="""_j_""" "
 ....f m="type","name","source","op","arg1","arg2","arg3" s k=k_m_"="""_$g(@Ref2@(m))_""" "
 ....d AddXMLline("<titem "_k_"/>")
 ..d AddXMLline("</trans>")
 .d AddXMLline("/transformations")
 i $d(@Sou@("bands")) d
 .d AddXMLline("<bands>")
 .s i=""
 .f  s i=$o(@Sou@("bands",i)) q:i=""  d
 ..s Ref=$na(@Sou@("bands",i)),Ref2=$na(@Ref@("header"))
 ..s k="id="""_i_""" "
 ..f m="type","name" s k=k_m_"="""_$g(@Ref2@(m))_""" "
 ..s k=k_"height="""_$g(@Ref2@("h"))_""" "
 ..f m="frame","flexible","down" s l=+$g(@Ref2@(m)) i l s k=k_m_"="""_l_""" "
 ..f m="trans","link" s l=$g(@Ref2@(m)) i l'="" s k=k_m_"="""_l_""" "
 ..d AddXMLline("<band "_k_">")
 ..i $d(@Ref@("data")) d
 ...s j=""
 ...f  s j=$o(@Ref@("data",j)) q:j=""  d
 ....s Ref2=$na(@Ref@("data",j))
 ....s k="id="""_j_""" "
 ....f m="type","name","value","x","y" s l=$g(@Ref2@(m)) s k=k_m_"="""_l_""" "
 ....s k=k_"height="""_$g(@Ref2@("h"))_""" "
 ....s k=k_"width="""_$g(@Ref2@("w"))_""" "
 ....f m="font","fontsize","prefix","link","basex","basey" s l=$g(@Ref2@(m)) i l'="" s k=k_m_"="""_l_""" "
 ....f m="align","valign","start","end","frame","boxed","flexible" s l=+$g(@Ref2@(m)) i l s k=k_m_"="""_l_""" "
 ....d AddXMLline("<item "_k_"/>")
 ..d AddXMLline("</band>")
 .d AddXMLline("</bands>")
 
 d AddXMLline("</Template>")
 q
AddXMLline(%)   
 s Count=Count+1,@Dest@(Count)=%
 q
 
.
 ;;******** SYSTEM *******************
 ;Call TeX
CallTeX(Name)
 n Err,Ins,Dir,File
 s Dir="d:\Temp\bzu\Tex\",File=Dir_"RunTeX-"_$p($j,":")_".bat"
 ;Create BATCH file
 s Ins(1)="cd "_$p(Dir,":")_":",Ins(2)="cd "_Dir
 s Ins(3)=Dir_"bin\win32\pdfcsplain.exe -no-file-line-error -interaction=batchmode "_Dir_Name_".tex"
 s Err=$$LtF^LIBdatop("Ins",File,"",1)
 s Err=$zf(-1,File)
 ;s Err=$zf(-1,"d:\Temp\bzu\TeX\RunTeX.bat")
 ;s Err=$zf(-100,"/SHELL","D:\Temp\bzu\TeX\RunTeX.bat","")
 d dfile^LIBm(File)
 q Err
 
 ;;********** TESTING ************** 
.
 ;Test
Test
 n TeX,DataT,xDest,xTemp,Err,Ref,Ref1,Ref2,File
 s xDest="^bz",xTemp="^bzt",File="testik"
 ;Template for test
 s Err=$$FtL^LIBdatop("Sablona.xml",xDest)
 d LoadTemplate(xDest,xTemp)
 ;Data
 s DataT("POKUS")="Pokusnik"
 s DataT("POKUS","Uroven2")="Pokusnik druhy"
 ;Call to make TeX-source
 d MakeTeX^LIBprttex(xTemp,"DataT",xDest)
 ;Save to file
 s Err=$$LtF^LIBdatop(xDest,File_".tex","",1)
 k @xDest
 s Err=$$CallTeX(File)
 w Err,!
 q
  

LIBreport^INT^1^65016,54173.948403^0
LIBreport
 ;Report - make PDF from template
 ;Copyright Slavek Zmek, 2010
 ;Using HPDF* library
 
 ;One template - more data
MakePDFH(xTemp,xData,xDest)
 n PDF,i
 s PDF=$$New^HPDF()
 i PDF="" q
 s i=""
 f  s i=$o(@xData@(i)) q:i=""  d Add($na(@xData@(i)),xTemp)
 g Fin
 
 ;One template - one data
MakePDF(xTemp,xData,xDest)
 n PDF
 s PDF=$$New^HPDF()
 i PDF="" q
 d Add(xData,xTemp)
 
Fin
 n Err
 s Err=$$SaveToGlobal^HPDF(PDF,xDest)
 d Free^HPDF(PDF)
 q
 
 ;Add one step data-template
Add(Data,Temp)
 n font,page,band,bType,bHeader,bFooter,a,aTop,dFN,dPat,pgRef,i
 ;Initialize, first settings
 m a("con")=@Temp@("const")
 s i=""
 f  s i=$o(a("con",i)) q:i=""  i $e(a("con",i))="@" s a("con",i)=$$GetVal($p(a("con",i),"@",2))
 
 s i=$na(@Temp@("header"))
 s dFN=$$GetStr($g(@i@("font")))
 d FillNum(i,.a,"dWid:width,dHei:h,Ori:orient,FoS:fontsize")
 i dFN="" s dFN="Helvetica"
 i 'a("FoS") s a("FoS")=10
 i $d(@Temp@("script")) d Script
 s font=$$GetFont^HPDFfont(PDF,dFN,"CP1250")
 s page=$$Add^HPDFpage(PDF,.pgRef)
 i a("Ori") d SetSize^HPDFpages(pgRef,"A4",1)
 d SetFontAndSize^HPDFpage(pgRef,font,a("FoS"))
 i 'a("dWid") s a("dWid")=$$GetWidth^HPDFpage(pgRef)
 i 'a("dHei") s a("dHei")=$$GetHeight^HPDFpage(pgRef)
 s a("FN")=dFN
 s a("FS")=a("FoS")
 s (a("Beg"),a("Num"))=1
 s aTop=a("dHei")
 s dPat=0
 s (bHeader,bFooter)=""
 f i="Cont","C","THea","TFoo","PgT" s a(i)=""
 
 ;Loop over all bands
 s band=""
 f  s band=$o(@Temp@("bands",band)) q:band=""  d
 .i $g(@Temp@("bands",band,"header","ff")) d NewPage(band)
 .s bType=+$g(@Temp@("bands",band,"header","type"))
 .i 'bType d RegHea q
 .i bType=2 d RegFoo q
 .i bType=4 s a("THea")=band q
 .i bType=5 s a("TFoo")=band q
 .i a("Beg"),bHeader d WriteBand(bHeader) s a("Beg")=0
 .i bType=3 d WriteTable(band)
 .i bType'=3 d WriteBand(band)
 
 i bFooter s aTop=dPat d WriteBand(bFooter)
 i a("PgT")'="" d SetInternal^HPDFpage(PDF,a("PgT"),a("Num"))
 q
 
 ;Register headings band
RegHea
 n i
 s i=$g(@Temp@("bands",band,"header","page"))
 i i="" k bHeader s bHeader=band q
 s bHeader(i)=band
 i a("Beg"),a("Num")=i s bHeader=band
 q
.
 ;Register footer band
RegFoo
 s bFooter=band
 s dPat=$$GetNum($g(@Temp@("bands",band,"header","h")))
 q 
 
 ;Write band - standard
WriteBand(bnd)
 n bP,eP,d,x,x1,y,y1,value,i,iLoo
 d LoadB
 i '$$LinkB("") q
 i (aTop-bP("He"))<dPat,bnd'=bFooter d NewPage(bnd)
 i bP("C")'="" d FillB
 s d="",iLoo=0
 f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ElemB(d,"",1) d
 .i $e(eP("Na"),$l(eP("Na")))="%" s iLoo=1 q
 .d SetFont(0)
 .i eP("WW") d Split(eP("Na")) s eP("Fl")=1
 .;Type - what to do...
 .i eP("type")=0 d TText($s(eP("Fl"):eP("Na"),1:""),0) q
 .i eP("type")=1 d  q
 ..i eP("Na")'="" s value=$$GetVal(eP("Na"))
 ..d TText($s(eP("Fl"):eP("Na"),1:""),0)
 .i eP("type")=2 d TLine q
 .i eP("type")=3 d TRect q
 .i eP("type")=4 d TConst q
 .i eP("type")=5 d TJPG q
 .i eP("type")=6 d  q
 ..i eP("Na")'="" s value=$$GetVal(eP("Na"))
 ..d TBarCode
 .i eP("type")=7 d TCircle q
.
 i bP("Loo")'="",iLoo d Loop("")
 s aTop=aTop-bP("He")
 q
 
 ;Write band - cyclic(table)
WriteTable(bnd)
 n bP,eP,d,x,x1,y,y1,value,Idx,ev,tok,bDef,bGrp,eR,iLoo
 d Group
 i '$d(bGrp) q
 s tok=0
 s (Idx,bDef)=""
 f  s Idx=$o(@Data@(bP("Na"),Idx)) q:Idx=""  d
 .s ev=$g(@Data@(bP("Na"),Idx,"e"))
 .s eR=bP("Na")_"."_Idx
 .;Go through the group
 .s bnd=""
 .f  s bnd=$o(bGrp(bnd)) q:bnd=""  d
 ..i bnd'=bDef d LoadB s bDef=bnd
 ..i '$$LinkB(eR) q
 ..i (aTop-bP("He"))<dPat d NewPage(bnd) s tok=0
 ..i bP("C")'="" d FillB
 ..;Table's head
 ..i 'tok,a("THea")'="" d WriteBand(a("THea")) s tok=1
 ..s d="",iLoo=0
 ..f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ElemB(d,eR,0) d
 ...i $e(eP("Na"),$l(eP("Na")))="%" s iLoo=1 q
 ...d SetFont(ev)
 ...i eP("type")=2 d TLine q
 ...i eP("type")=3 d TRect q
 ...i eP("type")=1,eP("Na")'="" s value=$g(@Data@(bP("Na"),Idx,eP("Na")))
 ...d TText($s(eP("Fl"):eR_"."_eP("Na"),1:""),0)
 ..i bP("Loo")'="",iLoo d Loop(eR)
 ..s aTop=aTop-bP("He")
 
 i tok,a("TFoo")'="" d WriteBand(a("TFoo"))
 q
 
 ;Fill list of the band's group
Group
 n i,j,grp,Ok
 s j=$na(@Temp@("bands"))
 s bP("Na")=$g(@j@(bnd,"header","name"))
 i bP("Na")="" q
 s bGrp(bnd)=""
 s grp=$g(@j@(bnd,"header","group"))
 i grp="" q
 s i=bnd,Ok=1
 f  s i=$o(@j@(i)) q:i=""  d  q:'Ok
 .i $g(@j@(i,"header","name"))'=bP("Na") s Ok=0 q
 .i $g(@j@(i,"header","group"))'=grp s Ok=0 q
 .s band=i
 .s bGrp(i)=""
 q
 
 ;Load band's parameters
LoadB
 n ref
 s ref=$na(@Temp@("bands",bnd,"header"))
 d FillNum(ref,.bP,"He:h,BX:basex,BY:basey,Fl:flexible,FSi:fontsize")
 d FillStr(ref,.bP,"FNa:font,Loo:loop")
 d FillVal(ref,.bP,"Na:name,LI:link,C:rgb")
 i bP("FNa")="" s bP("FNa")=dFN
 i 'bP("FSi") s bP("FSi")=a("FoS")
 q
 
 ;Link of band
LinkB(%)
 n i,j
 i bP("LI")="" q 1
 s j=bP("LI")
 i %'="" s j=%_"."_j
 s i=$$Ref(j)
 i i="" q 0
 i '$d(@i) q 0
 i bP("Fl") d FlexB(%)
 i 'bP("He") q 0
 q 1
 
 ;Flexibility of band, height is set according to elements
FlexB(%)
 n i,j,d
 s bP("He")=0
 s d=""
 f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ElemB(d,%,1) d
 .s j=eP("Na")
 .i %'="" s j=%_"."_j i '$$DataVal(j) q
 .i eP("WW") d Split(j)
 .i eP("Fl") d
 ..s i="" f  s i=$$OrderVal(j,i) q:i=""  s y=y+y1
 ..i %'="" s y=y-y1
 .i y>bP("He") s bP("He")=y
 s bP("He")=bP("He")+bP("Fl")
 q
 
 ;Parameters of band's element
ElemB(%,%1,%2)
 n ref,link,i
 s ref=$na(@Temp@("bands",bnd,"data",%))
 s link=$g(@ref@("link"))
 i '%2,$e(link,$l(link))="%" s link=""
 i link'="" d  i 'i q 0
 .i $e(link)="%" s i=$$GetNum(link) q
 .i %1'="" s link=%1_"."_link
 .s i=$$DataVal(link)
 
 s eP("type")=+$g(@ref@("type"))
 d FillVal(ref,.eP,"Na:name,Cvt:convert,Cont:continue,Ev:onevent,Rm:rmode,Crlf:crlf,WW:wordwrap,C:rgb")
 d FillNum(ref,.eP,"BX:basex,BY:basey,Start:start,End:end")
 
 s x=$$GetNum($g(@ref@("x")))
 s y=$$GetNum($g(@ref@("y")))
 s x1=$$GetNum($g(@ref@("x1")))
 s y1=$$GetNum($g(@ref@("y1")))
 s eP("Fl")=$s(bP("Fl"):$g(@ref@("flexible")),1:0)
 s value=$$GetStr($g(@ref@("value")))
 i value="" s value=$g(@ref@("default"))
 q 1
.
 ;Fill band
FillB
 n i
 s i=$$GetRGBFill^HPDFpage(pgRef)
 d SetRGBFill^HPDFpage(pgRef,.5,.5,.5)
 d Rectangle^HPDFpage(pgRef,x,aTop,300,aTop-bP("He"))
 d FillStroke^HPDFpageo(pgRef)
 d SetRGBFill^HPDFpage(pgRef,$p(i,"#"),$p(i,"#",2),$p(i,"#",3))
 q
.
Loop(%)
 n l1,l2,l3,l4,l5
 s l1=$$GetNum($p(bP("Loo"),","))
 s l2=$$GetNum($p(bP("Loo"),",",2))
 s l3=$$GetNum($p(bP("Loo"),",",3))
 s d=""
 f  s d=$o(@Temp@("bands",bnd,"data",d)) q:d=""  i $$ElemB(d,%,0) d
 .s l5=eP("Na")
 .i $e(l5,$l(l5))'="%" q
 .s l5=$e(l5,1,$l(l5)-1)
 .d SetFont(0)
 .f l4=l1:1:l2 s eP("Na")=l5_l4 d  s x=x+l3,x1=x1+l3
 ..i '$$LinkL(d,%,l4) q
 ..s a("con","loop")=l4
 ..i eP("type")=0 d TText($s(eP("Fl"):eP("Na"),1:""),0) q
 ..i eP("type")=1 d  q
 ...i %="" d  q
 ....s value=$$GetVal(eP("Na"))
 ....d TText($s(eP("Fl"):eP("Na"),1:""),0)
 ...s value=$g(@Data@(bP("Na"),Idx,eP("Na")))
 ...d TText($s(eP("Fl"):%_Idx_"."_eP("Na"),1:""),0)
 ..i eP("type")=2 d TLine q
 ..i eP("type")=3 d TRect q
 ..i eP("type")=4 d TConst q
 ..i eP("type")=5 d TJPG q
 ..i eP("type")=6 d  q
 ...s value=$$GetVal(eP("Na"))
 ...d TBarCode
 ..i eP("type")=7 d TCircle q
 .s a("Cont")=""
 q
.
 ;Link in loop
LinkL(%,%1,%2)
 n ref,link
 s ref=$na(@Temp@("bands",bnd,"data",%))
 s link=$g(@ref@("link"))
 i $e(link,$l(link))'="%" q 1
 s link=$e(link,1,$l(link)-1)_%2
 i %1'="" s link=%1_"."_link
 q $$DataVal(link)
   
 ;Make reference
Ref(%)
 n i,j
 i %="" q ""
 i $f(Data,"(") s i=$p(Data,")")_","
 e  s i=Data_"("
 i '$f(%,".") s i=i_""""_%_""")"
 i $f(%,".") d
 .f j=1:1:$l(%,".") s i=i_""""_$p(%,".",j)_""","
 .s $e(i,$l(i))=")"
 q i
 
 ;Hodnota polozky
GetVal(x)
 n i
 s i=$$Ref(x)
 i i="" q ""
 q $g(@i)
 
 ;Test existence dat
DataVal(x)
 n i,j
 s i=$$Ref(x)
 i i="" q 0
 s j=$g(@i)
 i j'="" q 1
 q $d(@i)
 
 ;Order polozky
OrderVal(x,y)
 n i
 s i=$$Ref(x)
 i i="" q ""
 q $o(@i@(y))
 
 ;Set font of element in band
SetFont(%)
 n i,fS,fN
 s fN=$$GetStr($g(@Temp@("bands",bnd,"data",d,"font")))
 s fS=$$GetNum($g(@Temp@("bands",bnd,"data",d,"fontsize")))
 i fN="" s fN=bP("FNa")
 i 'fS s fS=bP("FSi")
 ;Change font according to event
 i %,eP("Ev"),$d(@Temp@("event",eP("Ev"))) d
 .s i=$$GetStr($g(@Temp@("event",eP("Ev"),"font")))
 .i i'="" s fN=i
 .s i=$$GetNum($g(@Temp@("event",eP("Ev"),"fontsize")))
 .i i s fS=i
 .s i=$g(@Temp@("event",eP("Ev"),"rgb"))
 .i i'="" s eP("C")=i
 ;Font change 
 i fN=a("FN"),fS=a("FS"),eP("C")=a("C") q
 i fN'=a("FN") s font=$$GetFont^HPDFfont(PDF,fN,"CP1250")
 d SetFontAndSize^HPDFpage(pgRef,font,fS)
 s a("FN")=fN
 s a("FS")=fS
 ;Color
 i eP("C")=a("C") q
 s a("C")=eP("C")
 i eP("C")="" d SetRGBFill^HPDFpage(pgRef,0,0,0) q
 d SetRGBFill^HPDFpage(pgRef,$p(eP("C"),"#"),$p(eP("C"),"#",2),$p(eP("C"),"#",3))
 q
 
 ;New page
NewPage(band)
 i bFooter,bFooter'=band s aTop=dPat d WriteBand(bFooter)
 
 s page=$$Add^HPDFpage(PDF,.pgRef)
 i a("Ori") d SetSize^HPDFpages(pgRef,"A4",1)
 d SetFontAndSize^HPDFpage(pgRef,font,a("FoS"))
 s a("Num")=a("Num")+1
 s aTop=a("dHei")
 i $d(bHeader(a("Num"))) s bHeader=bHeader(a("Num")) k bHeader(a("Num"))
 i bHeader,bHeader'=band d WriteBand(bHeader)
 q
 
 ;Line
TLine
 n i
 d SetLineWidth^HPDFpage(pgRef,$$GetWidth())
 s i=$g(@Temp@("bands",bnd,"data",d,"dash"))
 i i'="" d SetDash^HPDFpageo(pgRef,i,0)
 i a("Cont")'="" s x=a("Cont"),a("Cont")=""
 d MoveTo^HPDFpage(pgRef,x+bP("BX"),aTop-y-bP("BY"))
 d LineTo^HPDFpage(pgRef,x1+bP("BX"),aTop-y1-bP("BY"))
 d Stroke^HPDFpage(pgRef)
 i i'="" d SetDash^HPDFpageo(pgRef,"",0)
 q
 
 ;Text
TText(sub,mode)
 n align,i,j
 i a("Cont")'="" s x=a("Cont"),a("Cont")=""
 ;Truncate
 i eP("Start")!eP("End") d
 .i 'eP("Start") s eP("Start")=1
 .i 'eP("End") s eP("End")=$l(value)
 .s value=$e(value,eP("Start"),eP("End"))
 i eP("Cont")'="" d
 .s a("Cont")=x+eP("Cont")
 .i value'="" s a("Cont")=a("Cont")+$$TextWidth^HPDFpage(pgRef,value)
 i value="",sub="" q
 i eP("Cvt")'="",value'="" d Konvert
 s align=+$g(@Temp@("bands",bnd,"data",d,"align"))
 i eP("Rm") d SetTextRenderingMode^HPDFpage(pgRef,eP("Rm"))
 s j=0
 i value'="" d TText1(mode)
 ;Sub-elements
 i sub'="" d
 .i 'y1 s y1=bP("FSi")
 .s i=""
 .f  s i=$$OrderVal(sub,i) q:i=""  d
 ..i j s y=y+y1
 ..s value=$$GetVal(sub_"."_i)
 ..d TText1(mode)
 i eP("Rm") d SetTextRenderingMode^HPDFpage(pgRef,0)
 q
 
TText1(mode)
 n i,x2,y2
 s x2=x
 i align d TAlign
 s i=$$KtW^LIBchar(value)
 d BeginText^HPDFpage(pgRef)
 s x2=x2+bP("BX")+eP("BX"),y2=aTop-y-bP("BY")-eP("BY")
 i 'mode d
 .i align=3 d ChSp
 .d TextOut^HPDFpage(pgRef,x2,y2,i)
 .i align=3 d SetCharSpace^HPDFpage(pgRef,0)
 i mode d InternalOut^HPDFpage(pgRef,x2,y2,i)
 d EndText^HPDFpage(pgRef)
 s j=1
 q
 ;Char space - stretch for align=3
ChSp
 n rw,tmplen,chsp
 s tmplen=$$MeasureText^HPDFpage(pgRef,i,x1-x,1,.rw)
 s chsp=(x1-x-rw)/($l(i)-1)
 d SetCharSpace^HPDFpage(pgRef,chsp)
 q
 
 
 ;Text-alignment - move print-point
TAlign
 n i
 s i=$$TextWidth^HPDFpage(pgRef,$$KtX^LIBchar(value))
 i align=1 s x2=x1-i q
 i align=2 s x2=x+((x1-x-i)/2) q
 q
 
 ;Rectangle
TRect
 d SetLineWidth^HPDFpage(pgRef,$$GetWidth())
 d Rectangle^HPDFpage(pgRef,x+bP("BX"),aTop-y-bP("BY"),x1-x,y-y1)
 d Stroke^HPDFpage(pgRef)
 q
 
 ;Tisk specialni konstanty
TConst
 n i,j,k
 i value=4 d  q
 .s i=$$GetVal(eP("Na"))
 .i i'="" d TPict($na(^Uziv("ID",i,"PODPISO")),"@"_i)
 s i="",j=0,k=value
 i 'value s i=a("Num")
 i value=1 s i=$$HtD^SYSdati(+$h)
 i value=2 d
 .i a("PgT")="" d
 ..s j=1 f  q:'$d(@PDF@("icat","pgTotal"_j))  s j=j+1
 ..s a("PgT")="pgTotal"_j
 .s i=a("PgT"),j=1
 i value=3 s i=$$NOWR^SYSdati()
 i value=5 s i=$g(a("con","loop"))
 s value=i
 d TText("",j)
 s value=k
 q
.
 ;JPG-picture
TJPG
 n i,j
 s i=$na(@Temp@("image",value))
 i $g(@i@("source"))'="" s j=$na(^ALT("RES",@i@("source"),"S"))
 e  s j=$na(@i@("data"))
 i $d(@j) d TPict(j,$g(@i@("name")))
 q
 ;Picture
TPict(%,%1)
 n i
 s i=$$LoadJpeg^HPDFimage(PDF,%,%1)
 i i'="" d DrawImage^HPDFpageo(pgRef,i,x+bP("BX"),aTop-y-bP("BY"),x1,y1)
 q
 ;Barcode
TBarCode
 d Code128^HPDFbarc(pgRef,value,0,x,aTop-y,10,$$GetWidth())
 q
 ;Circle
TCircle
 d SetGrayStroke^HPDFpage(pgRef,0)
 d Circle^HPDFpageo(pgRef,x+bP("BX"),aTop-y-bP("BY"),x1)
 d Stroke^HPDFpage(pgRef)
 q
 
 ;Script
Script
 n sc,i,line,len,Ok
 s sc=$na(@Temp@("script"))
 s i="",Ok=0
 f  s i=$o(@sc@(i)) q:i=""  d  q:Ok
 .s line=@sc@(i),len=$l(line)
 .i $e(line,1,2)="IF" d IF q
 .i $e(line,1,4)="EXIT" s Ok=1 q
.
 q 
 ;Script-If
IF
 n type,Exp1,Exp2,i,j
 s type=0,j=3,len=$l(line)
 i $e(line,j)'="(" d  i type=-1 q
 .s type=-1
 .i $e(line,j)="L" s type=1
 .i $e(line,j)="G" s type=2
 .i $e(line,j)="N" s type=3
 .s j=j+1
 ;1.expression
 s j=j+1
 s Exp1=""
 f  q:j>len  q:$e(line,j)=","  q:$e(line,j)=")"  s Exp1=Exp1_$e(line,j),j=j+1
 s Exp1=$$GetVal(Exp1)
 ;2.expression
 i $e(line,j)'=")" s j=j+1
 s Exp2=""
 f  q:j>len  q:$e(line,j)=")"  s Exp2=Exp2_$e(line,j),j=j+1
 s j=j+1
 s line=$$trim^SYSutil($e(line,j,len)),j=1,len=$l(line)
 ;Compare
 s i=0
 i type=0,Exp1=Exp2 s i=1
 i type=1,Exp1<Exp2 s i=1
 i type=2,Exp1>Exp2 s i=1
 i type=3,Exp1'=Exp2 s i=1
 i 'i q
 ;Set
 s a("con",$p(line,"="))=$p(line,"=",2)
 q
.
 ;Konverze tisknute hodnoty
Konvert
 n i,j
 i eP("Cvt")=1 s value=$$lht^SYSutil(value) q
 i eP("Cvt")=2 d  q
 .s j=""
 .f i=1:1:$l(value) s j=j_$e(value,i)_" "
 .s value=$e(j,1,$l(j)-1)
 i eP("Cvt")=3 s value=$$KtX^LIBchar(value) q
 q
 
 ;Vraci sirku elementu, pro cary...
GetWidth()
 n i
 s i=$$GetNum($g(@Temp@("bands",bnd,"data",d,"width")))
 i 'i s i=0.5
 q i
  
 ;Rozdeli hodnotu na vice radku podle sirky
Split(%)
 n i,j,Poz,Del,Prev,val,Idx,width,rw,len
 s val=$$GetVal(%)
 i val="" q
 s width=$$GetNum($g(@Temp@("bands",bnd,"data",d,"width")))
 s i=$$Ref(%)
 i $d(@i)>9 q
 s Poz=1,(Del,Prev)=0,Idx=-1
 f  d  q:val=""  i 'Del s Poz=Poz+1 q:$l(val)<Poz
 .s Del=0
 .i " .,"'[$e(val,Poz) q
 .;Test rozdeleni
 .s j=$e(val,1,Poz)
 .s len=$$MeasureText^HPDFpage(pgRef,j,width,0,.rw)
 .i len=Poz s Prev=Poz q
 .;Preteceni
 .i 'Prev s Prev=Poz
 .;Zapis
 .s Idx=Idx+1
 .i Idx=0 s @i=$e(val,1,Prev)
 .i Idx>0 s @i@(Idx)=$e(val,1,Prev)
 .s val=$e(val,Prev+1,$l(val))
 .s (Poz,Del)=1,Prev=0
 
 i val'="" d
 .s Idx=Idx+1
 .i Idx=0 s @i=val q
 .s @i@(Idx)=val
 q
 
 ;Read value as number. Test - it could be constant...
GetNum(%)
 i $e(%)'="%" q +%
 s %=$e(%,2,$l(%))
 i %="" q 0
 i %["+" q +$g(a("con",$p(%,"+")))+$p(%,"+",2)
 i %["-" q +$g(a("con",$p(%,"-")))+$p(%,"-",2) 
 q +$g(a("con",%))
 ;Read value as string. Test - it could be constant...
GetStr(%)
 i $e(%)'="%" d  q %
 .i $e(%,1,2)="\%" s %=$e(%,2,$l(%))
 s %=$e(%,2,$l(%))
 i %="" q ""
 q $g(a("con",%))
 ;Fill values
FillVal(%Ref,%Sou,%Data)
 n i,j
 f i=1:1:$l(%Data,",") s j=$p(%Data,",",i) i j'="" s %Sou($p(j,":"))=$g(@%Ref@($p(j,":",2)))
 q
 ;Fill numeric-values
FillNum(%Ref,%Sou,%Data)
 n i,j
 f i=1:1:$l(%Data,",") s j=$p(%Data,",",i) i j'="" s %Sou($p(j,":"))=$$GetNum($g(@%Ref@($p(j,":",2))))
 q
 ;Fill string-values
FillStr(%Ref,%Sou,%Data)
 n i,j
 f i=1:1:$l(%Data,",") s j=$p(%Data,",",i) i j'="" s %Sou($p(j,":"))=$$GetStr($g(@%Ref@($p(j,":",2))))
 q 

LIBrest^INT^1^65149,31176.969014^0
LIBrest
 ;Communication server - REST - Answering
 ;Copyright Slavek Zmek, 2018
 
 ;Starting point
GO
 n Err,Txt,Tags,Pars,Hea,HeaA,Ans,Ok,OkL,Rou,IdR,Type,IdJ,xRJou,Format,TokID,xUSER,xUSERID,xIP,xROLE,GbJ,Nsp
 s $zt=$$SetZT^LIBm("err^LIBrest")
 s Err=200,(Ok,Type)=0,(TokID,xUSER,xUSERID)=""
 m Hea=head
 s Hea("REQ","IP")=$p($g(Hea("X-Forwarded-For")),":")
 i Hea("REQ","IP")="" s Hea("REQ","IP")="???"
 d TrimURL^LIBrestu(Hea("REQ","URL"),"Tags","Pars")
 i $p($g(Hea("Content-Type")),";")="application/json" s GbJ=$$GetJSONtmp^LIBrestu()
 ;Access rights, token,...
 s Rou=$g(^XMAloc("T","AUTH"))
 i Rou'="" d @Rou i Err'=200 g GO2
 ;Flag - journal
 s xRJou=1
 i xRJou s IdJ=$$Journal^LIBrestu()
 
 ;Analyzing URL, routing,....
 s OkL=$$Route(.Rou,.IdR,.Nsp)
 i OkL d TryIt(Rou,Nsp)
 i 'OkL d
 .s Ok=0
 .s Rou=$g(^XMAloc("T","ROUTEL"))
 .i Rou'="" d TryIt(Rou)
GO2 
 i 'Ok d Bad
GO1
 i Type=0 d
 .i '$d(Format) d EncodeX^LIBjson("Ans",GbR) q
 .d EncodeX^LIBjson("Ans",GbR,"","Format")
 d FillHead^LIBrestu
 i $g(xRJou) m @IdJ@("R")=@GbR
 i $g(GbJ)'="" k @GbJ
 q
.
 ;Err
err
 s Err=500
 d WE^LIBerr("REST","REST")
 d FillHead^LIBrestu
 i $g(GbJ)'="" k @GbJ
 q
 
 ;Maybe routine - try it....
TryIt(%,%1)
 n Nspold
 s $zt=$$SetZT^LIBm("TryItE^LIBrest")
 i $g(%1)'="" s Nspold=$$GetNSP^LIBm zn %1
 d @%
 i $g(Nspold)'="" zn Nspold
 s Ok=1
 q 
 
TryItE
 d WE^LIBerr("REST","REST")
 i $g(Nspold)'="" zn Nspold
 s Ok=0
 q
 
 
 ;Analyzing URL, routing
Route(Rou,Idx,Nsp)
 n i,j,k,l,m,Ok,OkL,cou
 i 'Tags q 0
 s Ok=0
 s i=""
 f  s i=$o(^XMAloc("T","ROUTE",i)) q:i=""  d  q:Ok
 .s j=$g(^XMAloc("T","ROUTE",i,"R"))
 .i j="" q
 .;Method
 .i $p(j,"|")'="",$p(j,"|")'=$g(Hea("REQ","MET")) q
 .;Number of tags
 .i $p(j,"|",2)'="",$p(j,"|",2)'=Tags q
 .;Tag equal to const
 .i $p(j,"|",3)'="" d  i 'OkL q
 ..s k=$p(j,"|",3),OkL=1
 ..f l=1:1:$l(k,"&") s m=$p(k,"&",l) i m'="" d  q:'OkL
 ...s cou=$p(m,":")
 ...i cou="" q
 ...i $e(cou)="*" s cou=$replace(cou,"*",Tags) s @("cou="_cou)
 ...i $g(Tags(cou))'=$p(m,":",2) s OkL=0
 .;OK - GO!!!!
 .s j=$g(^XMAloc("T","ROUTE",i,"X"))
 .i j="" q
 .s Rou=j
 .s Idx=i
 .s Nsp=$g(^XMAloc("T","ROUTE",i,"NSP"))
 .s Ok=1
 q Ok
.
 ;Bad - no service
Bad
 k Ans
 s Ans("Txt")=$g(Txt)
 i Ans("Txt")="" s Ans("Txt")="No service !"
 s Ans("URL")=Hea("REQ","URL")
 i Err=200 s Err=400
 s Ans("Err")=Err
 q
.
.

LIBrestqa^INT^1^64974,51803.814667^0
LIBrestqa
 ;Communication server - REST - Q&A
 ;Copyright Slavek Zmek, 2018
 
 ;Place       : In temporary global ^Zrestqa($j) or could be user-defined
 ;Structures  : 
 ;        Common settings   - "Sett" : "Server" - server's IP 
 ;                                     "Port"   - server's port 
 ;                                     "Token"  - token for authorization
 ;                                     "Name"   - name of testsuite
 ;                                     "User"   - user (to get token)
 ;                                     "Pass"   - password (to get token)
 ;        Predefined values - "Values"
 ;        Test settings     - "Tests". Next level is ID. Fields are of two categories - input (parameters to run test) and output(results filled by test) 
 ;                              Fields:(I) "Name"     - Test's name
 ;                                         "URL"      - URL of service
 ;                                         "Method"   - method (GET, POST)
 ;                                         "Https"    - https flag
 ;                                         "Request"  - request  (tree)
 ;                                         "FillVar"  - fill variables (analyze response)
 ;                                         "Repeat"   - number of cycles of test. If not set it will run only once.
 ;                                         "OnError"  - continuation flag after error: -1 - stopped testing
 ;                                                                                     >0 - jump to test with this Id
 ;                                                                                     else continue with next test  
 ;                                         "Check"    - check-tree (check response)
 ;                                         "CheckMode"- check mode (1-compare tree, 2-compare values, else-no check)
 ;                                     (O) "Response" - response (tree)
 ;                                         "Result"   - result - receive phase (0-OK, 1-error)
 ;                                         "ResultE"  - result-error
 ;                                         "ResultC"  - result - check phase (0-OK, 1-error)
 ;                                         "RunStart" - datetime (horolog-format) - start test
 ;                                         "RunEnd"   - datetime (horolog-format) - end test
 ;
 ;Procedures and functions with TestSuite:
 ;                      CreateSuite - create test suite. Parameter is name, it returns temporary global with testsuite.
 ;                      LoadSuite   - load test suite from file
 ;                      SaveSuite   - save test suite to file
 ;Procedures and functions:
 ;                      SetParams   - set setting for all tests (Server,.....)
 ;                      SetValues   - set predefined values
 ;                      DeleteValue - delete predefined value
 ;                      AddTest     - add test
 ;                      ModifyTest  - modify test params
 ;                      DeleteTest  - delete test
 ;                      ListTests   - list all tests (settings, params,.....)
 ;                      ListResults - list results of all tests
 ;                      RunAllTests - run all tests
 ;                      RunOneTest  - run one test
 ;                      GetResponse - get response from with in JSON-string format 
 ;
 
 ;Create TestSuite
CreateSuite(Name)
 n Gbl,Id
 s Id=$zp(^Zrestqa($j,""))+1
 s Gbl=$na(^Zrestqa($j,Id))
 s @Gbl@("Sett","Name")=Name
 q Gbl
 
 ;Load TestSuite
LoadSuite(file,Suite)
 n Gbl,Err
 s Gbl=$na(^Zexpts($j))
 k @Gbl
 d TtL^LIBdatop(Suite,Gbl)
 s Err=$$LtF^LIBdatop(Gbl,file,0,1)
 k @Gbl
 q
 
 ;Save TestSuite
SaveSuite(Suite,file)
 n Gbl,Err
 s Gbl=$na(^Zexpts($j))
 k @Gbl
 s Err=$$FtL^LIBdatop(file,Gbl)
 d LtT^LIBdatop(Gbl,Suite)
 q  
 
 ;Setting parameters. Pars - field with params, called by reference (dot-syntax), it could be set partially
SetParams(Suite,Pars)
 n Ref,i
 s Ref=$na(@Suite@("Sett")) 
 f i="Server","Port","Token","Name","User","Pass" i $d(Pars(i)) s @Ref@(i)=Pars(i)
 q
 
 ;Setting values. Pars - field with values, called by reference (dot-syntax), it could be set partially
SetValues(Suite,Pars)
 n Ref,i
 s Ref=$na(@Suite@("Values")) 
 s i=""
 f  s i=$o(Pars(i)) q:i=""  s @Ref@(i)=Pars(i)
 q
 
 ;Delete value
DeleteValue(Suite,Name)
 k @Suite@("Values",Name)
 q
 
 ;Add test. Pars - field with params, called by reference (dot-syntax), it could be set partially
AddTest(Suite,Pars)
 n Id,Ref,i
 s Id=$zp(@Suite@("Tests",""))+1
 g SetTestI
 
 ;Modify test. Pars - field with params, called by reference (dot-syntax), it could be set partially
ModifyTest(Suite,%,Pars)
 n Id,Ref,i
 i '$d(@Suite@("Tests",%)) q
 s Id=%
 
 ;Set params for Test - internal procedure
SetTestI
 s Ref=$na(@Suite@("Tests",Id))
 f i="Name","URL","Method","Https","OnError","Repeat","CheckMode" d
 .i $d(Pars(i)) s @Ref@(i)=Pars(i)
 f i="Request","FillVar","Check" i $d(Pars(i)) d
 .k @Ref@(i)
 .d Decode^LIBjson(Pars(i),$na(@Ref@(i)))
 q
  
 ;Delete test
DeleteTest(Suite,%)
 i $d(@Suite@("Tests",%)) k @Suite@("Tests",%)
 q
  
 ;List of test and settings
ListTests(Suite)
 n Ref,RefT,i,j
 d ListHea
 w $j("",2),"Tests:",!
 s i=""
 f  s i=$o(@Suite@("Tests",i)) q:i=""  d 
 .s RefT=$na(@Suite@("Tests",i))
 .s j=$j("",2)_"ID: "_i_", Name: "_$g(@RefT@("Name"))_", URL: "_$g(@RefT@("URL"))
 .s j=j_", method: "_$g(@RefT@("Method"))_", HTTPS: "_$s($g(@RefT@("Https")):"YES",1:"NO")
 .i $g(@RefT@("OnError"))'="" s j=j_" ,OnError: "_$g(@RefT@("OnError"))
 .i $g(@RefT@("Repeat"))'="" s j=j_" ,repeat: "_$g(@RefT@("Repeat"))
 .w j,!
 q
 
 ;List of Results 
ListResults(Suite)
 n i,j,Err
 d ListHea
 w "Results of tests:",!
 s i=""
 f  s i=$o(@Suite@("Tests",i)) q:i=""  d 
 .s RefT=$na(@Suite@("Tests",i))
 .s j=$j("",2)_"ID: "_i_", Name: "_$g(@RefT@("Name"))_", URL: "_$g(@RefT@("URL"))
 .s j=j_" Result: "
 .s Err=$g(@RefT@("Result"))
 .i 'Err s j=j_"OK"
 .i Err s j=j_"ERROR"
 .w j,!
 .i Err w $j("",4),$g(@RefT@("ResultE")),!
 q
 
 ;List - header
ListHea
 n Ref,i,j
 s Ref=$na(@Suite@("Sett")) 
 w "Test suite: ",$g(@Ref@("Name")),$j("",10),"Place: ",Suite,!
 w $j("",2),"Server ",$g(@Ref@("Server")),",  port ",$g(@Ref@("Port")),", token: ",$s($g(@Ref@("Token"))'="":"YES",1:"NO"),!
 w $j("",2),"Values: "
 s Ref=$na(@Suite@("Values")),j=0
 s i="" f  s i=$o(@Ref@(i)) q:i=""  w:j $j("",10) w @Ref@(i)," -> ",i,! s j=1
 w !
 q 
.
 ;Get response in JSO-string format 
GetResponse(Suite,Test)
 n Ref
 s Ref=$na(@Suite@("Tests",Test))
 q $$Encode^LIBjson($na(@Ref@("Response")))
 
 ;Run all tests
RunAllTests(Suite)
 n Id,Fine,Res,OnE,i,Cyc,Ref
 ;Initializaton
 s Id=""
 f  s Id=$o(@Suite@("Tests",Id)) q:Id=""  d
 .f i="Result","ResultE","ResultC","Response","RunStart","RunEnd" k @Suite@("Tests",Id,i)
 ;Run tests
 s Id=$o(@Suite@("Tests","")),(Fine,Cyc)=0
 i Id="" s Fine=1
 w "START",!
 f  q:Fine  d
 .s Ref=$na(@Suite@("Tests",Id))
 .w "Test: ",$g(@Ref@("Name")),"..."
 .i 'Cyc s Cyc=+$g(@Ref@("Repeat"))
 .d RunOneTest(Suite,Id)
 .i Cyc w "step ",Cyc,"..." s Cyc=Cyc-1
 .s Res=+$g(@Ref@("Result"))
 .i 'Res d
 ..w "OK"
 ..i $g(@Ref@("CheckMode")) w " CHECK: ",$s('$g(@Ref@("ResultC")):"OK",1:"ERROR")
 ..i 'Cyc s Id=$o(@Suite@("Tests",Id))
 .i Res d
 ..w "ERROR"
 ..s OnE=+$g(@Ref@("OnError"))
 ..i OnE=-1 w " testing stopped!" s Fine=1 q
 ..i OnE,$d(@Suite@("Tests",OnE)) w " JUMP to another test" s Id=OnE q
 ..s Id=$o(@Suite@("Tests",Id))
 .w !
 .i Id="" s Fine=1
 w "STOP",!
 q
 
 ;Run one test
RunOneTest(Suite,%)
 n SC,Ref,RefT,RE,REQ,i,Data
 s Ref=$na(@Suite@("Sett")) 
 s RefT=$na(@Suite@("Tests",%)) 
 f i="Response","ResultE" k @RefT@(i)
 s REQ=""
 i $d(@RefT@("Request")) d
 .m Data=@RefT@("Request")
 .d Substitute("Data")
 .s REQ=$$Encode^LIBjson("Data")
 s @RefT@("RunStart")=$now()
 s SC=$$CallREST^LIBwww($g(@RefT@("URL")),.RE,$g(@RefT@("Method")),$g(@Ref@("Server")),$g(@Ref@("Port")),REQ,+$g(@RefT@("Https")),$g(@Ref@("Token")))
 s @RefT@("RunEnd")=$now()
 i 'SC s @RefT@("Result")=1,@RefT@("ResultE")=SC q
 ; OK - Continuing with action
 s @RefT@("Result")=0
 d Decode^LIBjson(RE,$na(@RefT@("Response")))
 i $d(@RefT@("FillVar")) d FillVar
 ; Check
 i $g(@RefT@("CheckMode")) d CheckResp
 q
 
 ;Substitute values
Substitute(Ref)
 n i,j,End
 s i=Ref,End=$e(Ref,1,$l(Ref)-1)
 f  s i=$q(@i) q:i=""  q:i'[End  d
 .s j=$g(@i)
 .i $e(j)'="%" q
 .s j=$e(j,2,$l(j))
 .i j="" q
 .i $d(@Suite@("Values",j)) s @i=@Suite@("Values",j)
 
 q
 
 ;Fill variables from test's response
FillVar
 n i,j,End,RefD
 s i=$na(@RefT@("FillVar"))
 s RefD=$na(@RefT@("Response")),RefD=$e(RefD,1,$l(RefD)-1)
 s End=$e(i,1,$l(i)-1)
 f  s i=$q(@i) q:i=""  q:i'[End  d
 .s j=RefD_$e(i,$l(End)+1,$l(i))
 .i $d(@j)#2 s @Suite@("Values",@i)=@j
 q
.
 ;Check response
CheckResp
 n Err,Out,ChM,i,RefD,End
 s ChM=$g(@RefT@("CheckMode"))
 ;Compare trees
 i ChM=1 d  q
 .s Err=$$TreeCmp^LIBdatop($na(@RefT@("Response")),$na(@RefT@("Check")),"Out")
 .i 'Err s @RefT@("ResultC")=0
 .e  s @RefT@("ResultC")=1
 ;Compare values
 i ChM=2 d  q
 .s i=$na(@RefT@("Check")),Err=0
 .s RefD=$na(@RefT@("Response")),RefD=$e(RefD,1,$l(RefD)-1)
 .s End=$e(i,1,$l(i)-1)
 .f  s i=$q(@i) q:i=""  q:i'[End  d  q:Err
 ..s j=RefD_$e(i,$l(End)+1,$l(i))
 ..i $g(@j)'=$g(@i) s Err=1
 .i 'Err s @RefT@("ResultC")=0
 .e  s @RefT@("ResultC")=1
 q

LIBrestu^INT^1^65149,33404.328013^0
LIBrestu
 ;Communication server - REST - Answering - utilities
 ;Copyright Slavek Zmek, 2018
.
 ;Fill head
FillHead
 n i,j
 k head
 ;OWN HEAD
 i Type>1000 m head=HeaA q
 ;OTHER HEAD
 s j=0
 i Err=200 s Err=Err_" OK"
 d AddHea("HTTP/1.1 "_Err)
 ;REST
 i Type<10 d
 .d AddHea("Date:"_$h)
 .d AddHea("Content-Type: application/json")
 .d AddHea("Content-Length: "_$$CalcLEN)
 .d AddHea("Content-Encoding: identity")
 .i '$d(HeaA) q
 .s i="" f  s i=$o(HeaA(i)) q:i=""  d AddHea(HeaA(i))
 ;SOAP
 i Type>10 d
 .d AddHea("Cache-Control: no-cache")
 .d AddHea("Pragma: no-cache")
 .d AddHea("Content-Length: "_$$CalcLEN)
 .d AddHea("Content-Type: text/xml; charset=UTF-8")
 .d AddHea("Content-Encoding: identity")
 .d AddHea("Expires: Thu, 29 Oct 1998 17:04:19 GMT")
 .d AddHea("Server: Microsoft-IIS/8.5")
 .d AddHea("X-Powered-By: ASP.NET")
 .d AddHea("Date: Thu, "_$zd(+$h,2)_" 06:59:53 GMT")
 
 q
 
 ;Add head's item
AddHea(%)
 s j=j+1,head(j)=%
 q
   
 ;Trim URL into fields
TrimURL(%,%1,%2)
 n i,j,k
 k @%1
 i $g(%2)'="" k @%2
 ;Delete protocol and server
 i $f(%,"//") s %=$p(%,"//",2)
 i $e(%)="/" s %=$e(%,2,$l(%))
 s @%1=$l(%,"/")
 f i=1:1:$l(%,"/") s @%1@(i)=$p(%,"/",i)
 f  q:'@%1  q:@%1@(@%1)'=""  k @%1@(@%1) s @%1=@%1-1
 s i=""
 i @%1 d
 .s i=@%1@(@%1)
 .s j=$p(i,"?",2),@%1@(@%1)=$p(i,"?")
 .i j="" q
 .f i=1:1:$l(j,"&") s k=$p(j,"&",i) i $p(k,"=")'="" s @%2@($p(k,"="))=$p(k,"=",2)
 q
 
 ;Calculate length of answer
CalcLEN()
 n i,j
 s i="",j=0
 f  s i=$o(@GbR@(i)) q:i=""  s k=$zcvt(@GbR@(i),"O","UTF8"),j=j+$l(k),@GbR@(i)=k
 q j
 
 ;SOAP - write XML tag with value
WriTag(%,%1)
 d Wri("<"_%_">"_%1_"</"_%_">")
 q
 
 ;Write data
Wri(%)
 s Cou=Cou+1,@GbR@(Cou)=%
 q
 
 ;Write data with LF
WriLF(%)
 s Cou=Cou+1,@GbR@(Cou)=%_$c(13,10)
 q
 
 ; Fill header with errcode+errtxt
FillHeaErr(%,%1,%2)
 s Ans("header","errcode")=%
 s Ans("header","errtxt")=%1
 i $g(%2) s Ans("header","errshowok")=1
 q
.
 ;JSON response - OK
MakeOK
 d FillHeaErr(0,"OK")
 q
.
 ;JSON posilany nazpet - seznam chyb v poli Txt
MakeErr
 n i,j
 d MakeErrT("Chyby p?i ulo?ení")
 s i="",j=0
 f  s i=$o(Txt(i)) q:i=""  s j=j+1,Ans("data",j,"text")=Txt(i)
 s Format("data")=1 
 q
.
 ;JSON posilany nazpet - text chyby v promenne %
MakeErrT(%)
 d FillHeaErr(1,%)
 q
 
 ;Doplneny JSONa posilaneho nazpet o chyby nasledneho Requestu
MakeReqErr(Err,Txt,Action,Data)
 n i,Ref
 s Ref=$na(Ans("header","request"))
 s @Ref@("errcode")=Err
 s @Ref@("errtxt")=Txt
 i $g(Action)'="" d
 .s @Ref@("action","url")=Action
 .s @Ref@("action","page")="form"
 .s i=""
 .f  s i=$o(@Data@(i)) q:i=""  s @Ref@("action","data",i)=@Data@(i)
 q
.
 ;Temporary global. Received JSON (@GbD) is unpacked into this global
GetJSONtmp()
 n i
 s i=$na(^Zjson($j))
 k @i
 d DecodeX^LIBjson(GbD,i)
 q i
 
 ;Fill logged user via token
SetUser(%)
 n i,j,Ref
 i %="" s (xUSERID,xUSER)="" q
 s xUSERID=$g(^XMAloc("AUTH",%,"I","user_id"))
 i xUSERID="" s xUSER="" q
 s Ref=$na(^XCIS("EMPLOYEES",xUSERID))
 s xUSER=$g(@Ref@("JmenoCele"))
 ;Role, kompetence,...
 k xROLE
 m xROLE=@Ref@("Role")
 q
 
 ;*********  Route  **************
ListRoute
 n i,j,k,l,m
 ;Headline
 w "ROUTE LIST",!
 w "#",?4,"Method",?12,"Par's count",?25,"Par's condition",?62,"Routine"
 w !
 s i=""
 f  s i=$o(^XMAloc("T","ROUTE",i)) q:i=""  d
 .w i," "
 .s k=$g(^XMAloc("T","ROUTE",i,"R"))
 .s l=$p(k,"|")
 .i l="" s l="ALL"
 .w ?5,l
 .s l=$p(k,"|",2)
 .i l="" s l="ALL"
 .w ?12,l
 .s l=$p(k,"|",3)
 .i l="" s l="NONE"
 .w ?20,l," "
 .s l=$g(^XMAloc("T","ROUTE",i,"X"))
 .s m=$g(^XMAloc("T","ROUTE",i,"NSP"))
 .i m'="" s m="(nsp."_m_")"
 .w ?60,l,m
 .w !
 q 
 
 ;Add item into routing table. Parameters: Rule  - rule to evaluate
 ;                                         Rou   - executed routine 
 ;                                         Place - index. Optional. If it is not set, position is at the end.
 ;                                                                  Otherwise rules are spread to have exact index.
 ;                                         Nsp   - namespace. Optional.
AddRoute(Rule,Rou,Place,Nsp)
 n i
 ;Spread
 i $g(Place)'="",$d(^XMAloc("T","ROUTE",Place)) d
 .s i=$zp(^XMAloc("T","ROUTE",""))
 .f  d  q:i=Place  s i=$zp(^XMAloc("T","ROUTE",i))
 ..m ^XMAloc("T","ROUTE",i+1)=^XMAloc("T","ROUTE",i)
 ..k ^XMAloc("T","ROUTE",i)
 i $g(Place)="" s Place=$zp(^XMAloc("T","ROUTE",""))+1
 s ^XMAloc("T","ROUTE",Place,"R")=Rule
 s ^XMAloc("T","ROUTE",Place,"X")=Rou
 i $g(Nsp)'="" s ^XMAloc("T","ROUTE",Place,"NSP")=Nsp
 q
 
 ;Move item to different place
MoveRoute(From,To)
 n Rule,Rou,Nsp
 i '$d(^XMAloc("T","ROUTE",From)) q
 s Rule=^XMAloc("T","ROUTE",From,"R")
 s Rou=^XMAloc("T","ROUTE",From,"X")
 s Nsp=^XMAloc("T","ROUTE",From,"NSP")
 d DeleteRoute(From)
 d AddRoute(Rule,Rou,To,Nsp)
 q
 
 ;Delete route
DeleteRoute(Place)
 k ^XMAloc("T","ROUTE",Place)
 q
 
 ;Compact route table
CompactRoute
 n i,j
 s i="",j=0
 f  s i=$o(^XMAloc("T","ROUTE",i)) q:i=""  d
 .s j=j+1
 .i i'=j,'$d(^XMAloc("T","ROUTE",j)) d MoveRoute(i,j)
 q
 
 ;Check route - URL
CheckRoute(URL,Meth)
 n Tags,Pars,Hea,Ok,Rou,Idx,Nsp
 s Hea("REQ","URL")=URL
 s Hea("REQ","MET")=$g(Meth)
 d TrimURL(Hea("REQ","URL"),"Tags","Pars")
 s Ok=$$Route^LIBrest(.Rou,.Idx,.Nsp)
 q Ok_"|"_$g(Idx)_"|"_$g(Rou)_"|"_$g(Nsp)
.
 ;********* Journal ***************
.
 ;Journaled data
Journal()
 n Ref,Ref1,horolog,id 
 ;Place where journaling
 s horolog=$h
 s Ref=$na(^Zrestj("J",$j,horolog)),id=$$GetUniq^LIButil(Ref)
 ;Save data
 s Ref1=$na(@Ref@(id))
 m @Ref1@("H")=Hea
 m @Ref1@("A")=@GbD
 m @Ref1@("P")=Pars
 s @Ref1@("T")=TokID
 ;Indexes
 s ^Zrestj("I",horolog,horolog,$j,id)=""
 s ^Zrestj("IM",Hea("REQ","URL"),horolog,$j,id)=""
 s ^Zrestj("IIP",Hea("REQ","IP"),horolog,$j,id)=""
 i TokID'="" s ^Zrestj("IT",TokID,horolog,$j,id)=""
 l -@Ref1
 q Ref1
 
 ;Make indexes
MakeIndex
 n i,horolog,job,id
 f i="I","IM","IIP","IT" k ^Zrestj(i)
 s job=""
 f  s job=$zp(^Zrestj("J",job)) q:job=""  d
 .s horolog=""
 .f  s horolog=$zp(^Zrestj("J",job,horolog)) q:horolog=""  d
 ..s id=""
 ..f  s id=$zp(^Zrestj("J",job,horolog,id)) q:id=""  d
 ...s ^Zrestj("I",horolog,horolog,job,id)=""
 ...s i=$g(^Zrestj("J",job,horolog,id,"H","REQ","URL"))
 ...i i'="" s ^Zrestj("IM",i,horolog,job,id)=""
 ...s i=$g(^Zrestj("J",job,horolog,id,"H","REQ","IP"))
 ...i i'="" s ^Zrestj("IIP",i,horolog,job,id)=""
 ...s i=$$GetTokenID^appsysAUTH($g(^Zrestj("J",job,horolog,id,"H","Authorization")))
 ...i i'="" s ^Zrestj("IT",i,horolog,job,id)=""
 q
 
 ;Clean journaled data. Parameter: how many days back
Clean(%)
 n int,horolog,horolog2,job,id,TokID,Ref,URL,IP
 s int=+$g(%)
 i 'int s int=1
 s horolog=($h-int)_",99999"
 f  s horolog=$zp(^Zrestj("I",horolog)) q:horolog=""  d
 .s horolog2=""
 .f  s horolog2=$zp(^Zrestj("I",horolog,horolog2)) q:horolog2=""  d
 ..s job=""
 ..f  s job=$zp(^Zrestj("I",horolog,horolog2,job)) q:job=""  d
 ...s id=""
 ...f  s id=$zp(^Zrestj("I",horolog,horolog2,job,id)) q:id=""  d
 ....s Ref=$na(^Zrestj("J",job,horolog,id,"H"))
 ....s TokID=$$GetTokenID^appsysAUTH($g(@Ref@("Authorization")))
 ....i TokID'="" k ^Zrestj("IT",TokID,horolog,job,id)
 ....s URL=$g(@Ref@("REQ","URL"))
 ....i URL'="" k ^Zrestj("IM",URL,horolog,job,id)
 ....s IP=$g(@Ref@("REQ","IP"))
 ....i IP'="" k ^Zrestj("IIP",IP,horolog,job,id)
 ....k ^Zrestj("I",horolog,horolog2,job,id)
 ....k ^Zrestj("J",job,horolog,id)
 ;Projeti vsech jestli maji existujici token
 s TokID=""
 f  s TokID=$o(^Zrestj("IT",TokID)) q:TokID=""  i '$d(^XMAloc("AUTH",TokID)) k ^Zrestj("IT",TokID)
 ;Pri chybach - vycisteni indexu, ktere se nikam neodkazuji
 s URL=""
 f  s URL=$o(^Zrestj("IM",URL)) q:URL=""  d
 .s horolog=""
 .f  s horolog=$o(^Zrestj("IM",URL,horolog)) q:horolog=""  d
 ..s job=""
 ..f  s job=$o(^Zrestj("IM",URL,horolog,job)) q:job=""  i '$d(^Zrestj("J",job,horolog)) k ^Zrestj("IM",URL,horolog,job)
 s IP=""
 f  s IP=$o(^Zrestj("IIP",IP)) q:IP=""  d
 .s horolog=""
 .f  s horolog=$o(^Zrestj("IIP",IP,horolog)) q:horolog=""  d
 ..s job=""
 ..f  s job=$o(^Zrestj("IIP",IP,horolog,job)) q:job=""  i '$d(^Zrestj("J",job,horolog)) k ^Zrestj("IIP",IP,horolog,job)
 s TokID=""
 f  s TokID=$o(^Zrestj("IT",TokID)) q:TokID=""  d
 .s horolog=""
 .f  s horolog=$o(^Zrestj("IT",TokID,horolog)) q:horolog=""  d
 ..s job=""
 ..f  s job=$o(^Zrestj("IT",TokID,horolog,job)) q:job=""  i '$d(^Zrestj("J",job,horolog)) k ^Zrestj("IT",TokID,horolog,job)
 q
.
 ;Hard clean journaled data. Parameter: how many days back. Without using index. Clean, and then rebuild indexes 
HardClean(%)
 n int,ref,job,horolog
 s int=+$g(%)
 i 'int s int=1
 s ref=($h-int)_",0"
 w ref,!
 s job=""
 f  s job=$o(^Zrestj("J",job)) q:job=""  d
 .s horolog=ref
 .f  s horolog=$zp(^Zrestj("J",job,horolog)) q:horolog=""  d
 ..k ^Zrestj("J",job,horolog)
 d MakeIndex
 q
 
 ;List journal. Field % optional, called as reference (dot), values:
 ;                                  Count   - number of records
 ;                                  Order   - index to order: H(horolog, default),T(token),IP(IPadress),URL(requested URL)
 ;                                  Flag    - detailed report, values: Q(request),R(response),RQ(both)
 ;                                  OneRest - only one REST (value is its number) reported as detailed
 ;                                  Value   - list of RESTS with this value in index
ListJournal(%)
 n Count,Order,idx,Flag,OneRest,Value
 s Count=$g(%("Count"))
 i 'Count s Count=20
 s Order=$g(%("Order"))
 i Order="" s Order="H"
 s Flag=$g(%("Flag"))
 s OneRest=$g(%("OneRest"))
 s Value=$g(%("Value"))
 ;Order by horolog
 i Order="H" s idx="" f  s idx=$zp(^Zrestj("I",idx)) q:idx=""  d  q:'Count
 .d ListJournalO("I",idx)
 ;Order by Token
 i Order="T" d
 .i Value="" s idx="" f  s idx=$o(^Zrestj("IT",idx)) q:idx=""  d ListJournalO("IT",idx) q:'Count
 .i Value'="" d ListJournalO("IT",Value)
 ;Order by IP
 i Order="IP" d
 .i Value="" s idx="" f  s idx=$o(^Zrestj("IIP",idx)) q:idx=""  d ListJournalO("IIP",idx) q:'Count
 .i Value'="" d ListJournalO("IIP",Value)
 ;Order by URL
 i Order="URL" d
 .i Value="" s idx="" f  s idx=$o(^Zrestj("IM",idx)) q:idx=""  d ListJournalO("IM",idx) q:'Count
 .i Value'="" d ListJournalO("IM",Value)
 
 q
 
 ;Order in indexes
ListJournalO(%,%1)
 n horolog,job,id
 s horolog=""
 f  s horolog=$zp(^Zrestj(%,%1,horolog)) q:horolog=""  d  q:'Count
 .s job=""
 .f  s job=$o(^Zrestj(%,%1,horolog,job)) q:job=""  d  q:'Count
 ..s id=""
 ..f  s id=$o(^Zrestj(%,%1,horolog,job,id)) q:id=""  d  q:'Count
 ...i OneRest,OneRest=Count d ListJournal1(job,horolog,id,"RQ") s Count=0 q
 ...i 'OneRest d ListJournal1(job,horolog,id,Flag)
 ...s Count=Count-1
 q 
 
 ;Write one row
ListJournal1(job,horolog,id,flg)
 n Ref,i,j,wrdata
 s Ref=$na(^Zrestj("J",job,horolog,id,"H"))
 s j=$$GetTokenID^appsysAUTH($g(@Ref@("Authorization")))
 i j'="" s j=j_"/"_$g(^XMAloc("AUTH",j,"I","user_id"))
 s wrdata(1)=$$HtRR^ISBdt(horolog)
 s wrdata(2)=j
 s wrdata(3)=$g(@Ref@("REQ","MET"))
 s wrdata(4)=$g(@Ref@("REQ","URL"))
 s wrdata(5)=$g(@Ref@("REQ","IP"))
 w wrdata(1),?16,wrdata(2),?32,wrdata(3),?38,wrdata(4),?65,wrdata(5)
 w " (",Count,")"
 w !
 ;Request
 i $f($g(flg),"Q") d
 .i '$d(^Zrestj("J",job,horolog,id,"A")) q
 .w ?10,"Request:"
 .s i=""
 .f  s i=$o(^Zrestj("J",job,horolog,id,"A",i)) q:i=""  w ?30,$g(^Zrestj("J",job,horolog,id,"A",i)),!
 ;Response
 i $f($g(flg),"R") d
 .w ?10,"Response:"
 .s i=""
 .f  s i=$o(^Zrestj("J",job,horolog,id,"R",i)) q:i=""  w ?30,$g(^Zrestj("J",job,horolog,id,"R",i)),!
 q 

LIBserver^INT^1^64142,50483^0
LIBserver	;LIBrary
 ;Communication server
 ;Copyright Slavek Zmek, 2005
 
 q
 
err
 g loop
 
 ;job's starting point
start(port,user)
 s user=$g(user)
 i user="" s user="127.0.0.1"
 s i=$system.License.Login(user)
 ;Port is regular
 s port=+$g(port)
 i 'port s port=1717
 s dev="|TCP|"_port
 s timeout=10
 ;Indication - job is running
 s ^XMA("J","Br",port)=$j
 
 ;Server's initialization
init
 s $zt="err^LIBserver"
 ;I'm sure, the port is closed
 c dev
 ;Open server for listening
 d log("Starting server at "_port)
 o dev:(:port:"SA"::32767:32767:10):10
 ;Cannot open the server
 i '$t d log("Cannot start the server") g end
 
 u dev
 d log("Starting reading mode...")
 
loop
 r xX:20
 i '$t g:'$g(^XMA("J","Br",port)) end g loop
 s clientip=$zu(111,0)
 s ipn=$a(clientip,1)_"."_$a(clientip,2)_"."_$a(clientip,3)_"."_$a(clientip,4)
 d log("Connection request from "_ipn_":"_($a(clientip,5)*256+$a(clientip,6))_", starting child server process")
 i $v(0,-2,$zu(40,0,1))\(2**16)#2 d log("System shutting down") g end
 j child(ipn,port):(:24):timeout
 i '$t d log("Unable to start a child process") w *-2 
 g loop
 
end
 i $g(dev)'="" c dev
 d log("Server is down")
 s ^XMA("J","Br",port)=0
 q
 
 ;Starts server as a job
job(port)
 j start(port)
 q
 
 ;Ends server
stop(port)
 s ^XMA("J","Br",port)=0
 q
 
 ;Logs - for logging uncomment
log(mess)
 ;d log^LIBserveru(mess)
 q
 
 ;child process
child(ip,port)
 s $zt="errc^LIBserver"
 ;Use current (correct) TCP device
 u $zu(53)
 ;Makes the last device in use the principal I/O device
 d $zu(132)
 u 0:(::"+S"::32767:32767)
 
 ;Connection established - testing client's license ...
 s i=$system.License.Login(ip)
 d log("child established !")
 s xbuf=""
child2
 s bufl=0
 f  r *xX s xbuf=xbuf_$c(xX) d:'bufl  i $l(xbuf)=bufl q
 .i $l(xbuf)=2 s bufl=$a(xbuf,2)*256+$a(xbuf),xbuf=""
 
 s xcmnd=$e(xbuf),xdata=$e(xbuf,2,bufl),rer="",xbuf=$e(xbuf,bufl+1,$l(xbuf))
 i xcmnd="" g child2
 
 ;Save local variables - may be to complete later ...
 i xcmnd="X" d xecute
 i xcmnd="R" d RegLic^LIBserveru(xbuf)
 i xcmnd="G" g @xbuf
 
 ;Restore local variables
 
 d endc
 g child2
 
 ; Child's error
errc
 d log($ze)
 i $ze["<DSCON>" g halt
 g child2
 
 ;End transmission, flush buffers
endc
 i $g(rer)="" s rer="0"_$g(VALUE)
 w $c($l(rer)#256)_$c($l(rer)\256)_rer
 w *-3
 q
 
 ;Halt child connection  
halt
 d log("Child connection stopped!")
 c dev
 ;Remove saved local variables
 q
 
 ;xecute string
xecute
 n dev,xcmnd
 s $zt="xerr^LIBserver"
 d log("BufLen:"_bufl)
 d log("Xecute:"_xdata)
 x xdata
 q
 
xerr
 d log("Execute error - "_$zerror)
 s rer=1_$zerror
 s xbuf=""
 q

LIBserverj^INT^1^64142,50469^0
LIBserverj	;LIBrary
 ;Communication server - JSON
 ;Copyright Slavek Zmek, 2016
.
 q
 
err
 g loop
 
 ;job's starting point
start(port,user)
 s user=$g(user)
 i user="" s user="127.0.0.1"
 s i=$system.License.Login(user)
 ;Port is regular
 s port=+$g(port)
 i 'port s port=1727
 s dev="|TCP|"_port
 s timeout=10
 ;Indication - job is running
 s ^XMA("J","BrJ",port)=$j
 
 ;Server's initialization
init
 s $zt="err^LIBserverj"
 ;I'm sure, the port is closed
 c dev
 ;Open server for listening
 d log("Starting server at "_port)
 o dev:(:port:"SA"::32767:32767:10):10
 ;Cannot open the server
 i '$t d log("Cannot start the J-server") g end
 
 u dev
 d log("Starting reading mode...")
 
loop
 r xX:20
 i '$t g:'$g(^XMA("J","BrJ",port)) end g loop
 s clientip=$zu(111,0)
 s ipn=$a(clientip,1)_"."_$a(clientip,2)_"."_$a(clientip,3)_"."_$a(clientip,4)
 d log("Connection request from "_ipn_":"_($a(clientip,5)*256+$a(clientip,6))_", starting child server process")
 i $v(0,-2,$zu(40,0,1))\(2**16)#2 d log("System shutting down") g end
 j child(ipn,port):(:24):timeout
 i '$t d log("Unable to start a child process") w *-2 
 g loop
 
end
 i $g(dev)'="" c dev
 d log("Server is down")
 s ^XMA("J","BrJ",port)=0
 q
 
 ;Starts server as a job
job(port)
 j start(port)
 q
 
 ;Ends server
stop(port)
 s ^XMA("J","BrJ",port)=0
 q
 
 ;Logs - for logging uncomment
log(mess)
 ;d log^LIBserveru(mess)
 q
 
 ;child process
child(ip,port)
 s $zt="errc^LIBserverj"
 ;Use current (correct) TCP device
 u $zu(53)
 ;Makes the last device in use the principal I/O device
 d $zu(132)
 u 0:(::"+S"::32767:32767)
 
 ;Connection established - testing client's license ...
 s i=$system.License.Login(ip)
 d log("child established !")
child2
 s xbuf=""
 s bufl=0
 f  r *xX s xbuf=xbuf_$c(xX) d:xX=125  i bufl q
 .i '$$Decode^LIBjson(xbuf,"JSON") s bufl=1,xbuf="" q
 .k JSON
.
 s rer=""
 i $g(JSON("OP"))="" d ErrMSG("Undefined operation") g child3 
 i JSON("OP")="SYS" d  g child3
 .i JSON("COMMAND")="REG" d RegLic^LIBserveru(JSON("PARAM")),OkMSG("") q
 .i JSON("COMMAND")="XEC" d xecute q
 .d ErrMSG("Unknown SYS operation")
 
 i JSON("OP")="LOCAL" d  g child3
 .s i=$g(^XMA("BrJ","LOCAL"))
 .i i'="" d Local(i) q
 .d ErrMSG("Unknown LOCAL operation")
.
 d ErrMSG("Unknown operation")
child3 
 ;Answer, flush buffers
 i $g(rer)="" s i="Not specified answer,"_$g(JSON("OP"))_":"_$g(JSON("COMMAND")) d log(i),ErrMSG("i")
 w rer
 w *-3
 k JSON
 g child2
 
 ; Child's error
errc
 d log($ze)
 i $ze["<DSCON>" g halt
 d ErrMSG("ERROR !")
 g child3
 
 ;Halt child connection  
halt
 d log("Child connection stopped!")
 c dev
 ;Remove saved local variables
 q
.
 ;OK - JSON message
OkMSG(%)
 n Answer
 s Answer("STATUS")=0
 i $g(%)="" s %="OK"
 s Answer("MSG")=%
 s rer=$$Encode^LIBjson("Answer")
 q
 
 ;Error - JSON message
ErrMSG(%)
 n Answer
 s Answer("STATUS")=1
 i $g(%)="" s %="Error"
 s Answer("MSG")=%
 s rer=$$Encode^LIBjson("Answer")
 q
 
 ;xecute string
xecute
 n dev
 s $zt="xerr^LIBserverj"
 d log("Xecute:"_$g(JSON("PARAM")))
 x JSON("PARAM")
 d OkMSG($g(VALUE))
 q
xerr
 d log("Execute error - "_$zerror)
 d ErrMSG("Error while XECUTE")
 q 
.
 ;Local operation
Local(i)
 n dev
 s $zt="LocalE^LIBserverj"
 d log("Local:"_$g(JSON("COMMAND")))
 d @i
 i rer="" d OkMSG($g(VALUE))
 q
LocalE
 d log("Local operation error - "_$zerror)
 d ErrMSG("Error while LOCAL")
 q 
.

LIBserverr^INT^1^64672,36018.65439^0
LIBserverr	;LIBrary
 ;Communication server - REST
 ;Copyright Slavek Zmek, 2017
 
 q
 
err
 g loop
 
 ;job's starting point
start
 n port,user
 s user=$g(^XMAloc("T","USER"))
 i user="" s user="127.0.0.1"
 s i=$system.License.Login(user)
 ;Port is regular
 s port=+$g(^XMAloc("T","PORT"))
 i 'port s port=80
 s dev="|TCP|"_port
 s timeout=10
 ;Indication - job is running
 s ^XMAloc("T","job")=$j
 
 ;Server's initialization
init
 s $zt="err^LIBserverr"
 ;I'm sure, the port is closed
 c dev
 ;Open server for listening
 d log("Starting server at "_port)
 o dev:(:port:"SA"::32767:32767:10):10
 ;Cannot open the server
 i '$t d log("Cannot start the server") g end
 
 u dev
 d log("Starting reading mode...")
 
loop
 r xX:20
 i '$t g:'$g(^XMAloc("T","job")) end g loop
 s clientip=$zu(111,0)
 s ipn=$a(clientip,1)_"."_$a(clientip,2)_"."_$a(clientip,3)_"."_$a(clientip,4)
 d log("Connection request from "_ipn_":"_($a(clientip,5)*256+$a(clientip,6))_", starting child server process")
 i $v(0,-2,$zu(40,0,1))\(2**16)#2 d log("System shutting down") g end
 j child(ipn,port):(:24):timeout
 i '$t d log("Unable to start a child process") w *-2 
 g loop
 
end
 i $g(dev)'="" c dev
 d log("Server is down")
 s ^XMAloc("T","job")=0
 q
 
 ;Starts server as a job
job
 j start
 q
 
 ;Ends server
stop
 s ^XMAloc("T","job")=0
 q
 
 ;Logs - for logging uncomment
log(mess)
 ;d log^LIBserveru(mess)
 q
 
 ;child process
child(ip,port)
 s $zt="errc^LIBserverr"
 ;Use current (correct) TCP device
 u $zu(53)
 ;Makes the last device in use the principal I/O device
 d $zu(132)
 u 0:(::"+S"::32767:32767)
 ;d SetIO^%NLS("UTF8")
 ;Connection established - testing client's license ...
 s i=$system.License.Login(ip)
 d log("child established !")
child1 
 ;Read header, initialization
 s xbuf="",GbD=$na(^Zrests($j)),GbR=$na(^Zresponse($j))
 s headi=0
 k head
 f  r *xX:4 q:'$t  s xbuf=xbuf_$c(xX) i xX=10 s headi=headi+1,head(headi)=$p(xbuf,$c(13)),xbuf="" q:head(headi)=""
 d TrimHead
 ;Head parameters - Code length, Connection
 s len=+$$GetHValue("Content-Length")
 s conn=$$GetHValue("Connection")
 ;Read data
 k @GbD
 s xbuf="",(bufl,i)=0
 i len f  r *xX:4 q:'$t  s xbuf=xbuf_$c(xX),bufl=bufl+1 q:bufl=len  i $l(xbuf)=1000 s i=i+1,@GbD@(i)=$zcvt(xbuf,"I","UTF8"),xbuf=""
 i xbuf'="" s i=i+1,@GbD@(i)=$zcvt(xbuf,"I","UTF8")
 ;Evaluate data, make answer
 k @GbR
 s xrou=$g(^XMAloc("T","ROU"))
 i xrou="" d defa
 i xrou'="" d @xrou
 ;Answer
 d send
 k @GbD,@GbR
 i conn="Keep-Alive" g child1
 g halt
 
 ; Child's error
errc
 d log($ze)
 g halt
 
 ;Halt child connection  
halt
 d log("Child connection stopped!")
 c 0
 q
 
 ;Make default answer - testing...
defa
 n i
 s i=head(1)
 k head
 s head(1)="HTTP/1.1 200 OK"
 s head(2)="Date:"
 s head(3)="Content-Type: application/json"
 s head(4)="Content-Length: "_($$GetLength(i)+2)
 s head(5)="Content-Encoding: identity"
 s @GbR@(1)="OK"
 s @GbR@(2)=i
 q
 
 ;Send answer
send
 n i
 s i=""
 f  s i=$o(head(i)) q:i=""  w head(i),$c(13,10)
 w $c(13,10)
 s i=""
 f  s i=$o(@GbR@(i)) q:i=""  w @GbR@(i)
 w *-3
 q
 
 ;**** Useful procedures and functions
 ;Transform HEAD and REQUEST LINE into fields
TrimHead
 n i,j,k
 m k=head
 k head
 s head("REQ","MET")=$p(k(1)," "),head("REQ","URL")=$p(k(1)," ",2)
 f i=2:1:headi d
 .s j=$p(k(i),":")
 .i j="" q
 .s head(j)=$p(k(i),":",2,100)
 .f  q:$e(head(j))'=" "  s $e(head(j))=""
 
 q
 
GetHValue(%)
 q $g(head(%))
.
GetLength(%)
 n i,j,k
 i '$SYSTEM.Version.IsUnicode() q $l(%)
 s i=$zwbunpack(%)
 s k=$l(i)
 f j=1:2:$l(i) i $a(i,j)=0 s k=k-1
 q k
 
test 
 k ^rest
 m ^rest(1)=head
 m ^rest(2)=@GbD
 d defa
 q
.

LIBserveru^INT^1^64142,50455^0
LIBserveru	;LIBrary
 ;Communication server - utilities
 ;Copyright Slavek Zmek, 2016
.
 ;Register license
RegLic(%)
 n i  
 s $zt="RegLicE^LIBserveru"
 s i=$system.License.Login(%)
 q
RegLicE
 d log("Register error - "_$zerror)
 s rer="1"_$zerror
 q
 
 ;Logs
log(%)
 n i
 s i=$zp(^log(""))+1
 s ^log(i)=%
 q    

LIBsversion^INT^1^64952,31830.405066^0
LIBsversion
 ;Source version system
 ;Copyright Slavek Zmek, 2018
 ;Structures: ^sversion  - data, settings,....
 ;                 "Cont" - content (according to namespaces)
 ;                    <namespace>
 ;                           "C" - classes
 ;                           "D" - data
 ;                           "P" - projects
 ;                           "R" - routines
 ;                 "Sett" - settings for different services
 ;                    "BckUpDir"  - directory for backup
 ;                    "BckUpMode" - every item in own file(0), or one file for all(1)
 ;                    "Namespace" - current(0) or all(1)
 ;                 "Stat" - statistics
 ;                    "BckUpLast" - last backup (horolog)
 ;Functions/procedures:
 ;             BackUp   - backup of current namespace/all namespaces, into new directory (name according to current date)
 ;             Upgrade  - make upgrade's file into directory
 ;             List     - list of content
 ;        For registration:
 ;			   AddRou   - add routine
 ;			   DelRou   - delete routine
 ;			   AddClass - add class
 ;			   DelClass - delete class
 ;			   AddData  - add data
 ;			   DelData  - delete data
 ;			   AddProj  - add project
 ;			   DelProj  - delete project
 ;        For recover:
 ;             Recover  - recover one file from backup
 ;        Batch-functions, used by binary SVersion.exe:
 ;
 ;
.
.
 ;Backup
BackUp()
 n Dir,NspOld,Nsp,NspMode,Err,Mode,i,j
 s Dir=$g(^sversion("Sett","BckUpDir"))
 i Dir="" s ErrTxt="No directory for backup !" q 1
 i $e(Dir,$l(Dir))'="\" s Dir=Dir_"\"
 s i=$$HtD^ISBdt(+$h)
 s Dir=Dir_$p(i,".",3)_$tr($j($p(i,".",2),2)," ","0")_$tr($j($p(i,"."),2)," ","0"),i=0,j=""
 f  q:'$$tdir^LIBm(Dir_j)  s i=i+1,j="."_$tr($j(i,3)," ","0")
 s Dir=Dir_j
 d mkdir^LIBm(Dir)
 s Dir=Dir_"\"
 s Mode=+$g(^sversion("Sett","BckUpMode"))
 s NspMode=+$g(^sversion("Sett","Namespace"))
 s $zt=$$SetZT^LIBm("BackUpERR^LIBsversion")
.
 s ^sversion("Stat","BckUpLast")=$h
 s NspOld=$$GetNSP^LIBm()
 s Err=0
 i 'NspMode d BackUpNsp(NspOld)
 i NspMode d
 .s Nsp=""
 .f  s Nsp=$o(^sversion("Cont",Nsp)) q:Nsp=""  d
 ..d SetNSP^LIBm(Nsp)
 ..d BackUpNsp(Nsp)
 .d SetNSP^LIBm(NspOld)
 q Err
 
 ;Zetrap for Backup
BackUpERR
 d SetNSP^LIBm(NspOld)
 q 1
.
 ;Backup - one namespace
BackUpNsp(Nsp)
 n Ref,Item,eData,File,k,Gb
 
 ;Make Steps
 s Gb=$na(^Zscenario($j))
 k @Gb
 ;Routines
 s Ref=$na(^sversion("Cont",Nsp,"R")),k=0
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  s k=k+1,eData(k)=Item
 i $d(eData) d AddStepItem^LIBXupdate("eData","R",Gb) k eData
 ;Classes
 s Ref=$na(^sversion("Cont",Nsp,"C")),k=0
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  s k=k+1,eData(k)=Item
 i $d(eData) d AddStepItem^LIBXupdate("eData","C",Gb) k eData
 ;Data
 s Ref=$na(^sversion("Cont",Nsp,"D")),k=0
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  s k=k+1,eData(k)=Item
 i $d(eData) d AddStepItem^LIBXupdate("eData","D",Gb) k eData
 ;Projects
 s Ref=$na(^sversion("Cont",Nsp,"P")),k=0
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  s k=k+1,eData(k)=Item
 i $d(eData) d AddStepItem^LIBXupdate("eData","P",Gb) k eData
 
 i '$d(@Gb) q
 i 'Mode s Err=$$FiledStepsX^LIBXupdate(Gb,Dir)
 i Mode s Err=$$FiledSteps^LIBXupdate(Gb,Dir_"Backup-"_Nsp_".xxx")
 s Err=$$SaveSteps^LIBXupdate(Gb,Dir_"Content-"_Nsp_".txt")
 k @Gb
 q
  
 ;List
List
 n Ref,i
 w ?20,"Backup system",!,?20,"---------------------",!
 s Ref=$na(^sversion("Sett"))
 w "Settings: ",?20,"Directory:",?40,$g(@Ref@("BckUpDir")),!
 s i=+$g(@Ref@("BckUpMode"))
 w ?20,"Mode:",?40,$s(i=1:"One file",1:"Separate files"),!
 s i=+$g(@Ref@("Namespace"))
 w ?20,"Namespace:",?40,$s(i=1:"All",1:"Current"),!
 w !
 d ListT("R")
 d ListT("C")
 d ListT("D")
 d ListT("P")
 q
 
 ;List of one type
ListT(%)
 n i,Nsp,Ref,Item,Count,Mode
 s i=$s(%="D":"Data",%="P":"Projects",%="C":"Classes",%="R":"Routines",1:"???")
 i %="R" s Mode=1
 e  s Mode=0
 w i,!,"-------------",!
 s Nsp=""
 f  s Nsp=$o(^sversion("Cont",Nsp)) q:Nsp=""  i $d(^sversion("Cont",Nsp,%)) d
 .w $j("",5),"Namespace: ",Nsp,!
 .s Ref=$na(^sversion("Cont",Nsp,%))
 .s Item="",(Count,i)=0
 .f  s Item=$o(@Ref@(Item)) q:Item=""  d
 ..s Count=Count+1,i=i+1
 ..i Mode=0 w ?10,Item,!
 ..i Mode=1 w ?((i-1)*25),Item i i>2 s i=0 w !
 .i Mode w !
 .w "Count: ",Count,!!
 q
 
 ;Upgrade
 ;Parameters: Dir     - directory to store upgrade
 ;            Params  - parameters, must by called by reference (.Params)
 ;                         NspMode  - namespaces - 0=current, 1=all
 ;                         DateFrom - upgrade routines/classes with date newer
 ;                         NoData   - 0 - without Data, 1 - with defined data
Upgrade(Dir,Params)
 n NspOld,Nsp,NspMode,Err,i,j
 i Dir="" s ErrTxt="No directory for upgrade !" q 1
 i $e(Dir,$l(Dir))'="\" s Dir=Dir_"\"
 i '$$tdir^LIBm(Dir) d mkdir^LIBm(Dir)
 s Dir=Dir_"\"
 s $zt=$$SetZT^LIBm("UpgradeERR^LIBsversion")
.
 s NspOld=$$GetNSP^LIBm()
 s Err=0
 s NspMode=$g(Params("Namespace"))
 i 'NspMode d UpgradeNsp(NspOld)
 i NspMode d
 .s Nsp=""
 .f  s Nsp=$o(^sversion("Cont",Nsp)) q:Nsp=""  d
 ..d SetNSP^LIBm(Nsp)
 ..d UpgradeNsp(Nsp)
 .d SetNSP^LIBm(NspOld)
 q Err
 
 ;Zetrap for Upgrade
UpgradeERR
 d SetNSP^LIBm(NspOld)
 q 1
 
 ;Upgrade - one namespace
UpgradeNsp(Nsp)
 n Ref,Item,eData,File,k,Gb,dtFrom
 s dtFrom=$g(Params("DataFrom"))
 ;Make Steps
 s Gb=$na(^Zscenario($j))
 k @Gb
 ;Routines
 s Ref=$na(^sversion("Cont",Nsp,"R")),k=0
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  d
 .i dtFrom'="",$g(^ROUTINE(Item,"0"))<dtFrom q
 .s k=k+1,eData(k)=Item
 i $d(eData) d AddStepItem^LIBXupdate("eData","R",Gb) k eData
 ;Classes
 s Ref=$na(^sversion("Cont",Nsp,"C")),k=0
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  d
 .i dtFrom'="",$g(^ROUTINE(Item_".1","0"))<dtFrom q
 .s k=k+1,eData(k)=Item
 i $d(eData) d AddStepItem^LIBXupdate("eData","C",Gb) k eData
 ;Data
 i '$g(Params("NoData")) d
 .s Ref=$na(^sversion("Cont",Nsp,"D")),k=0
 .s Item=""
 .f  s Item=$o(@Ref@(Item)) q:Item=""  s k=k+1,eData(k)=Item
 .i $d(eData) d AddStepItem^LIBXupdate("eData","D",Gb) k eData
 
 i '$d(@Gb) q
 s Err=$$FiledSteps^LIBXupdate(Gb,Dir_"Upgrade-"_Nsp_".xxx")
 s Err=$$SaveSteps^LIBXupdate(Gb,Dir_"Content-"_Nsp_".txt")
 k @Gb
 q
 
 ;Recover
 ;Parameters: File    - file to recover
 ;            Date    - date of backup, format YYYYMMDD
Recover(File,Date)
 n Dir,Err
 s Dir=$g(^sversion("Sett","BckUpDir"))
 i Dir="" s ErrTxt="No directory for backup !" q 1
 i $e(Dir,$l(Dir))'="\" s Dir=Dir_"\"
 i Date="" s ErrTxt="No inserted date !" q 1
 i File="" s ErrTxt="No inserted file !" q 1
 s Dir=Dir_Date_"\"
 i '$$tfile^LIBm(Dir_File) s ErrTxt="File doesn't exist !" q 1
 s Err=$$LoadUpdate^LIBXupdate(Dir_File)
 q Err
 
 
 ;Batch - prepare list of all namespaces, for binary SVersion.exe
Batch(Place,Mode)
 n Nsp,Idx
 d ModifRef(.Place)
 k @Place
 s Idx=0
 s Idx=Idx+1,@Place@(Idx)="VarSet|Ridici|Ridici.txt"
 s Idx=Idx+1,@Place@(Idx)="VarSet|GblF|%TmpGlob"
 s Idx=Idx+1,@Place@(Idx)="VarAddR|GblF|F"
 s Nsp=""
 f  s Nsp=$o(^sversion("Cont",Nsp)) q:Nsp=""  d BatchNsp(Nsp,Place,$g(Mode),1)
 s @Place@("OK")=1 
 q
 
 ;Batch - prepare list of namespace, for binary SVersion.exe. Run as job
BatchJob(Place,Mode)
 j Batch(Place,$g(Mode))
 f  q:$g(@Place@("OK"))=1  h .5
 q
  
 ;Batch prepare - for binary SVersion.exe
BatchNsp(Nsp,Place,Mode,NoKill)
 n NspOld,Idx,Ref,Ref1,Item,Ext,xMode
 s $zt=$$SetZT^LIBm("BatchERR^LIBsversion")
 s NspOld=$$GetNSP^LIBm()
 d SetNSP^LIBm(Nsp)
 
 i '$g(NoKill) k @Place
 
 d DoBatch($na(^sversion("Cont",Nsp)))
 
 d SetNSP^LIBm(NspOld)
 q
.
 ;Batch. For binary SVersion.exe. Read items by analyzing of file, e.g. from GIT
BatchFile(Nsp,Place,Pref,File,Mode,NoKill)
 n NspOld,Idx,i,j,xMode,GbT
 s $zt=$$SetZT^LIBm("BatchERR^LIBsversion")
 d ModifRef(.Place)
 d ModifRef(.File)
 s NspOld=$$GetNSP^LIBm()
 d SetNSP^LIBm(Nsp)
 i '$g(NoKill) k @Place
 ;Make batch-structure-list from file
 s GbT=$na(^Zforsver($j))
 k @GbT
 s i="",Pref=$g(Pref)
 f  s i=$o(@File@(i)) q:i=""  d
 .s j=@File@(i)
 .i Pref'="",$e(j,1,$l(Pref))=Pref s j=$e(j,$l(Pref)+1,$l(j))
 .i $p(j,".",*)="cls" d  q
 ..s j=$tr($p(j,".cls"),"/",".")
 ..s @GbT@("C",j)=""
 
 d DoBatch(GbT)
 
 k @GbT
 d SetNSP^LIBm(NspOld)
 q
 
 ;Batch - call for all types with structure. Some variables must be filled in advance.... Nsp,Place,Mode,....
DoBatch(xPlace)
 n xMode,i
 s Idx=$zp(@Place@("F",""))
 ;Directory
 s Idx=Idx+1,@Place@("F",Idx)="Comment|Namespace "_Nsp
 s Idx=Idx+1,@Place@("F",Idx)="VarDir|ADir"
 s Idx=Idx+1,@Place@("F",Idx)="MakeDir|"_Nsp
 s xMode=$g(Mode)
 i xMode="" s xMode="RCPD"
 ;Routines
 i $f(xMode,"R") d BatchRou($na(@xPlace@("R")))
 ;Classes
 i $f(xMode,"C") d BatchCls($na(@xPlace@("C")))
 ;Data
 i $f(xMode,"D") d BatchData($na(@xPlace@("D")))
 ;Projects
 i $f(xMode,"P") d BatchPrj($na(@xPlace@("P")))
 ;Directory back
 s Idx=Idx+1,@Place@("F",Idx)="ChDir|%ADir"
 ;Compact
 s i=""
 f  s i=$o(@Place@("D",i)) q:i=""  d CompactL^LIBdatop($na(@Place@("D",i)),$na(@Place@("D",i)),1)
 q
 
 ;Batch - routine
BatchRou(Ref)
 n Ext,Item,Ref1
 s Ext=$$GetExt^LIBXupdate("R")
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  d
 .s Idx=Idx+1
 .s @Place@("A",Idx)="R|"_Item
 .s Ref1=$na(@Place@("D",Idx))
 .d PrepareOne^LIBXupdate("R",Item,Ref1)
 .s @Place@("F",Idx)="SaveData|"_Ref1_"|"_Item_Ext_"|"_"BIN"
 q 
 
 ;Batch - classes
BatchCls(Ref)
 n Ext,Item,Ref1
 s Ext=$$GetExt^LIBXupdate("C")
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  d
 .s Idx=Idx+1
 .s @Place@("A",Idx)="C|"_Item
 .s Ref1=$na(@Place@("D",Idx))
 .d PrepareOne^LIBXupdate("C",Item,Ref1)
 .s @Place@("F",Idx)="SaveData|"_Ref1_"|"_Item_Ext_"|"_"BIN"
 q
 
 ;Batch - data
BatchData(Ref)
 n Ext,Item,Ref1
 s Ext=$$GetExt^LIBXupdate("D")
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  d
 .s Idx=Idx+1
 .s @Place@("A",Idx)="D|"_Item
 .s Ref1=$na(@Place@("D",Idx))
 .d PrepareOne^LIBXupdate("D",Item,Ref1)
 .s @Place@("F",Idx)="SaveData|"_Ref1_"|"_$tr(Item,"""^,()","-")_Ext_"|"_"BIN"
 q
 
 ;Batch - project
BatchPrj(Ref)
 n Ext,Item,Ref1
 s Ext=$$GetExt^LIBXupdate("P")
 s Item=""
 f  s Item=$o(@Ref@(Item)) q:Item=""  d
 .s Idx=Idx+1
 .s @Place@("A",Idx)="P|"_Item
 .s Ref1=$na(@Place@("D",Idx))
 .d PrepareOne^LIBXupdate("P",Item,Ref1)
 .s @Place@("F",Idx)="SaveData|"_Ref1_"|"_Item_Ext_"|"_"BIN"
 q
 
 ;Batch Recover
BatchRecoverNsp(Nsp,Place)
 n NspOld,Err
 s $zt=$$SetZT^LIBm("BatchERR^LIBsversion")
 d ModifRef(.Place)
 s NspOld=$$GetNSP^LIBm()
 d SetNSP^LIBm(Nsp)
 s Err=$$LoadOne^LIBXupdate(Place)
 d SetNSP^LIBm(NspOld)
 q
 
 ;Zetrap for Batch
BatchERR
 d SetNSP^LIBm(NspOld)
 q 1
 
 ;Modify reference with current namespace
ModifRef(%)
 n Nsp
 s Nsp=$$GetNSP^LIBm()
 i $e(%)="^" s %=$e(%,2,$l(%))
 s %="^["""_Nsp_"""]"_%
 q
 
 ;Utilities
 
 ;Add routine
AddRou(Rou)
 d AddItem("R",Rou)
 q
 
 ;Delete routine
DelRou(Rou)
 d DelItem("R",Rou)
 q
.
 ;Add class
AddClass(Cls)
 d AddItem("C",Cls)
 q
 
 ;Delete class
DelClass(Cls)
 d DelItem("C",Cls)
 q
 
 ;Add data
AddData(Data)
 d AddItem("D",Data) 
 q
.
 ;Delete data
DelData(Data)
 d DelItem("D",Data)
 q
 
 ;Add project
AddProj(Data)
 d AddItem("P",Data) 
 q
.
 ;Delete project
DelProj(Data)
 d DelItem("P",Data)
 q
 
 ;Add one item
AddItem(Type,Item)
 n Nsp,Err
 s Nsp=$$GetNSP^LIBm()
 i Type="R" s Err=$$xTest^LIBXupdate(Item_".INT") i Err q
 s ^sversion("Cont",Nsp,Type,Item)=""
 q
 
 ;Delete one item
DelItem(Type,Item)
 n Nsp
 s Nsp=$$GetNSP^LIBm()
 k ^sversion("Cont",Nsp,Type,Item)
 q
.
 ;Make scenario from ^sversion - structure
MakeScenario(Dest)
 n i,Item,Nsp,Ref
 k @Dest
 s Nsp=$$GetNSP^LIBm()
 s i=0
 ;Routines
 i $d(^sversion("Cont",Nsp,"R")) d
 .s i=i+1,@Dest@(i)="[Routines]"
 .s Ref=$na(^sversion("Cont",Nsp,"R"))
 .s Item=""
 .f  s Item=$o(@Ref@(Item)) q:Item=""  s i=i+1,@Dest@(i)=Item
 ;Classes
 i $d(^sversion("Cont",Nsp,"C")) d
 .s i=i+1,@Dest@(i)="[Classes]"
 .s Ref=$na(^sversion("Cont",Nsp,"C"))
 .s Item=""
 .f  s Item=$o(@Ref@(Item)) q:Item=""  s i=i+1,@Dest@(i)=Item
 ;Data
 i $d(^sversion("Cont",Nsp,"D")) d
 .s i=i+1,@Dest@(i)="[Data]"
 .s Ref=$na(^sversion("Cont",Nsp,"D"))
 .s Item=""
 .f  s Item=$o(@Ref@(Item)) q:Item=""  s i=i+1,@Dest@(i)=Item
 ;Projects
 i $d(^sversion("Cont",Nsp,"P")) d
 .s i=i+1,@Dest@(i)="[Projects]"
 .s Ref=$na(^sversion("Cont",Nsp,"P"))
 .s Item=""
 .f  s Item=$o(@Ref@(Item)) q:Item=""  s i=i+1,@Dest@(i)=Item
 q

LIButil^INT^1^64688,33127.438358^0
LIButil
 ;Utility
 ;Copyright Slavek Zmek, 2010
 
 ;Get unique ID from reference, locked after exit
GetUniq(%)
 n ID,Ok
 s Ok=0,ID=$zp(@%@(""))+1
 f  d  q:Ok  s ID=ID+1
 .l +@%@(ID):2 e  q
 .i $d(@%@(ID)) l -@%@(ID):2 q
 .s Ok=1
 q ID
.
 ; Translate - one string to another ( $tr is char oriented !)
TrStr(%,%1,%2)
 n i,j
 s j=0 f  s i=$f(%,%1,j) q:i=0  d
 .s %=$e(%,1,i-$l(%1)-1)_%2_$e(%,i,$l(%))
 .s j=i-$l(%1)+$l(%2)
 q %
 
 ;Get transaction's number
GetTN()
 q $$GetTNX("")
GetTNX(%)
 n i,j
 l +^XMAloc("KOM","LC")
 s i=$g(%)
 i i="" s i=$g(^XMAloc("KOM","LC","I"))
 i i="" s i="X"
 s j=$g(^XMAloc("KOM","LC","L"))+1
 i j>99999999 s j=1
 s ^XMAloc("KOM","LC","L")=j
 l -^XMAloc("KOM","LC")
 q i_j

LIBwww^INT^1^65175,48739.474195^0
LIBwww
 ;WWW - protocols
 ;Copyright Slavek Zmek, 2018
.
 ;Send mail - parameters in field Data. Data("From") - From, Data("To") - To, Data("Cc")=CC, Data("Bcc"), Data("Subject"), Data("Body")
SendMail(Data)  
 n SmtpServer,SmtpPort,User,Pass,server,auth,msg,i,status
 ;Settings - constant for fnb. It must be set to different place as basic parameters
 s SmtpServer="postak.fnbrno.cz"
 s SmtpPort=25
 s User="test888@fnbrno.cz"
 s Pass="nemocnice123"
 
 ;Cache-Intersystems implementation
 s server=##class(%Net.SMTP).%New()
 s server.smtpserver=SmtpServer
 s server.port=SmtpPort
 ;Authentification
 s auth=##class(%Net.Authenticator).%New()
 s auth.UserName=User
 s auth.Password=Pass
 s server.authenticator=auth
 s server.AuthFrom=User
 ;Message  
 s msg=##class(%Net.MailMessage).%New()
 s i=@Data@("From")
 s:i="" i=User
 s msg.From=i
 d msg.To.Insert(@Data@("To"))
 s i=$g(@Data@("Cc"))
 i i'="" d msg.Cc.Insert(i)
 s i=$g(@Data@("Bcc"))
 i i'="" d msg.Bcc.Insert(i)
 s msg.Subject=$g(@Data@("Subject"))
 s msg.IsBinary=0
 s msg.IsHTML=0
 d msg.TextData.Write($g(@Data@("Body")))
  
 s status=server.Send(msg)
 i status'=1 {
    d $System.Status.DisplayError(status)
    ;Neccesary to resolv server.Error
    q 1
  }
 q 0
 
 ;Call REST service
CallREST(serviceUrl,response,method,server,port,body,https,auth,params)
 n ht,i,SC,httpStatusCode,responseContent
 ;s response={}
 s response=""
 s SC=1
 
 s ht=##class(%Net.HttpRequest).%New()
 s i=$g(server)
 i i="" s i="127.0.0.1"
 s ht.Server=i
 s i=$g(port)
 i i="" s i=80
 s ht.Port=i
 i $g(https) s ht.SSLConfiguration="SSL",ht.Https=1
 i $g(auth)'="" s ht.Authorization=auth
.
 d ht.SetHeader("Content-Type","application/json")
 s ht.ContentType="application/json"
 s ht.ContentCharset="UTF-8"
 i $d(params) d
 .s i=""
 .f  s i=$o(params(i)) q:i=""  d ht.SetParam(i,params(i))
 
 s i=$g(method)
 i i="" s i="GET"
 i i="GET"{
		s SC=ht.Get(serviceUrl)
	} elseif i="POST" {
		d ht.EntityBody.Write(body)
		s SC=ht.Post(serviceUrl)
	}
 i SC'=1 q SC
 s httpStatusCode=ht.HttpResponse.StatusCode
 i httpStatusCode'=200{
		return $System.Status.Error(5001, "REST service "_serviceUrl_" ended with http status code "_httpStatusCode)
	}
.
 i $isobject(ht.HttpResponse.Data){
		; stream
 d ht.HttpResponse.Data.Rewind()
 s responseContent=ht.HttpResponse.Data.Read()
 while ht.HttpResponse.Data.AtEnd=0{
			s responseContent=responseContent_ht.HttpResponse.Data.Read()
		}
	} else {
		; string
		s responseContent=ht.HttpResponse.Data
	}
 s response=responseContent
 ;s response=##class(%DynamicObject).%FromJSON(responseContent)
 q SC
.
 ;Call SOAP service
CallSOAP(serviceUrl,response,server,port,body,bigdata,https,action,auth)
 n ht,i,j,SC,httpStatusCode,responseContent
 i '$g(bigdata) s response=""
 s SC=1
 
 s ht=##class(%Net.HttpRequest).%New()
 s i=$g(server)
 i i="" s i="127.0.0.1"
 s ht.Server=i
 s i=$g(port)
 i i="" s i=9999
 s ht.Port=i
 i $g(https) s ht.SSLConfiguration="SSL",ht.Https=1,ht.Location=serviceUrl
.
 s body="<soapenv:Envelope xmlns:soapenv=""http://schemas.xmlsoap.org/soap/envelope/"" xmlns:fnbb=""http://www.fnbb.cz"">"_$c(13,10)_"<soapenv:Header/>"_$c(13,10)_"<soapenv:Body>"_$c(13,10)_body
 s body=body_"</soapenv:Body>"_$c(13,10)_"</soapenv:Envelope>"
.
 d ht.SetHeader("Content-Type","text/xml")
 d ht.SetHeader("Accept-Encoding","gzip,deflate")
 s ht.ContentType="text/xml"
 s ht.ContentCharset="UTF-8"
 i $g(action)'="" d ht.SetHeader("SOAPAction",action)
 ;Ruzne pokusy jak tam dat autorizaci
 i $g(auth)'="" d
 .;s ht.Authorization="Basic"
 .s ht.Username=$p(auth,":",2)
 .s ht.Password=$p(auth,":",3)
 .;s j=$p(auth,":")
 .;s i=j_" "
 .;i j="Basic" d  q
 .;.s i=i_$$encB64nolf^LIBchar($p(auth,":",2,3))
 .;.s ht.Authorization=i
 .d ht.SetHeader("Authorization",i)
 d ht.EntityBody.Write(body)
 i '$g(kttps) s SC=ht.Post(serviceUrl)
 i $g(kttps) s SC=ht.Post()
	
 i SC'=1 q 1_"$"_SC
 s httpStatusCode=ht.HttpResponse.StatusCode
 i $isobject(ht.HttpResponse.Data){
		; stream
 d ht.HttpResponse.Data.Rewind()
 i $g(bigdata) s i=1,@response@(i)=ht.HttpResponse.Data.Read()
 i '$g(bigdata) s responseContent=ht.HttpResponse.Data.Read()
 while ht.HttpResponse.Data.AtEnd=0{
			i '$g(bigdata) s responseContent=responseContent_ht.HttpResponse.Data.Read()
			i $g(bigdata) s i=i+1,@response@(i)=ht.HttpResponse.Data.Read()
		}
	} else {
		; string
		s responseContent=ht.HttpResponse.Data
	}
 i '$g(bigdata) s response=responseContent
 i httpStatusCode'=200 q httpStatusCode_"$"_"SOAP service "_serviceUrl_" ended with http status code "_httpStatusCode
 q 0
 
 ;Make data as parameters to add into URL
DataToURL(Sou)
 n i,j,Re
 s (i,Re)=""
 f  s i=$o(@Sou@(i)) q:i=""  d
 .s j=@Sou@(i)
 .s j=$$TrStr^LIButil(j,"/","%2F")
 .s Re=Re_i_"="_j_"&"
 q $e(Re,1,$l(Re)-1)
 
 

LIBxml^INT^1^65384,30145.120579^0
LIBxml
 ;XML parser
 ;Copyright Slavek Zmek, 2010
 ;Library to read and create XML-structures
 ;    Analyze XML-file saved into database:
 ;          s Wrk=$$Init^LIBxml()
 ;          s Err=$$Analyze^LIBxml(Wrk,Source,Start,End)
 ;            ....steps to read data.....
 ;          d Release^LIBxml(Wrk)
 ;
 ;    Create XML-file via temporary data (in bzd):
 ;          d NewElemB("bzd","Form,Button")
 ;          d NewAttrB("bzd","Label:Ulozit,Method:post")
 ;          d NewElem("bzd","FormMap")
 ;          d NewAttr("bzd","FormProperty","HlavickaZadanky.Urgency")
 ;          d CloseElem("bzd")
 ;            ...another new elements and attributes......
 ;          s Wrk=$$Init()
 ;          d Create(Wrk,"bzd")
 ;          d Export(Wrk,Dest)
 ;          d Release(Wrk)
 ;
 ;    Modify existing XML - load, modify, save...
 ;          s Wrk=$$Init^LIBxml()
 ;          s Err=$$Analyze^LIBxml(Wrk,Source,Start,End)
 ;          ...
 ;          d ChangeVal(">Form>Dependencies>TestVal","Hodnota2",Wrk)
 ;          d ChangeAttr(">Form>Button","Label","Ulozit2",Wrk)
 ;          d AddVal(">Form>Uzovka>Typ","obojkova",wrk)
 ;          d AddAttr(">Form>Uzovka>Typ","Vlozil","Slavek",wrk)
 ;          ...
 ;          d Export(Wrk,Dest)
 ;          d Release(Wrk)
 ;
 
 ;Initialize space for data
Init()
 n wrk
 s wrk=$$GetUniq^LIButil("^ZXMLTMP")
 s ^ZXMLTMP(wrk)=$j
 l -^ZXMLTMP(wrk)
 q wrk
 
 ;Release data structure
Release(wrk)
 k ^ZXMLTMP(wrk)
 q
.
 ;Analyzing XML-data, fill structure
Analyze(wrk,src,start,end)
 n srcsub,line,atrib,atribval,Elevel,str,str2,exit,errmsg,sect,i,j,WhC
 n Ebeg,Eend,Eval,Xcdata,Xcomment,Xdecl,Xdoctype,Cvt
 i $g(src)="" q "0\No Data"
 s (srcsub,line,errmsg)=""
 s (Ebeg,Eend,Eval,Xdecl,Xdoctype,Xcomment,Xcdata,exit)=0
 d CInit
 i $g(start)'="" s srcsub=$zp(@src@(start))
 s end=$g(end)
ReadL
 s srcsub=$o(@src@(srcsub))
 i srcsub=end g EndA
 s line=line_$g(@src@(srcsub))
ReadL1
 s line=$$TrimL(line)
 i '$l(line) g ReadL
 i '(Ebeg+Eend+Eval+Xdecl+Xdoctype+Xcomment+Xcdata) d
 .s sect=""
 .i $e(line,1,2)="</" s Eend=1 q
 .i $e(line,1,2)="<?" s Xdecl=1 q
 .i $e(line,1,9)="<![CDATA[" s Xcdata=1 q
 .i $e(line,1,9)="<!DOCTYPE" s Xdoctype=1 q
 .i $e(line,1,4)="<!--" s Xcomment=1 q
 .i $e(line)="<" s:$f(line,">") Ebeg=1 q
 .s Eval=1
 i Ebeg g ReadElBeg
 i Eval g ReadElVal
 i Eend g ReadElEnd
 i Xdecl g ReadXdecl
 i Xdoctype g ReadXdoctype
 i Xcomment g ReadXcomment
 i Xcdata g ReadXcdata
 g ReadL
.
 ;End of analyzing
EndA q 'exit_$s(exit:"\"_errmsg,1:"")
 
 ;Attribute
Atrib(ele,wrk,atrib)
 n i,j,k,ret
 s j=$$Ref(ele)
 i j="" q ""
 s (ret,i)="",j=j_",i)"
 f  s i=$o(@j) q:i=""  s k=$g(@j) i $p(k,"\")="A",$p(k,"\",2)=atrib s ret=$p(k,"\",3,$l(k,"\")) q
 q ret
.
 ;Testing existence of attribute
TestAtrib(ele,wrk,atrib)
 n i
 s i=$$Atrib(ele,wrk,atrib)
 i i="" q 0
 q 1
 
 ;Testing existence of element
TestElem(ele,wrk)
 n i
 s i=$$Ref(ele)
 i i="" q 0
 q 1
 
 ;Testing existence of value
TestVal(ele,wrk)
 n i,j,k,ret
 s j=$$Ref(ele)
 i j="" q 0
 s ret=0,i="",j=j_",i)"
 f  s i=$o(@j) q:i=""  s k=$g(@j) i $p(k,"\")="V" s ret=1 q
 q ret
 
 ;Value
Val(ele,wrk)
 n i,j,k,ret
 s j=$$Ref(ele)
 i j="" q ""
 s (ret,i)="",j=j_",i)"
 f  s i=$o(@j) q:i=""  d  q:$l(ret)
 .s k=$g(@j)
 .i $p(k,"\")="V" s ret=$p(k,"\",2,$l(k,"\"))
 q ret
 
 ;List of elements - subscript by name
Elements(ele,wrk,where)
 n i,j,k,ret
 k where
 s j=$$Ref(ele)
 i j="" q 1
 s i="",j=j_",i)",ret=1
 f  s i=$o(@j) q:i=""  s k=$g(@j) i $p(k,"\")="E" s where($p(k,"\",2,$l(k,"\")))="",ret=0
 q ret
 ;List of elements - subscript by order
ElementsO(ele,wrk,where)
 n i,j,k,l,ret
 k where
 s j=$$Ref(ele)
 i j="" q 1
 s i="",j=j_",i)",ret=1,l=0
 f  s i=$o(@j) q:i=""  s k=$g(@j) i $p(k,"\")="E" s l=l+1,where(l)=$p(k,"\",2,$l(k,"\")),ret=0
 q ret
.
 ;List of attributes
Atributs(ele,wrk,where)
 n i,j,k,ret
 k where
 s j=$$Ref(ele)
 i j="" q 1
 s i="",j=j_",i)",ret=1
 f  s i=$o(@j) q:i=""  s k=$g(@j) i $p(k,"\")="A" s where($p(k,"\",2))="",ret=0
 q ret
 
 ;Values of all attributes
AtributsVal(ele,wrk,where)
 n i,attX
 k where
 s i=$$Atributs(ele,wrk,.attX)
 s i=""
 f  s i=$o(attX(i)) q:i=""  s where(i)=$$Atrib(ele,wrk,i)
 q 
 
ReadElVal
 i '$f(line,"<") g ReadL
 s str=$p(line,"<")
 s sect=sect_$s($l(sect)&$l(str):" ",1:"")_str
 s line=$e(line,$l(str)+1,$l(line))
 i $l(line) d
 .s Eval=0
 .i '$l(sect) q
 .f  q:$e(sect,$l(sect))'=" "  s sect=$e(sect,1,$l(sect)-1)
 .i sect=$c(13,10) q
 .d SetAll("V",$$Transf(sect))
 g ReadL1
 
 ;read element
ReadElBeg
 i '$f(line,">") g ReadL
 i Ebeg=1 s Ebeg=2,sect="",line=$e(line,2,$l(line))
 s str=$p(line,">")
 s sect=sect_" "_str
 i $l(line,">")>1 s Ebeg=0
 s line=$e(line,$l(str)+2,$l(line))
 i 'Ebeg d
 .s sect=$$TrimAll(sect)
 .i $e(sect,$l(sect))="/" s Eend=1,Eval=0,sect=$$TrimAll($e(sect,1,$l(sect)-1))
 .s sect=$tr(sect,$c(13,10),"  ")
 .s str=$p(sect," "),str2=$$TrimAll($e(sect,$l(str)+2,$l(sect)))
 .d NewEle("E",str)
 .f  q:str2=""  d
 ..s atrib=$p(str2,"="),str2=$$TrimL($e(str2,$l(atrib)+2,$l(str2)))
 ..i $e(str2)="'" s i="'"
 ..e  i $e(str2)="""" s i=""""
 ..e  d Err("bad syntax of attribute...") q
 ..s j=1 f  s j=j+1 q:$e(str2,j)=i  q:$e(str2,j)=""
 ..s atribval=$e(str2,2,j-1),str2=$$TrimL($e(str2,j+1,$l(str2)))
 ..d SetAll("A",atrib,atribval)
 .i Eend d EndEle
 g ReadL1
 
ReadElEnd
 i '$f(line,">") g ReadL
 s str=$p(line,">"),i=$p($p($g(Elevel("path")),">",Elevel),"#")
 i $e(str,3,$l(str))'=i d  g EndA
 .d Err("Bad closing - element '"_i_"' is closed '"_$e(str,3,$l(str))_"'")
 d EndEle
 s line=$e(line,$l(str)+2,$l(line))
 g ReadL1
 
ReadXcomment
 i Xcomment=1 s Xcomment=2,sect="",line=$e(line,5,$l(line))
 s str=$p(line,"-->")
 i $l(str)+$l(sect)>32000 d SetAll("K",$$TrimAll(sect)) s sect=""
 s sect=sect_$s($l(sect):" ",1:"")_str
 i $l(line,"-->")>1 s Xcomment=0
 s line=$e(line,$l(str)+4,$l(line))
 i 'Xcomment d SetAll("K",$$TrimAll(sect))
 g ReadL1
 
ReadXdoctype
 i Xdoctype=1 s Xdoctype=2,sect="",line=$e(line,10,$l(line))
 s str=$p(line,">")
 s sect=sect_$s($l(sect):" ",1:"")_str
 i $l(line,">")>1 s Xdoctype=0
 s line=$e(line,$l(str)+2,$l(line))
 i 'Xdoctype d SetAll("D",sect)
 g ReadL1
 
ReadXcdata
 i Xcdata=1 s Xcdata=2,sect="",line=$e(line,10,$l(line))
 s str=$p(line,">")
 i $l(str)+$l(sect)>32000 d SetAll("C",sect) s sect=""
 s sect=sect_$s($l(sect):" ",1:"")_str
 i $l(line,">")>1 s Xcdata=0
 s line=$e(line,$l(str)+2,$l(line))
 i 'Xcdata d SetAll("C",sect)
 g ReadL1
 
ReadXdecl
 i Xdecl=1 s Xdecl=2,sect="",line=$e(line,3,$l(line))
 s str=$p(line,"?>")
 s sect=sect_$s($l(sect):" ",1:"")_str
 i $l(line,"?>")>1 s Xdecl=0
 s line=$e(line,$l(str)+3,$l(line))
 i 'Xdecl d
 .s sect=$$TrimAll(sect)_" ENDXML"
 .s sect=$$TrStr^LIButil(sect,$c(13,10)," ")
 .f i=1:1:$l(sect,"=") d
 ..s str=$$TrimAll($p(sect,"=",i))
 ..s str2=$$TrimAll($p(sect,"=",i-1))
 ..i i=1 d NewEle("X",$p(str," ")) q
 ..i '$l(str) q
 ..s atrib=$p(str2," ",$l(str2," "))
 ..s atribval=$p(str," ",1,$l(str," ")-1)
 ..i $e(atribval)="'",$e(atribval,$l(atribval))="'" s atribval=$e(atribval,2,$l(atribval)-1)
 ..e  i $e(atribval)="""",$e(atribval,$l(atribval))="""" s atribval=$e(atribval,2,$l(atribval)-1)
 ..e  d Err("bad syntax of attribute...") q
 ..d SetAll("A",atrib,atribval)
 .k Elevel(Elevel)
 .k Elevel("path")
 .s Elevel=Elevel-1
 g ReadL1
 
 ;Initialize some constant
CInit
 s WhC=" "_$c(9)
 s Cvt("&lt;")="<"
 s Cvt("&gt;")=">"
 s Cvt("&amp;")="&"
 s Cvt("&quot;")=""""
 s Cvt("&apos;")="'"
 s Elevel=0,Elevel("Dref")="^ZXMLTMP("_wrk_",""D"""
 q
.
Err(%)
 s exit=1
 s errmsg=%
 q
  
Transf(str)
 n ret,pom,pom2,i,j
 i '$f(str,"&") q str
 s ret=$p(str,"&")
 f i=2:1:$l(str,"&") d
 .s pom=$p(str,"&",i)
 .s pom2="&"_$p(pom,$c(59),1)_$c(59)
 .s j=$l(pom,$c(59))
 .i j>1,$d(Cvt(pom2)) s ret=ret_$g(Cvt(pom2))_$p(pom,$c(59),2,j)
 .e  s ret=ret_"&"_pom
 q ret
 
SetAll(type,x1,x2)
 n val,i,j
 s Elevel(Elevel)=$g(Elevel(Elevel))+1
 s j=Elevel("Dref")
 f i=0:1:$g(Elevel) s j=j_","_$g(Elevel(i),0)
 s j=j_")"
 s val=type_"\"_x1
 i type="A" s val=val_"\"_$$Transf(x2)
 s @j=val
 q
 
NewEle(type,ele)
 n i,j
 d SetAll(type,ele)
 s Elevel=Elevel+1
 s Elevel(Elevel)=0
 s Elevel("path")=$g(Elevel("path"))_$s(Elevel>1:">",1:"")_ele
 f i=1:1 q:'$d(^ZXMLTMP(wrk,"I",">"_Elevel("path")_"#"_i))
 s Elevel("path")=Elevel("path")_"#"_i
 s j=""
 f i=0:1:(Elevel-1) s j=j_","_Elevel(i)
 s ^ZXMLTMP(wrk,"I",">"_Elevel("path"))=j
 q
 
EndEle
 s Eend=0
 k Elevel(Elevel)
 s Elevel=Elevel-1
 s Elevel("path")=$p(Elevel("path"),">",1,Elevel)
 q
 
 ;Make reference to data
Ref(%)
 n i,j,k
 s k=""
 f i=2:1:$l(%,">") d
 .s j=$p(%,">",i)
 .s k=k_">"_$p(j,"#")_"#"_$s(+$p(j,"#",2):+$p(j,"#",2),1:1)
 s i=$g(^ZXMLTMP(wrk,"I",k))
 i i'="" s i="^ZXMLTMP("_wrk_",""D"""_i
 q i
.
 ;New reference to data
NewRef(%)
 n i,j,k,l,m,x
 s (k,l)=""
 f i=2:1:$l(%,">") d
 .s j=$p(%,">",i)
 .s k=k_">"_$p(j,"#")_"#"_$s(+$p(j,"#",2):+$p(j,"#",2),1:1)
 .i $d(^ZXMLTMP(wrk,"I",k)) s l=$g(^ZXMLTMP(wrk,"I",k)) q
 .s x="^ZXMLTMP("_wrk_",""D"""_l_")"
 .s m=$zp(@x@(""))+1
 .s @x@(m)="E\"_$p(j,"#")
 .s l=l_","_m
 .s ^ZXMLTMP(wrk,"I",k)=l
 s i=$g(^ZXMLTMP(wrk,"I",k))
 i i'="" s i="^ZXMLTMP("_wrk_",""D"""_i
 q i
.
 ;Utilities
 
 ;Trim white chars - space, tab
TrimL(line)
 n i
 f i=1:1:$l(line)+1 q:WhC'[$e(line,i)
 q $e(line,i,$l(line))
TrimR(line)
 n i
 f i=$l(line):-1:0 q:WhC'[$e(line,i)
 q $e(line,1,i)
TrimAll(line)
 q $$TrimL($$TrimR(line))
 
  ; Conversion some Char -> XML
CtX(%)
 s %=$$TrStr^LIButil(%,"&","&amp;")
 s %=$$TrStr^LIButil(%,"<","&lt;")
 s %=$$TrStr^LIButil(%,">","&gt;")
 s %=$$TrStr^LIButil(%,"""","&quot;")
 s %=$$TrStr^LIButil(%,"'","&apos;")
 q %
.
 ;****** For batch-import to FieldList
ImpField(%,%1,%2,%3)
 n i,j,k1,k2
 f i=1:1:$l(%1,",") s j=$p(%1,",",i) i j'="" d
 .s k1=$p(j,":"),k2=$p(j,":",2)
 .s @%@(k2)=$$Val(%2_k1,%3)
 q
 ;With null-test
ImpFieldN(%,%1,%2,%3)
 n i,j,k,k1,k2
 f i=1:1:$l(%1,",") s j=$p(%1,",",i) i j'="" d
 .s k1=$p(j,":"),k2=$p(j,":",2)
 .s k=$$Val(%2_k1,%3)
 .i k'="" s @%@(k2)=k
 q
 
 ;******** Create and export XML-data structure, from scratch ****************
 
 ;Create according to data
Create(wrk,data)
 n Elevel,Cvt,i,j,k,type,Eend,WhC
 d CInit
 d NewEle("X","xml")
 d SetAll("A","version","1.0")
 d SetAll("A","encoding","UTF-8")
 d EndEle
 s i=""
 f  s i=$o(@data@(i)) q:i=""  d
 .s type=@data@(i)
 .i type="E" d  q
 ..d NewEle("E",@data@(i,1))
 ..i @data@(i,2)'="" d SetAll("V",$$CtX(@data@(i,2)))
 .i type="A" d SetAll("A",@data@(i,1),@data@(i,2))
 .i type="CE" d
 ..s j=+$g(@data@(i,1))
 ..i 'j s j=1
 ..f k=1:1:j d EndEle
.
 q 
 
 ;Export XML-data from filled-structure
Export(wrk,src)
 n Count,i,j,txt
 k @src
 s Count=0
 ;XML-header  - node 1
 s txt="<?xml "
 s i=""
 f  s i=$o(^ZXMLTMP(wrk,"D",1,i)) q:i=""  d
 .s j=^ZXMLTMP(wrk,"D",1,i)
 .i $p(j,"\")="A" s txt=txt_$p(j,"\",2)_"="""_$p(j,"\",3)_""" "
 s txt=txt_"?>"
 d EWri(txt)
 ;Main data   - node 2
 s i=$p($g(^ZXMLTMP(wrk,"D",2)),"\",2)
 d Export1(i,">"_i)
 q
Export1(ret,ref)
 n i,j,k,l,type,val,txt,err,errc,items
 d AtributsVal(ref,wrk,.items)
 s k="",txt="<"_ret
 f  s k=$o(items(k)) q:k=""  s txt=txt_" "_k_"="""_items(k)_""""
 s errc=$$TestVal(ref,wrk)
 s err=$$ElementsO(ref,wrk,.items)
 i err,'errc s txt=txt_" /"
 d EWri(txt_">")
 i errc s txt=$tr($$Val(ref,wrk),$c(13,10)) i txt'="" d EWri(txt)
 i 'err d
 .s errc=1
 .s i=""
 .f  s i=$o(items(i)) q:i=""  d
 ..s l=items(i)
 ..f j=1:1 s err=$$TestElem(ref_">"_l_"#"_j,wrk) q:'err  d Export1(l,ref_">"_l_"#"_j)
 i errc d EWri("</"_ret_">")
 q 
EWri(%)
 s Count=Count+1,@src@(Count)=%
 q
 
 ; Utilities to build instruction's list
 ;New element
NewElem(%,%1,%2)
 n i
 s i=$zp(@%@(""))+1
 s @%@(i)="E",@%@(i,1)=%1,@%@(i,2)=$g(%2)
 q
 ;New elements - batch
NewElemB(%,%1)
 n i,j
 f i=1:1:$l(%1,",") s j=$p(%1,",",i) d NewElem(%,$p(j,":"),$p(j,":",2))
 q 
 ;New element - close
NewElemC(%,%1,%2)
 d NewElem(%,%1,%2)
 d CloseElem(%)
 q
 ;New element - with attributes
NewElemAt(%,%1,%2)
 d NewElem(%,%1)
 d NewAttrB(%,%2)
 q 
 ;New element - with attributes, closed
NewElemAtC(%,%1,%2)
 d NewElemAt(%,%1,%2)
 d CloseElem(%)
 q 
 ;New element - value, with attributes, closed
NewElemVAtC(%,%1,%2,%3)
 d NewElem(%,%1,%2)
 d NewAttrB(%,%3)
 d CloseElem(%)
 q 
 ;New attribut
NewAttr(%,%1,%2)
 n i
 s i=$zp(@%@(""))+1
 s @%@(i)="A",@%@(i,1)=%1,@%@(i,2)=$g(%2)
 q
 ;New attributs - batch, separated by double-colon/comma
NewAttrB(%,%1)
 n i,j
 f i=1:1:$l(%1,",") s j=$p(%1,",",i) d NewAttr(%,$p(j,":"),$p(j,":",2))
 q
 ;Close element
CloseElem(%,%1) 
 n i
 s i=$zp(@%@(""))+1
 s @%@(i)="CE",@%@(i,1)=$g(%1)
 q
 
 ;******* Change existing tree ******************************
  
 ;Change existing value according to path, return 0-OK,1-error,don't exist
ChangeVal(%,%1,%2)
 n i,j,k,ret,wrk
 s wrk=%2
 s j=$$Ref(%)
 i j="" q 1
 s i="",j=j_",i)",ret=1
 f  s i=$o(@j) q:i=""  d  q:'ret
 .s k=$g(@j)
 .i $p(k,"\")="V" s @j="V\"_%1,ret=0
 q ret
 ;Change existing attribut according to path
ChangeAttr(%,%1,%2,%3)
 n i,j,k,ret,wrk
 s wrk=%3
 s j=$$Ref(%)
 i j="" q 1
 s i="",j=j_",i)",ret=1
 f  s i=$o(@j) q:i=""  d  q:'ret
 .s k=$g(@j)
 .i $p(k,"\")="A",$p(k,"\",2)=%1 s @j="A\"_%1_"\"_%2,ret=0
 q ret
 ;Add value according to path
AddVal(%,%1,%2)
 n i,j,k,ret,wrk
 s wrk=%2
 i '$$ChangeVal(%,%1,%2) q 0
 s j=$$NewRef(%)
 s i="",j=j_",i)"
 s i=$zp(@j)+1
 s @j="V\"_%1 
 q 0
 ;Add attribute according to path
AddAttr(%,%1,%2,%3) 
 n i,j,k,ret,wrk
 s wrk=%3
 i '$$ChangeAttr(%,%1,%2,%3) q 0
 s j=$$NewRef(%)
 s i="",j=j_",i)"
 s i=$zp(@j)+1
 s @j="A\"_%1_"\"_%2
 q 0
 
 ;******* TESTING *******************
 ;Test create and export 
Test
 n wrk,bzd
 d NewElemB("bzd","Form,Button")
 d NewAttrB("bzd","Label:Ulozit,Method:post")
 d NewElem("bzd","FormMap")
 d NewAttr("bzd","FormProperty","HlavickaZadanky.Urgency")
 d CloseElem("bzd")
 d NewElemAtC("bzd","FormMap","FormProperty:HlavickaZadanky.Jedna")
 d NewElemAtC("bzd","FormMap","FormProperty:HlavickaZadanky.Druha")
 d CloseElem("bzd")
 d NewElem("bzd","Dependencies")
 d NewElem("bzd","TestVal","Hodnota")
 ;Create XML-tree
 s wrk=$$Init()
 d Create(wrk,"bzd")
 w $$ChangeVal(">Form>Dependencies>TestVal","Hodnota2",wrk),!
 w $$ChangeAttr(">Form>Button","Label","Ulozit2",wrk),!
 w $$AddVal(">Form>Uzovka>Typ","obojkova",wrk),!
 w $$AddAttr(">Form>Uzovka>Typ","Vlozil","Slavek",wrk),!
 d Export(wrk,"bze")
 d Release(wrk)
 q
.



